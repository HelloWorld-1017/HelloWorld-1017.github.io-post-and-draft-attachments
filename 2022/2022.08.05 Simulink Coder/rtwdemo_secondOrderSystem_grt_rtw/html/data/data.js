var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"rtwdemo_secondOrderSystem","ref":false,"files":[{"name":"rtwdemo_secondOrderSystem.c","type":"source","group":"model","path":"C:\\Users\\m\\Desktop\\TestSimulinkCoder\\rtwdemo_secondOrderSystem_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * rtwdemo_secondOrderSystem.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"rtwdemo_secondOrderSystem\".\r\n *\r\n * Model version              : 5.4\r\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\r\n * C source code generated on : Fri Aug  5 15:49:16 2022\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtwdemo_secondOrderSystem.h\"\r\n#include <math.h>\r\n#include \"rtwtypes.h\"\r\n#include \"rtwdemo_secondOrderSystem_private.h\"\r\n\r\n/* Block signals (default storage) */\r\nB_rtwdemo_secondOrderSystem_T rtwdemo_secondOrderSystem_B;\r\n\r\n/* Continuous states */\r\nX_rtwdemo_secondOrderSystem_T rtwdemo_secondOrderSystem_X;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_rtwdemo_secondOrderS_T rtwdemo_secondOrderSystem_M_;\r\nRT_MODEL_rtwdemo_secondOrderS_T *const rtwdemo_secondOrderSystem_M =\r\n  &rtwdemo_secondOrderSystem_M_;\r\n\r\n/*\r\n * This function updates continuous states using the ODE3 fixed-step\r\n * solver algorithm\r\n */\r\nstatic void rt_ertODEUpdateContinuousStates(RTWSolverInfo *si )\r\n{\r\n  /* Solver Matrices */\r\n  static const real_T rt_ODE3_A[3] = {\r\n    1.0/2.0, 3.0/4.0, 1.0\r\n  };\r\n\r\n  static const real_T rt_ODE3_B[3][3] = {\r\n    { 1.0/2.0, 0.0, 0.0 },\r\n\r\n    { 0.0, 3.0/4.0, 0.0 },\r\n\r\n    { 2.0/9.0, 1.0/3.0, 4.0/9.0 }\r\n  };\r\n\r\n  time_T t = rtsiGetT(si);\r\n  time_T tnew = rtsiGetSolverStopTime(si);\r\n  time_T h = rtsiGetStepSize(si);\r\n  real_T *x = rtsiGetContStates(si);\r\n  ODE3_IntgData *id = (ODE3_IntgData *)rtsiGetSolverData(si);\r\n  real_T *y = id->y;\r\n  real_T *f0 = id->f[0];\r\n  real_T *f1 = id->f[1];\r\n  real_T *f2 = id->f[2];\r\n  real_T hB[3];\r\n  int_T i;\r\n  int_T nXc = 2;\r\n  rtsiSetSimTimeStep(si,MINOR_TIME_STEP);\r\n\r\n  /* Save the state values at time t in y, we'll use x as ynew. */\r\n  (void) memcpy(y, x,\r\n                (uint_T)nXc*sizeof(real_T));\r\n\r\n  /* Assumes that rtsiSetT and ModelOutputs are up-to-date */\r\n  /* f0 = f(t,y) */\r\n  rtsiSetdX(si, f0);\r\n  rtwdemo_secondOrderSystem_derivatives();\r\n\r\n  /* f(:,2) = feval(odefile, t + hA(1), y + f*hB(:,1), args(:)(*)); */\r\n  hB[0] = h * rt_ODE3_B[0][0];\r\n  for (i = 0; i < nXc; i++) {\r\n    x[i] = y[i] + (f0[i]*hB[0]);\r\n  }\r\n\r\n  rtsiSetT(si, t + h*rt_ODE3_A[0]);\r\n  rtsiSetdX(si, f1);\r\n  rtwdemo_secondOrderSystem_step();\r\n  rtwdemo_secondOrderSystem_derivatives();\r\n\r\n  /* f(:,3) = feval(odefile, t + hA(2), y + f*hB(:,2), args(:)(*)); */\r\n  for (i = 0; i <= 1; i++) {\r\n    hB[i] = h * rt_ODE3_B[1][i];\r\n  }\r\n\r\n  for (i = 0; i < nXc; i++) {\r\n    x[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1]);\r\n  }\r\n\r\n  rtsiSetT(si, t + h*rt_ODE3_A[1]);\r\n  rtsiSetdX(si, f2);\r\n  rtwdemo_secondOrderSystem_step();\r\n  rtwdemo_secondOrderSystem_derivatives();\r\n\r\n  /* tnew = t + hA(3);\r\n     ynew = y + f*hB(:,3); */\r\n  for (i = 0; i <= 2; i++) {\r\n    hB[i] = h * rt_ODE3_B[2][i];\r\n  }\r\n\r\n  for (i = 0; i < nXc; i++) {\r\n    x[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1] + f2[i]*hB[2]);\r\n  }\r\n\r\n  rtsiSetT(si, tnew);\r\n  rtsiSetSimTimeStep(si,MAJOR_TIME_STEP);\r\n}\r\n\r\n/* Model step function */\r\nvoid rtwdemo_secondOrderSystem_step(void)\r\n{\r\n  real_T temp;\r\n  if (rtmIsMajorTimeStep(rtwdemo_secondOrderSystem_M)) {\r\n    /* set solver stop time */\r\n    if (!(rtwdemo_secondOrderSystem_M->Timing.clockTick0+1)) {\r\n      rtsiSetSolverStopTime(&rtwdemo_secondOrderSystem_M->solverInfo,\r\n                            ((rtwdemo_secondOrderSystem_M->Timing.clockTickH0 +\r\n        1) * rtwdemo_secondOrderSystem_M->Timing.stepSize0 * 4294967296.0));\r\n    } else {\r\n      rtsiSetSolverStopTime(&rtwdemo_secondOrderSystem_M->solverInfo,\r\n                            ((rtwdemo_secondOrderSystem_M->Timing.clockTick0 + 1)\r\n        * rtwdemo_secondOrderSystem_M->Timing.stepSize0 +\r\n        rtwdemo_secondOrderSystem_M->Timing.clockTickH0 *\r\n        rtwdemo_secondOrderSystem_M->Timing.stepSize0 * 4294967296.0));\r\n    }\r\n  }                                    /* end MajorTimeStep */\r\n\r\n  /* Update absolute time of base rate at minor time step */\r\n  if (rtmIsMinorTimeStep(rtwdemo_secondOrderSystem_M)) {\r\n    rtwdemo_secondOrderSystem_M->Timing.t[0] = rtsiGetT\r\n      (&rtwdemo_secondOrderSystem_M->solverInfo);\r\n  }\r\n\r\n  /* SignalGenerator: '<Root>/Force: f(t)' */\r\n  temp = rtwdemo_secondOrderSystem_P.Forceft_Frequency *\r\n    rtwdemo_secondOrderSystem_M->Timing.t[0];\r\n  if (temp - floor(temp) >= 0.5) {\r\n    /* SignalGenerator: '<Root>/Force: f(t)' */\r\n    rtwdemo_secondOrderSystem_B.Forceft =\r\n      rtwdemo_secondOrderSystem_P.Forceft_Amplitude;\r\n  } else {\r\n    /* SignalGenerator: '<Root>/Force: f(t)' */\r\n    rtwdemo_secondOrderSystem_B.Forceft =\r\n      -rtwdemo_secondOrderSystem_P.Forceft_Amplitude;\r\n  }\r\n\r\n  /* End of SignalGenerator: '<Root>/Force: f(t)' */\r\n  if (rtmIsMajorTimeStep(rtwdemo_secondOrderSystem_M)) {\r\n  }\r\n\r\n  /* Integrator: '<Root>/Integrator2' */\r\n  rtwdemo_secondOrderSystem_B.X = rtwdemo_secondOrderSystem_X.Integrator2_CSTATE;\r\n  if (rtmIsMajorTimeStep(rtwdemo_secondOrderSystem_M)) {\r\n  }\r\n\r\n  /* Integrator: '<Root>/Integrator1' */\r\n  rtwdemo_secondOrderSystem_B.X_h =\r\n    rtwdemo_secondOrderSystem_X.Integrator1_CSTATE;\r\n\r\n  /* Gain: '<Root>/Damping' */\r\n  rtwdemo_secondOrderSystem_B.Damping = rtwdemo_secondOrderSystem_P.Damping_Gain\r\n    * rtwdemo_secondOrderSystem_B.X_h;\r\n\r\n  /* Gain: '<Root>/Stiffness' */\r\n  rtwdemo_secondOrderSystem_B.Stiffness =\r\n    rtwdemo_secondOrderSystem_P.Stiffness_Gain * rtwdemo_secondOrderSystem_B.X;\r\n\r\n  /* Gain: '<Root>/Mass' */\r\n  rtwdemo_secondOrderSystem_B.Mass = rtwdemo_secondOrderSystem_P.Mass_Gain *\r\n    rtwdemo_secondOrderSystem_B.Forceft;\r\n\r\n  /* MATLAB Function: '<Root>/MATLAB Function' */\r\n  /* :  X = (-Stiffness+Mass-Damping); */\r\n  rtwdemo_secondOrderSystem_B.X_f = (-rtwdemo_secondOrderSystem_B.Stiffness +\r\n    rtwdemo_secondOrderSystem_B.Mass) - rtwdemo_secondOrderSystem_B.Damping;\r\n  if (rtmIsMajorTimeStep(rtwdemo_secondOrderSystem_M)) {\r\n    /* External mode */\r\n    rtExtModeUploadCheckTrigger(2);\r\n\r\n    {                                  /* Sample time: [0.0s, 0.0s] */\r\n      rtExtModeUpload(0, (real_T)rtwdemo_secondOrderSystem_M->Timing.t[0]);\r\n    }\r\n\r\n    if (rtmIsMajorTimeStep(rtwdemo_secondOrderSystem_M)) {/* Sample time: [0.001s, 0.0s] */\r\n      rtExtModeUpload(1, (real_T)\r\n                      (((rtwdemo_secondOrderSystem_M->Timing.clockTick1+\r\n                         rtwdemo_secondOrderSystem_M->Timing.clockTickH1*\r\n                         4294967296.0)) * 0.001));\r\n    }\r\n  }                                    /* end MajorTimeStep */\r\n\r\n  if (rtmIsMajorTimeStep(rtwdemo_secondOrderSystem_M)) {\r\n    /* signal main to stop simulation */\r\n    {                                  /* Sample time: [0.0s, 0.0s] */\r\n      if ((rtmGetTFinal(rtwdemo_secondOrderSystem_M)!=-1) &&\r\n          !((rtmGetTFinal(rtwdemo_secondOrderSystem_M)-\r\n             (((rtwdemo_secondOrderSystem_M->Timing.clockTick1+\r\n                rtwdemo_secondOrderSystem_M->Timing.clockTickH1* 4294967296.0)) *\r\n              0.001)) > (((rtwdemo_secondOrderSystem_M->Timing.clockTick1+\r\n                           rtwdemo_secondOrderSystem_M->Timing.clockTickH1*\r\n                           4294967296.0)) * 0.001) * (DBL_EPSILON))) {\r\n        rtmSetErrorStatus(rtwdemo_secondOrderSystem_M, \"Simulation finished\");\r\n      }\r\n\r\n      if (rtmGetStopRequested(rtwdemo_secondOrderSystem_M)) {\r\n        rtmSetErrorStatus(rtwdemo_secondOrderSystem_M, \"Simulation finished\");\r\n      }\r\n    }\r\n\r\n    rt_ertODEUpdateContinuousStates(&rtwdemo_secondOrderSystem_M->solverInfo);\r\n\r\n    /* Update absolute time for base rate */\r\n    /* The \"clockTick0\" counts the number of times the code of this task has\r\n     * been executed. The absolute time is the multiplication of \"clockTick0\"\r\n     * and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not\r\n     * overflow during the application lifespan selected.\r\n     * Timer of this task consists of two 32 bit unsigned integers.\r\n     * The two integers represent the low bits Timing.clockTick0 and the high bits\r\n     * Timing.clockTickH0. When the low bit overflows to 0, the high bits increment.\r\n     */\r\n    if (!(++rtwdemo_secondOrderSystem_M->Timing.clockTick0)) {\r\n      ++rtwdemo_secondOrderSystem_M->Timing.clockTickH0;\r\n    }\r\n\r\n    rtwdemo_secondOrderSystem_M->Timing.t[0] = rtsiGetSolverStopTime\r\n      (&rtwdemo_secondOrderSystem_M->solverInfo);\r\n\r\n    {\r\n      /* Update absolute timer for sample time: [0.001s, 0.0s] */\r\n      /* The \"clockTick1\" counts the number of times the code of this task has\r\n       * been executed. The resolution of this integer timer is 0.001, which is the step size\r\n       * of the task. Size of \"clockTick1\" ensures timer will not overflow during the\r\n       * application lifespan selected.\r\n       * Timer of this task consists of two 32 bit unsigned integers.\r\n       * The two integers represent the low bits Timing.clockTick1 and the high bits\r\n       * Timing.clockTickH1. When the low bit overflows to 0, the high bits increment.\r\n       */\r\n      rtwdemo_secondOrderSystem_M->Timing.clockTick1++;\r\n      if (!rtwdemo_secondOrderSystem_M->Timing.clockTick1) {\r\n        rtwdemo_secondOrderSystem_M->Timing.clockTickH1++;\r\n      }\r\n    }\r\n  }                                    /* end MajorTimeStep */\r\n}\r\n\r\n/* Derivatives for root system: '<Root>' */\r\nvoid rtwdemo_secondOrderSystem_derivatives(void)\r\n{\r\n  XDot_rtwdemo_secondOrderSyste_T *_rtXdot;\r\n  _rtXdot = ((XDot_rtwdemo_secondOrderSyste_T *)\r\n             rtwdemo_secondOrderSystem_M->derivs);\r\n\r\n  /* Derivatives for Integrator: '<Root>/Integrator2' */\r\n  _rtXdot->Integrator2_CSTATE = rtwdemo_secondOrderSystem_B.X_h;\r\n\r\n  /* Derivatives for Integrator: '<Root>/Integrator1' */\r\n  _rtXdot->Integrator1_CSTATE = rtwdemo_secondOrderSystem_B.X_f;\r\n}\r\n\r\n/* Model initialize function */\r\nvoid rtwdemo_secondOrderSystem_initialize(void)\r\n{\r\n  /* Registration code */\r\n\r\n  /* initialize real-time model */\r\n  (void) memset((void *)rtwdemo_secondOrderSystem_M, 0,\r\n                sizeof(RT_MODEL_rtwdemo_secondOrderS_T));\r\n\r\n  {\r\n    /* Setup solver object */\r\n    rtsiSetSimTimeStepPtr(&rtwdemo_secondOrderSystem_M->solverInfo,\r\n                          &rtwdemo_secondOrderSystem_M->Timing.simTimeStep);\r\n    rtsiSetTPtr(&rtwdemo_secondOrderSystem_M->solverInfo, &rtmGetTPtr\r\n                (rtwdemo_secondOrderSystem_M));\r\n    rtsiSetStepSizePtr(&rtwdemo_secondOrderSystem_M->solverInfo,\r\n                       &rtwdemo_secondOrderSystem_M->Timing.stepSize0);\r\n    rtsiSetdXPtr(&rtwdemo_secondOrderSystem_M->solverInfo,\r\n                 &rtwdemo_secondOrderSystem_M->derivs);\r\n    rtsiSetContStatesPtr(&rtwdemo_secondOrderSystem_M->solverInfo, (real_T **)\r\n                         &rtwdemo_secondOrderSystem_M->contStates);\r\n    rtsiSetNumContStatesPtr(&rtwdemo_secondOrderSystem_M->solverInfo,\r\n      &rtwdemo_secondOrderSystem_M->Sizes.numContStates);\r\n    rtsiSetNumPeriodicContStatesPtr(&rtwdemo_secondOrderSystem_M->solverInfo,\r\n      &rtwdemo_secondOrderSystem_M->Sizes.numPeriodicContStates);\r\n    rtsiSetPeriodicContStateIndicesPtr(&rtwdemo_secondOrderSystem_M->solverInfo,\r\n      &rtwdemo_secondOrderSystem_M->periodicContStateIndices);\r\n    rtsiSetPeriodicContStateRangesPtr(&rtwdemo_secondOrderSystem_M->solverInfo,\r\n      &rtwdemo_secondOrderSystem_M->periodicContStateRanges);\r\n    rtsiSetErrorStatusPtr(&rtwdemo_secondOrderSystem_M->solverInfo,\r\n                          (&rtmGetErrorStatus(rtwdemo_secondOrderSystem_M)));\r\n    rtsiSetRTModelPtr(&rtwdemo_secondOrderSystem_M->solverInfo,\r\n                      rtwdemo_secondOrderSystem_M);\r\n  }\r\n\r\n  rtsiSetSimTimeStep(&rtwdemo_secondOrderSystem_M->solverInfo, MAJOR_TIME_STEP);\r\n  rtwdemo_secondOrderSystem_M->intgData.y = rtwdemo_secondOrderSystem_M->odeY;\r\n  rtwdemo_secondOrderSystem_M->intgData.f[0] = rtwdemo_secondOrderSystem_M->\r\n    odeF[0];\r\n  rtwdemo_secondOrderSystem_M->intgData.f[1] = rtwdemo_secondOrderSystem_M->\r\n    odeF[1];\r\n  rtwdemo_secondOrderSystem_M->intgData.f[2] = rtwdemo_secondOrderSystem_M->\r\n    odeF[2];\r\n  rtwdemo_secondOrderSystem_M->contStates = ((X_rtwdemo_secondOrderSystem_T *)\r\n    &rtwdemo_secondOrderSystem_X);\r\n  rtsiSetSolverData(&rtwdemo_secondOrderSystem_M->solverInfo, (void *)\r\n                    &rtwdemo_secondOrderSystem_M->intgData);\r\n  rtsiSetIsMinorTimeStepWithModeChange(&rtwdemo_secondOrderSystem_M->solverInfo,\r\n    false);\r\n  rtsiSetSolverName(&rtwdemo_secondOrderSystem_M->solverInfo,\"ode3\");\r\n  rtmSetTPtr(rtwdemo_secondOrderSystem_M,\r\n             &rtwdemo_secondOrderSystem_M->Timing.tArray[0]);\r\n  rtmSetTFinal(rtwdemo_secondOrderSystem_M, 0.02);\r\n  rtwdemo_secondOrderSystem_M->Timing.stepSize0 = 0.001;\r\n\r\n  /* External mode info */\r\n  rtwdemo_secondOrderSystem_M->Sizes.checksums[0] = (2520051404U);\r\n  rtwdemo_secondOrderSystem_M->Sizes.checksums[1] = (1521222935U);\r\n  rtwdemo_secondOrderSystem_M->Sizes.checksums[2] = (694317596U);\r\n  rtwdemo_secondOrderSystem_M->Sizes.checksums[3] = (2740652019U);\r\n\r\n  {\r\n    static const sysRanDType rtAlwaysEnabled = SUBSYS_RAN_BC_ENABLE;\r\n    static RTWExtModeInfo rt_ExtModeInfo;\r\n    static const sysRanDType *systemRan[2];\r\n    rtwdemo_secondOrderSystem_M->extModeInfo = (&rt_ExtModeInfo);\r\n    rteiSetSubSystemActiveVectorAddresses(&rt_ExtModeInfo, systemRan);\r\n    systemRan[0] = &rtAlwaysEnabled;\r\n    systemRan[1] = &rtAlwaysEnabled;\r\n    rteiSetModelMappingInfoPtr(rtwdemo_secondOrderSystem_M->extModeInfo,\r\n      &rtwdemo_secondOrderSystem_M->SpecialInfo.mappingInfo);\r\n    rteiSetChecksumsPtr(rtwdemo_secondOrderSystem_M->extModeInfo,\r\n                        rtwdemo_secondOrderSystem_M->Sizes.checksums);\r\n    rteiSetTPtr(rtwdemo_secondOrderSystem_M->extModeInfo, rtmGetTPtr\r\n                (rtwdemo_secondOrderSystem_M));\r\n  }\r\n\r\n  /* block I/O */\r\n  {\r\n    rtwdemo_secondOrderSystem_B.Forceft = 0.0;\r\n    rtwdemo_secondOrderSystem_B.X = 0.0;\r\n    rtwdemo_secondOrderSystem_B.X_h = 0.0;\r\n    rtwdemo_secondOrderSystem_B.Damping = 0.0;\r\n    rtwdemo_secondOrderSystem_B.Stiffness = 0.0;\r\n    rtwdemo_secondOrderSystem_B.Mass = 0.0;\r\n    rtwdemo_secondOrderSystem_B.X_f = 0.0;\r\n  }\r\n\r\n  /* states (continuous) */\r\n  {\r\n    (void) memset((void *)&rtwdemo_secondOrderSystem_X, 0,\r\n                  sizeof(X_rtwdemo_secondOrderSystem_T));\r\n  }\r\n\r\n  /* InitializeConditions for Integrator: '<Root>/Integrator2' */\r\n  rtwdemo_secondOrderSystem_X.Integrator2_CSTATE =\r\n    rtwdemo_secondOrderSystem_P.Integrator2_IC;\r\n\r\n  /* InitializeConditions for Integrator: '<Root>/Integrator1' */\r\n  rtwdemo_secondOrderSystem_X.Integrator1_CSTATE =\r\n    rtwdemo_secondOrderSystem_P.Integrator1_IC;\r\n}\r\n\r\n/* Model terminate function */\r\nvoid rtwdemo_secondOrderSystem_terminate(void)\r\n{\r\n  /* (no terminate code required) */\r\n}\r\n"},{"name":"rtwdemo_secondOrderSystem.h","type":"header","group":"model","path":"C:\\Users\\m\\Desktop\\TestSimulinkCoder\\rtwdemo_secondOrderSystem_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * rtwdemo_secondOrderSystem.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"rtwdemo_secondOrderSystem\".\r\n *\r\n * Model version              : 5.4\r\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\r\n * C source code generated on : Fri Aug  5 15:49:16 2022\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtwdemo_secondOrderSystem_h_\r\n#define RTW_HEADER_rtwdemo_secondOrderSystem_h_\r\n#ifndef rtwdemo_secondOrderSystem_COMMON_INCLUDES_\r\n#define rtwdemo_secondOrderSystem_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#include \"rtw_extmode.h\"\r\n#include \"sysran_types.h\"\r\n#include \"rtw_continuous.h\"\r\n#include \"rtw_solver.h\"\r\n#include \"ext_work.h\"\r\n#endif                          /* rtwdemo_secondOrderSystem_COMMON_INCLUDES_ */\r\n\r\n#include \"rtwdemo_secondOrderSystem_types.h\"\r\n#include <float.h>\r\n#include <string.h>\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetContStateDisabled\r\n#define rtmGetContStateDisabled(rtm)   ((rtm)->contStateDisabled)\r\n#endif\r\n\r\n#ifndef rtmSetContStateDisabled\r\n#define rtmSetContStateDisabled(rtm, val) ((rtm)->contStateDisabled = (val))\r\n#endif\r\n\r\n#ifndef rtmGetContStates\r\n#define rtmGetContStates(rtm)          ((rtm)->contStates)\r\n#endif\r\n\r\n#ifndef rtmSetContStates\r\n#define rtmSetContStates(rtm, val)     ((rtm)->contStates = (val))\r\n#endif\r\n\r\n#ifndef rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag\r\n#define rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm) ((rtm)->CTOutputIncnstWithState)\r\n#endif\r\n\r\n#ifndef rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag\r\n#define rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm, val) ((rtm)->CTOutputIncnstWithState = (val))\r\n#endif\r\n\r\n#ifndef rtmGetDerivCacheNeedsReset\r\n#define rtmGetDerivCacheNeedsReset(rtm) ((rtm)->derivCacheNeedsReset)\r\n#endif\r\n\r\n#ifndef rtmSetDerivCacheNeedsReset\r\n#define rtmSetDerivCacheNeedsReset(rtm, val) ((rtm)->derivCacheNeedsReset = (val))\r\n#endif\r\n\r\n#ifndef rtmGetFinalTime\r\n#define rtmGetFinalTime(rtm)           ((rtm)->Timing.tFinal)\r\n#endif\r\n\r\n#ifndef rtmGetIntgData\r\n#define rtmGetIntgData(rtm)            ((rtm)->intgData)\r\n#endif\r\n\r\n#ifndef rtmSetIntgData\r\n#define rtmSetIntgData(rtm, val)       ((rtm)->intgData = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOdeF\r\n#define rtmGetOdeF(rtm)                ((rtm)->odeF)\r\n#endif\r\n\r\n#ifndef rtmSetOdeF\r\n#define rtmSetOdeF(rtm, val)           ((rtm)->odeF = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOdeY\r\n#define rtmGetOdeY(rtm)                ((rtm)->odeY)\r\n#endif\r\n\r\n#ifndef rtmSetOdeY\r\n#define rtmSetOdeY(rtm, val)           ((rtm)->odeY = (val))\r\n#endif\r\n\r\n#ifndef rtmGetPeriodicContStateIndices\r\n#define rtmGetPeriodicContStateIndices(rtm) ((rtm)->periodicContStateIndices)\r\n#endif\r\n\r\n#ifndef rtmSetPeriodicContStateIndices\r\n#define rtmSetPeriodicContStateIndices(rtm, val) ((rtm)->periodicContStateIndices = (val))\r\n#endif\r\n\r\n#ifndef rtmGetPeriodicContStateRanges\r\n#define rtmGetPeriodicContStateRanges(rtm) ((rtm)->periodicContStateRanges)\r\n#endif\r\n\r\n#ifndef rtmSetPeriodicContStateRanges\r\n#define rtmSetPeriodicContStateRanges(rtm, val) ((rtm)->periodicContStateRanges = (val))\r\n#endif\r\n\r\n#ifndef rtmGetRTWExtModeInfo\r\n#define rtmGetRTWExtModeInfo(rtm)      ((rtm)->extModeInfo)\r\n#endif\r\n\r\n#ifndef rtmGetZCCacheNeedsReset\r\n#define rtmGetZCCacheNeedsReset(rtm)   ((rtm)->zCCacheNeedsReset)\r\n#endif\r\n\r\n#ifndef rtmSetZCCacheNeedsReset\r\n#define rtmSetZCCacheNeedsReset(rtm, val) ((rtm)->zCCacheNeedsReset = (val))\r\n#endif\r\n\r\n#ifndef rtmGetdX\r\n#define rtmGetdX(rtm)                  ((rtm)->derivs)\r\n#endif\r\n\r\n#ifndef rtmSetdX\r\n#define rtmSetdX(rtm, val)             ((rtm)->derivs = (val))\r\n#endif\r\n\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((rtm)->Timing.stopRequestedFlag)\r\n#endif\r\n\r\n#ifndef rtmSetStopRequested\r\n#define rtmSetStopRequested(rtm, val)  ((rtm)->Timing.stopRequestedFlag = (val))\r\n#endif\r\n\r\n#ifndef rtmGetStopRequestedPtr\r\n#define rtmGetStopRequestedPtr(rtm)    (&((rtm)->Timing.stopRequestedFlag))\r\n#endif\r\n\r\n#ifndef rtmGetT\r\n#define rtmGetT(rtm)                   (rtmGetTPtr((rtm))[0])\r\n#endif\r\n\r\n#ifndef rtmGetTFinal\r\n#define rtmGetTFinal(rtm)              ((rtm)->Timing.tFinal)\r\n#endif\r\n\r\n#ifndef rtmGetTPtr\r\n#define rtmGetTPtr(rtm)                ((rtm)->Timing.t)\r\n#endif\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  real_T Forceft;                      /* '<Root>/Force: f(t)' */\r\n  real_T X;                            /* '<Root>/Integrator2' */\r\n  real_T X_h;                          /* '<Root>/Integrator1' */\r\n  real_T Damping;                      /* '<Root>/Damping' */\r\n  real_T Stiffness;                    /* '<Root>/Stiffness' */\r\n  real_T Mass;                         /* '<Root>/Mass' */\r\n  real_T X_f;                          /* '<Root>/MATLAB Function' */\r\n} B_rtwdemo_secondOrderSystem_T;\r\n\r\n/* Continuous states (default storage) */\r\ntypedef struct {\r\n  real_T Integrator2_CSTATE;           /* '<Root>/Integrator2' */\r\n  real_T Integrator1_CSTATE;           /* '<Root>/Integrator1' */\r\n} X_rtwdemo_secondOrderSystem_T;\r\n\r\n/* State derivatives (default storage) */\r\ntypedef struct {\r\n  real_T Integrator2_CSTATE;           /* '<Root>/Integrator2' */\r\n  real_T Integrator1_CSTATE;           /* '<Root>/Integrator1' */\r\n} XDot_rtwdemo_secondOrderSyste_T;\r\n\r\n/* State disabled  */\r\ntypedef struct {\r\n  boolean_T Integrator2_CSTATE;        /* '<Root>/Integrator2' */\r\n  boolean_T Integrator1_CSTATE;        /* '<Root>/Integrator1' */\r\n} XDis_rtwdemo_secondOrderSyste_T;\r\n\r\n#ifndef ODE3_INTG\r\n#define ODE3_INTG\r\n\r\n/* ODE3 Integration Data */\r\ntypedef struct {\r\n  real_T *y;                           /* output */\r\n  real_T *f[3];                        /* derivatives */\r\n} ODE3_IntgData;\r\n\r\n#endif\r\n\r\n/* Parameters (default storage) */\r\nstruct P_rtwdemo_secondOrderSystem_T_ {\r\n  real_T Forceft_Amplitude;            /* Expression: 4\r\n                                        * Referenced by: '<Root>/Force: f(t)'\r\n                                        */\r\n  real_T Forceft_Frequency;            /* Expression: 20\r\n                                        * Referenced by: '<Root>/Force: f(t)'\r\n                                        */\r\n  real_T Integrator2_IC;               /* Expression: 0\r\n                                        * Referenced by: '<Root>/Integrator2'\r\n                                        */\r\n  real_T Integrator1_IC;               /* Expression: 0\r\n                                        * Referenced by: '<Root>/Integrator1'\r\n                                        */\r\n  real_T Damping_Gain;                 /* Expression: 478.3853094256624\r\n                                        * Referenced by: '<Root>/Damping'\r\n                                        */\r\n  real_T Stiffness_Gain;               /* Expression: 1000000\r\n                                        * Referenced by: '<Root>/Stiffness'\r\n                                        */\r\n  real_T Mass_Gain;                    /* Expression: 1000000\r\n                                        * Referenced by: '<Root>/Mass'\r\n                                        */\r\n};\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_rtwdemo_secondOrderSy_T {\r\n  const char_T *errorStatus;\r\n  RTWExtModeInfo *extModeInfo;\r\n  RTWSolverInfo solverInfo;\r\n  X_rtwdemo_secondOrderSystem_T *contStates;\r\n  int_T *periodicContStateIndices;\r\n  real_T *periodicContStateRanges;\r\n  real_T *derivs;\r\n  boolean_T *contStateDisabled;\r\n  boolean_T zCCacheNeedsReset;\r\n  boolean_T derivCacheNeedsReset;\r\n  boolean_T CTOutputIncnstWithState;\r\n  real_T odeY[2];\r\n  real_T odeF[3][2];\r\n  ODE3_IntgData intgData;\r\n\r\n  /*\r\n   * Sizes:\r\n   * The following substructure contains sizes information\r\n   * for many of the model attributes such as inputs, outputs,\r\n   * dwork, sample times, etc.\r\n   */\r\n  struct {\r\n    uint32_T checksums[4];\r\n    int_T numContStates;\r\n    int_T numPeriodicContStates;\r\n    int_T numSampTimes;\r\n  } Sizes;\r\n\r\n  /*\r\n   * SpecialInfo:\r\n   * The following substructure contains special information\r\n   * related to other components that are dependent on RTW.\r\n   */\r\n  struct {\r\n    const void *mappingInfo;\r\n  } SpecialInfo;\r\n\r\n  /*\r\n   * Timing:\r\n   * The following substructure contains information regarding\r\n   * the timing information for the model.\r\n   */\r\n  struct {\r\n    uint32_T clockTick0;\r\n    uint32_T clockTickH0;\r\n    time_T stepSize0;\r\n    uint32_T clockTick1;\r\n    uint32_T clockTickH1;\r\n    time_T tFinal;\r\n    SimTimeStep simTimeStep;\r\n    boolean_T stopRequestedFlag;\r\n    time_T *t;\r\n    time_T tArray[2];\r\n  } Timing;\r\n};\r\n\r\n/* Block parameters (default storage) */\r\nextern P_rtwdemo_secondOrderSystem_T rtwdemo_secondOrderSystem_P;\r\n\r\n/* Block signals (default storage) */\r\nextern B_rtwdemo_secondOrderSystem_T rtwdemo_secondOrderSystem_B;\r\n\r\n/* Continuous states (default storage) */\r\nextern X_rtwdemo_secondOrderSystem_T rtwdemo_secondOrderSystem_X;\r\n\r\n/* Model entry point functions */\r\nextern void rtwdemo_secondOrderSystem_initialize(void);\r\nextern void rtwdemo_secondOrderSystem_step(void);\r\nextern void rtwdemo_secondOrderSystem_terminate(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_rtwdemo_secondOrderS_T *const rtwdemo_secondOrderSystem_M;\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'rtwdemo_secondOrderSystem'\r\n * '<S1>'   : 'rtwdemo_secondOrderSystem/MATLAB Function'\r\n */\r\n#endif                             /* RTW_HEADER_rtwdemo_secondOrderSystem_h_ */\r\n"},{"name":"rtwdemo_secondOrderSystem_private.h","type":"header","group":"model","path":"C:\\Users\\m\\Desktop\\TestSimulinkCoder\\rtwdemo_secondOrderSystem_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * rtwdemo_secondOrderSystem_private.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"rtwdemo_secondOrderSystem\".\r\n *\r\n * Model version              : 5.4\r\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\r\n * C source code generated on : Fri Aug  5 15:49:16 2022\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtwdemo_secondOrderSystem_private_h_\r\n#define RTW_HEADER_rtwdemo_secondOrderSystem_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"multiword_types.h\"\r\n\r\n/* Private macros used by the generated code to access rtModel */\r\n#ifndef rtmIsMajorTimeStep\r\n#define rtmIsMajorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MAJOR_TIME_STEP)\r\n#endif\r\n\r\n#ifndef rtmIsMinorTimeStep\r\n#define rtmIsMinorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MINOR_TIME_STEP)\r\n#endif\r\n\r\n#ifndef rtmSetTFinal\r\n#define rtmSetTFinal(rtm, val)         ((rtm)->Timing.tFinal = (val))\r\n#endif\r\n\r\n#ifndef rtmSetTPtr\r\n#define rtmSetTPtr(rtm, val)           ((rtm)->Timing.t = (val))\r\n#endif\r\n\r\n/* private model entry point functions */\r\nextern void rtwdemo_secondOrderSystem_derivatives(void);\r\n\r\n#endif                     /* RTW_HEADER_rtwdemo_secondOrderSystem_private_h_ */\r\n"},{"name":"rtwdemo_secondOrderSystem_types.h","type":"header","group":"model","path":"C:\\Users\\m\\Desktop\\TestSimulinkCoder\\rtwdemo_secondOrderSystem_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * rtwdemo_secondOrderSystem_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"rtwdemo_secondOrderSystem\".\r\n *\r\n * Model version              : 5.4\r\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\r\n * C source code generated on : Fri Aug  5 15:49:16 2022\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtwdemo_secondOrderSystem_types_h_\r\n#define RTW_HEADER_rtwdemo_secondOrderSystem_types_h_\r\n\r\n/* Model Code Variants */\r\n\r\n/* Parameters (default storage) */\r\ntypedef struct P_rtwdemo_secondOrderSystem_T_ P_rtwdemo_secondOrderSystem_T;\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_rtwdemo_secondOrderSy_T RT_MODEL_rtwdemo_secondOrderS_T;\r\n\r\n#endif                       /* RTW_HEADER_rtwdemo_secondOrderSystem_types_h_ */\r\n"},{"name":"rtwdemo_secondOrderSystem_data.c","type":"source","group":"data","path":"C:\\Users\\m\\Desktop\\TestSimulinkCoder\\rtwdemo_secondOrderSystem_grt_rtw","tag":"","groupDisplay":"Data files","code":"/*\r\n * rtwdemo_secondOrderSystem_data.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"rtwdemo_secondOrderSystem\".\r\n *\r\n * Model version              : 5.4\r\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\r\n * C source code generated on : Fri Aug  5 15:49:16 2022\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtwdemo_secondOrderSystem.h\"\r\n\r\n/* Block parameters (default storage) */\r\nP_rtwdemo_secondOrderSystem_T rtwdemo_secondOrderSystem_P = {\r\n  /* Expression: 4\r\n   * Referenced by: '<Root>/Force: f(t)'\r\n   */\r\n  4.0,\r\n\r\n  /* Expression: 20\r\n   * Referenced by: '<Root>/Force: f(t)'\r\n   */\r\n  20.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<Root>/Integrator2'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<Root>/Integrator1'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 478.3853094256624\r\n   * Referenced by: '<Root>/Damping'\r\n   */\r\n  478.3853094256624,\r\n\r\n  /* Expression: 1000000\r\n   * Referenced by: '<Root>/Stiffness'\r\n   */\r\n  1.0E+6,\r\n\r\n  /* Expression: 1000000\r\n   * Referenced by: '<Root>/Mass'\r\n   */\r\n  1.0E+6\r\n};\r\n"},{"name":"multiword_types.h","type":"header","group":"sharedutility","path":"C:\\Users\\m\\Desktop\\TestSimulinkCoder\\slprj\\grt\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * multiword_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"rtwdemo_secondOrderSystem\".\r\n *\r\n * Model version              : 5.1\r\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\r\n * C source code generated on : Thu Aug  4 23:39:13 2022\r\n */\r\n\r\n#ifndef MULTIWORD_TYPES_H\r\n#define MULTIWORD_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\n/*\r\n * Definitions supporting external data access\r\n */\r\ntypedef int32_T chunk_T;\r\ntypedef uint32_T uchunk_T;\r\n\r\n/*\r\n * MultiWord supporting definitions\r\n */\r\ntypedef long int long_T;\r\n\r\n/*\r\n * MultiWord types\r\n */\r\ntypedef struct {\r\n  uint32_T chunks[2];\r\n} int64m_T;\r\n\r\ntypedef struct {\r\n  int64m_T re;\r\n  int64m_T im;\r\n} cint64m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[2];\r\n} uint64m_T;\r\n\r\ntypedef struct {\r\n  uint64m_T re;\r\n  uint64m_T im;\r\n} cuint64m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[3];\r\n} int96m_T;\r\n\r\ntypedef struct {\r\n  int96m_T re;\r\n  int96m_T im;\r\n} cint96m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[3];\r\n} uint96m_T;\r\n\r\ntypedef struct {\r\n  uint96m_T re;\r\n  uint96m_T im;\r\n} cuint96m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[4];\r\n} int128m_T;\r\n\r\ntypedef struct {\r\n  int128m_T re;\r\n  int128m_T im;\r\n} cint128m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[4];\r\n} uint128m_T;\r\n\r\ntypedef struct {\r\n  uint128m_T re;\r\n  uint128m_T im;\r\n} cuint128m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[5];\r\n} int160m_T;\r\n\r\ntypedef struct {\r\n  int160m_T re;\r\n  int160m_T im;\r\n} cint160m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[5];\r\n} uint160m_T;\r\n\r\ntypedef struct {\r\n  uint160m_T re;\r\n  uint160m_T im;\r\n} cuint160m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[6];\r\n} int192m_T;\r\n\r\ntypedef struct {\r\n  int192m_T re;\r\n  int192m_T im;\r\n} cint192m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[6];\r\n} uint192m_T;\r\n\r\ntypedef struct {\r\n  uint192m_T re;\r\n  uint192m_T im;\r\n} cuint192m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[7];\r\n} int224m_T;\r\n\r\ntypedef struct {\r\n  int224m_T re;\r\n  int224m_T im;\r\n} cint224m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[7];\r\n} uint224m_T;\r\n\r\ntypedef struct {\r\n  uint224m_T re;\r\n  uint224m_T im;\r\n} cuint224m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[8];\r\n} int256m_T;\r\n\r\ntypedef struct {\r\n  int256m_T re;\r\n  int256m_T im;\r\n} cint256m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[8];\r\n} uint256m_T;\r\n\r\ntypedef struct {\r\n  uint256m_T re;\r\n  uint256m_T im;\r\n} cuint256m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[9];\r\n} int288m_T;\r\n\r\ntypedef struct {\r\n  int288m_T re;\r\n  int288m_T im;\r\n} cint288m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[9];\r\n} uint288m_T;\r\n\r\ntypedef struct {\r\n  uint288m_T re;\r\n  uint288m_T im;\r\n} cuint288m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[10];\r\n} int320m_T;\r\n\r\ntypedef struct {\r\n  int320m_T re;\r\n  int320m_T im;\r\n} cint320m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[10];\r\n} uint320m_T;\r\n\r\ntypedef struct {\r\n  uint320m_T re;\r\n  uint320m_T im;\r\n} cuint320m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[11];\r\n} int352m_T;\r\n\r\ntypedef struct {\r\n  int352m_T re;\r\n  int352m_T im;\r\n} cint352m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[11];\r\n} uint352m_T;\r\n\r\ntypedef struct {\r\n  uint352m_T re;\r\n  uint352m_T im;\r\n} cuint352m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[12];\r\n} int384m_T;\r\n\r\ntypedef struct {\r\n  int384m_T re;\r\n  int384m_T im;\r\n} cint384m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[12];\r\n} uint384m_T;\r\n\r\ntypedef struct {\r\n  uint384m_T re;\r\n  uint384m_T im;\r\n} cuint384m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[13];\r\n} int416m_T;\r\n\r\ntypedef struct {\r\n  int416m_T re;\r\n  int416m_T im;\r\n} cint416m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[13];\r\n} uint416m_T;\r\n\r\ntypedef struct {\r\n  uint416m_T re;\r\n  uint416m_T im;\r\n} cuint416m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[14];\r\n} int448m_T;\r\n\r\ntypedef struct {\r\n  int448m_T re;\r\n  int448m_T im;\r\n} cint448m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[14];\r\n} uint448m_T;\r\n\r\ntypedef struct {\r\n  uint448m_T re;\r\n  uint448m_T im;\r\n} cuint448m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[15];\r\n} int480m_T;\r\n\r\ntypedef struct {\r\n  int480m_T re;\r\n  int480m_T im;\r\n} cint480m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[15];\r\n} uint480m_T;\r\n\r\ntypedef struct {\r\n  uint480m_T re;\r\n  uint480m_T im;\r\n} cuint480m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[16];\r\n} int512m_T;\r\n\r\ntypedef struct {\r\n  int512m_T re;\r\n  int512m_T im;\r\n} cint512m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[16];\r\n} uint512m_T;\r\n\r\ntypedef struct {\r\n  uint512m_T re;\r\n  uint512m_T im;\r\n} cuint512m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[17];\r\n} int544m_T;\r\n\r\ntypedef struct {\r\n  int544m_T re;\r\n  int544m_T im;\r\n} cint544m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[17];\r\n} uint544m_T;\r\n\r\ntypedef struct {\r\n  uint544m_T re;\r\n  uint544m_T im;\r\n} cuint544m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[18];\r\n} int576m_T;\r\n\r\ntypedef struct {\r\n  int576m_T re;\r\n  int576m_T im;\r\n} cint576m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[18];\r\n} uint576m_T;\r\n\r\ntypedef struct {\r\n  uint576m_T re;\r\n  uint576m_T im;\r\n} cuint576m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[19];\r\n} int608m_T;\r\n\r\ntypedef struct {\r\n  int608m_T re;\r\n  int608m_T im;\r\n} cint608m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[19];\r\n} uint608m_T;\r\n\r\ntypedef struct {\r\n  uint608m_T re;\r\n  uint608m_T im;\r\n} cuint608m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[20];\r\n} int640m_T;\r\n\r\ntypedef struct {\r\n  int640m_T re;\r\n  int640m_T im;\r\n} cint640m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[20];\r\n} uint640m_T;\r\n\r\ntypedef struct {\r\n  uint640m_T re;\r\n  uint640m_T im;\r\n} cuint640m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[21];\r\n} int672m_T;\r\n\r\ntypedef struct {\r\n  int672m_T re;\r\n  int672m_T im;\r\n} cint672m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[21];\r\n} uint672m_T;\r\n\r\ntypedef struct {\r\n  uint672m_T re;\r\n  uint672m_T im;\r\n} cuint672m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[22];\r\n} int704m_T;\r\n\r\ntypedef struct {\r\n  int704m_T re;\r\n  int704m_T im;\r\n} cint704m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[22];\r\n} uint704m_T;\r\n\r\ntypedef struct {\r\n  uint704m_T re;\r\n  uint704m_T im;\r\n} cuint704m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[23];\r\n} int736m_T;\r\n\r\ntypedef struct {\r\n  int736m_T re;\r\n  int736m_T im;\r\n} cint736m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[23];\r\n} uint736m_T;\r\n\r\ntypedef struct {\r\n  uint736m_T re;\r\n  uint736m_T im;\r\n} cuint736m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[24];\r\n} int768m_T;\r\n\r\ntypedef struct {\r\n  int768m_T re;\r\n  int768m_T im;\r\n} cint768m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[24];\r\n} uint768m_T;\r\n\r\ntypedef struct {\r\n  uint768m_T re;\r\n  uint768m_T im;\r\n} cuint768m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[25];\r\n} int800m_T;\r\n\r\ntypedef struct {\r\n  int800m_T re;\r\n  int800m_T im;\r\n} cint800m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[25];\r\n} uint800m_T;\r\n\r\ntypedef struct {\r\n  uint800m_T re;\r\n  uint800m_T im;\r\n} cuint800m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[26];\r\n} int832m_T;\r\n\r\ntypedef struct {\r\n  int832m_T re;\r\n  int832m_T im;\r\n} cint832m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[26];\r\n} uint832m_T;\r\n\r\ntypedef struct {\r\n  uint832m_T re;\r\n  uint832m_T im;\r\n} cuint832m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[27];\r\n} int864m_T;\r\n\r\ntypedef struct {\r\n  int864m_T re;\r\n  int864m_T im;\r\n} cint864m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[27];\r\n} uint864m_T;\r\n\r\ntypedef struct {\r\n  uint864m_T re;\r\n  uint864m_T im;\r\n} cuint864m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[28];\r\n} int896m_T;\r\n\r\ntypedef struct {\r\n  int896m_T re;\r\n  int896m_T im;\r\n} cint896m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[28];\r\n} uint896m_T;\r\n\r\ntypedef struct {\r\n  uint896m_T re;\r\n  uint896m_T im;\r\n} cuint896m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[29];\r\n} int928m_T;\r\n\r\ntypedef struct {\r\n  int928m_T re;\r\n  int928m_T im;\r\n} cint928m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[29];\r\n} uint928m_T;\r\n\r\ntypedef struct {\r\n  uint928m_T re;\r\n  uint928m_T im;\r\n} cuint928m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[30];\r\n} int960m_T;\r\n\r\ntypedef struct {\r\n  int960m_T re;\r\n  int960m_T im;\r\n} cint960m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[30];\r\n} uint960m_T;\r\n\r\ntypedef struct {\r\n  uint960m_T re;\r\n  uint960m_T im;\r\n} cuint960m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[31];\r\n} int992m_T;\r\n\r\ntypedef struct {\r\n  int992m_T re;\r\n  int992m_T im;\r\n} cint992m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[31];\r\n} uint992m_T;\r\n\r\ntypedef struct {\r\n  uint992m_T re;\r\n  uint992m_T im;\r\n} cuint992m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[32];\r\n} int1024m_T;\r\n\r\ntypedef struct {\r\n  int1024m_T re;\r\n  int1024m_T im;\r\n} cint1024m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[32];\r\n} uint1024m_T;\r\n\r\ntypedef struct {\r\n  uint1024m_T re;\r\n  uint1024m_T im;\r\n} cuint1024m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[33];\r\n} int1056m_T;\r\n\r\ntypedef struct {\r\n  int1056m_T re;\r\n  int1056m_T im;\r\n} cint1056m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[33];\r\n} uint1056m_T;\r\n\r\ntypedef struct {\r\n  uint1056m_T re;\r\n  uint1056m_T im;\r\n} cuint1056m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[34];\r\n} int1088m_T;\r\n\r\ntypedef struct {\r\n  int1088m_T re;\r\n  int1088m_T im;\r\n} cint1088m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[34];\r\n} uint1088m_T;\r\n\r\ntypedef struct {\r\n  uint1088m_T re;\r\n  uint1088m_T im;\r\n} cuint1088m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[35];\r\n} int1120m_T;\r\n\r\ntypedef struct {\r\n  int1120m_T re;\r\n  int1120m_T im;\r\n} cint1120m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[35];\r\n} uint1120m_T;\r\n\r\ntypedef struct {\r\n  uint1120m_T re;\r\n  uint1120m_T im;\r\n} cuint1120m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[36];\r\n} int1152m_T;\r\n\r\ntypedef struct {\r\n  int1152m_T re;\r\n  int1152m_T im;\r\n} cint1152m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[36];\r\n} uint1152m_T;\r\n\r\ntypedef struct {\r\n  uint1152m_T re;\r\n  uint1152m_T im;\r\n} cuint1152m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[37];\r\n} int1184m_T;\r\n\r\ntypedef struct {\r\n  int1184m_T re;\r\n  int1184m_T im;\r\n} cint1184m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[37];\r\n} uint1184m_T;\r\n\r\ntypedef struct {\r\n  uint1184m_T re;\r\n  uint1184m_T im;\r\n} cuint1184m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[38];\r\n} int1216m_T;\r\n\r\ntypedef struct {\r\n  int1216m_T re;\r\n  int1216m_T im;\r\n} cint1216m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[38];\r\n} uint1216m_T;\r\n\r\ntypedef struct {\r\n  uint1216m_T re;\r\n  uint1216m_T im;\r\n} cuint1216m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[39];\r\n} int1248m_T;\r\n\r\ntypedef struct {\r\n  int1248m_T re;\r\n  int1248m_T im;\r\n} cint1248m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[39];\r\n} uint1248m_T;\r\n\r\ntypedef struct {\r\n  uint1248m_T re;\r\n  uint1248m_T im;\r\n} cuint1248m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[40];\r\n} int1280m_T;\r\n\r\ntypedef struct {\r\n  int1280m_T re;\r\n  int1280m_T im;\r\n} cint1280m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[40];\r\n} uint1280m_T;\r\n\r\ntypedef struct {\r\n  uint1280m_T re;\r\n  uint1280m_T im;\r\n} cuint1280m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[41];\r\n} int1312m_T;\r\n\r\ntypedef struct {\r\n  int1312m_T re;\r\n  int1312m_T im;\r\n} cint1312m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[41];\r\n} uint1312m_T;\r\n\r\ntypedef struct {\r\n  uint1312m_T re;\r\n  uint1312m_T im;\r\n} cuint1312m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[42];\r\n} int1344m_T;\r\n\r\ntypedef struct {\r\n  int1344m_T re;\r\n  int1344m_T im;\r\n} cint1344m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[42];\r\n} uint1344m_T;\r\n\r\ntypedef struct {\r\n  uint1344m_T re;\r\n  uint1344m_T im;\r\n} cuint1344m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[43];\r\n} int1376m_T;\r\n\r\ntypedef struct {\r\n  int1376m_T re;\r\n  int1376m_T im;\r\n} cint1376m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[43];\r\n} uint1376m_T;\r\n\r\ntypedef struct {\r\n  uint1376m_T re;\r\n  uint1376m_T im;\r\n} cuint1376m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[44];\r\n} int1408m_T;\r\n\r\ntypedef struct {\r\n  int1408m_T re;\r\n  int1408m_T im;\r\n} cint1408m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[44];\r\n} uint1408m_T;\r\n\r\ntypedef struct {\r\n  uint1408m_T re;\r\n  uint1408m_T im;\r\n} cuint1408m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[45];\r\n} int1440m_T;\r\n\r\ntypedef struct {\r\n  int1440m_T re;\r\n  int1440m_T im;\r\n} cint1440m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[45];\r\n} uint1440m_T;\r\n\r\ntypedef struct {\r\n  uint1440m_T re;\r\n  uint1440m_T im;\r\n} cuint1440m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[46];\r\n} int1472m_T;\r\n\r\ntypedef struct {\r\n  int1472m_T re;\r\n  int1472m_T im;\r\n} cint1472m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[46];\r\n} uint1472m_T;\r\n\r\ntypedef struct {\r\n  uint1472m_T re;\r\n  uint1472m_T im;\r\n} cuint1472m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[47];\r\n} int1504m_T;\r\n\r\ntypedef struct {\r\n  int1504m_T re;\r\n  int1504m_T im;\r\n} cint1504m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[47];\r\n} uint1504m_T;\r\n\r\ntypedef struct {\r\n  uint1504m_T re;\r\n  uint1504m_T im;\r\n} cuint1504m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[48];\r\n} int1536m_T;\r\n\r\ntypedef struct {\r\n  int1536m_T re;\r\n  int1536m_T im;\r\n} cint1536m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[48];\r\n} uint1536m_T;\r\n\r\ntypedef struct {\r\n  uint1536m_T re;\r\n  uint1536m_T im;\r\n} cuint1536m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[49];\r\n} int1568m_T;\r\n\r\ntypedef struct {\r\n  int1568m_T re;\r\n  int1568m_T im;\r\n} cint1568m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[49];\r\n} uint1568m_T;\r\n\r\ntypedef struct {\r\n  uint1568m_T re;\r\n  uint1568m_T im;\r\n} cuint1568m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[50];\r\n} int1600m_T;\r\n\r\ntypedef struct {\r\n  int1600m_T re;\r\n  int1600m_T im;\r\n} cint1600m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[50];\r\n} uint1600m_T;\r\n\r\ntypedef struct {\r\n  uint1600m_T re;\r\n  uint1600m_T im;\r\n} cuint1600m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[51];\r\n} int1632m_T;\r\n\r\ntypedef struct {\r\n  int1632m_T re;\r\n  int1632m_T im;\r\n} cint1632m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[51];\r\n} uint1632m_T;\r\n\r\ntypedef struct {\r\n  uint1632m_T re;\r\n  uint1632m_T im;\r\n} cuint1632m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[52];\r\n} int1664m_T;\r\n\r\ntypedef struct {\r\n  int1664m_T re;\r\n  int1664m_T im;\r\n} cint1664m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[52];\r\n} uint1664m_T;\r\n\r\ntypedef struct {\r\n  uint1664m_T re;\r\n  uint1664m_T im;\r\n} cuint1664m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[53];\r\n} int1696m_T;\r\n\r\ntypedef struct {\r\n  int1696m_T re;\r\n  int1696m_T im;\r\n} cint1696m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[53];\r\n} uint1696m_T;\r\n\r\ntypedef struct {\r\n  uint1696m_T re;\r\n  uint1696m_T im;\r\n} cuint1696m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[54];\r\n} int1728m_T;\r\n\r\ntypedef struct {\r\n  int1728m_T re;\r\n  int1728m_T im;\r\n} cint1728m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[54];\r\n} uint1728m_T;\r\n\r\ntypedef struct {\r\n  uint1728m_T re;\r\n  uint1728m_T im;\r\n} cuint1728m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[55];\r\n} int1760m_T;\r\n\r\ntypedef struct {\r\n  int1760m_T re;\r\n  int1760m_T im;\r\n} cint1760m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[55];\r\n} uint1760m_T;\r\n\r\ntypedef struct {\r\n  uint1760m_T re;\r\n  uint1760m_T im;\r\n} cuint1760m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[56];\r\n} int1792m_T;\r\n\r\ntypedef struct {\r\n  int1792m_T re;\r\n  int1792m_T im;\r\n} cint1792m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[56];\r\n} uint1792m_T;\r\n\r\ntypedef struct {\r\n  uint1792m_T re;\r\n  uint1792m_T im;\r\n} cuint1792m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[57];\r\n} int1824m_T;\r\n\r\ntypedef struct {\r\n  int1824m_T re;\r\n  int1824m_T im;\r\n} cint1824m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[57];\r\n} uint1824m_T;\r\n\r\ntypedef struct {\r\n  uint1824m_T re;\r\n  uint1824m_T im;\r\n} cuint1824m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[58];\r\n} int1856m_T;\r\n\r\ntypedef struct {\r\n  int1856m_T re;\r\n  int1856m_T im;\r\n} cint1856m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[58];\r\n} uint1856m_T;\r\n\r\ntypedef struct {\r\n  uint1856m_T re;\r\n  uint1856m_T im;\r\n} cuint1856m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[59];\r\n} int1888m_T;\r\n\r\ntypedef struct {\r\n  int1888m_T re;\r\n  int1888m_T im;\r\n} cint1888m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[59];\r\n} uint1888m_T;\r\n\r\ntypedef struct {\r\n  uint1888m_T re;\r\n  uint1888m_T im;\r\n} cuint1888m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[60];\r\n} int1920m_T;\r\n\r\ntypedef struct {\r\n  int1920m_T re;\r\n  int1920m_T im;\r\n} cint1920m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[60];\r\n} uint1920m_T;\r\n\r\ntypedef struct {\r\n  uint1920m_T re;\r\n  uint1920m_T im;\r\n} cuint1920m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[61];\r\n} int1952m_T;\r\n\r\ntypedef struct {\r\n  int1952m_T re;\r\n  int1952m_T im;\r\n} cint1952m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[61];\r\n} uint1952m_T;\r\n\r\ntypedef struct {\r\n  uint1952m_T re;\r\n  uint1952m_T im;\r\n} cuint1952m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[62];\r\n} int1984m_T;\r\n\r\ntypedef struct {\r\n  int1984m_T re;\r\n  int1984m_T im;\r\n} cint1984m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[62];\r\n} uint1984m_T;\r\n\r\ntypedef struct {\r\n  uint1984m_T re;\r\n  uint1984m_T im;\r\n} cuint1984m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[63];\r\n} int2016m_T;\r\n\r\ntypedef struct {\r\n  int2016m_T re;\r\n  int2016m_T im;\r\n} cint2016m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[63];\r\n} uint2016m_T;\r\n\r\ntypedef struct {\r\n  uint2016m_T re;\r\n  uint2016m_T im;\r\n} cuint2016m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[64];\r\n} int2048m_T;\r\n\r\ntypedef struct {\r\n  int2048m_T re;\r\n  int2048m_T im;\r\n} cint2048m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[64];\r\n} uint2048m_T;\r\n\r\ntypedef struct {\r\n  uint2048m_T re;\r\n  uint2048m_T im;\r\n} cuint2048m_T;\r\n\r\n#endif                                 /* MULTIWORD_TYPES_H */\r\n"},{"name":"rtwtypes.h","type":"header","group":"sharedutility","path":"C:\\Users\\m\\Desktop\\TestSimulinkCoder\\slprj\\grt\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * rtwtypes.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"rtwdemo_secondOrderSystem\".\r\n *\r\n * Model version              : 5.1\r\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\r\n * C source code generated on : Thu Aug  4 23:39:13 2022\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n#include \"tmwtypes.h\"\r\n#ifndef POINTER_T\r\n#define POINTER_T\r\n\r\ntypedef void * pointer_T;\r\n\r\n#endif\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n#endif                                 /* RTWTYPES_H */\r\n"},{"name":"ext_mode_types.h","type":"header","group":"interface","path":"C:\\Users\\m\\Desktop\\TestSimulinkCoder\\rtwdemo_secondOrderSystem_grt_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * ext_mode_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"rtwdemo_secondOrderSystem\".\r\n *\r\n * Model version              : 5.4\r\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\r\n * C source code generated on : Fri Aug  5 15:49:16 2022\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef EXT_MODE_TYPES_H\r\n#define EXT_MODE_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\n/** External Mode Event ID */\r\ntypedef uint16_T extmodeEventId_T;\r\n\r\n/** External Mode real time, measured using the target's clock */\r\ntypedef uint32_T extmodeRealTime_T;\r\n\r\n/** External Mode simulation time */\r\ntypedef time_T extmodeSimulationTime_T;\r\n\r\n/** External Mode double data type */\r\ntypedef real_T extmodeDouble_T;\r\n\r\n/** External Mode classic trigger signal */\r\ntypedef real_T extmodeClassicTriggerSignal_T;\r\n\r\n/** Run the simulation forever (infinite simulation end time) */\r\n#define EXTMODE_SIMULATION_RUN_FOREVER ((extmodeSimulationTime_T) -1)\r\n\r\n/** External Mode Base rate event id */\r\n#define EXTMODE_BASE_RATE_EVENT_ID     1\r\n\r\n/** External Mode Max Event Id */\r\n#define EXTMODE_MAX_EVENT_ID           0xFF\r\n#endif                                 /* EXT_MODE_TYPES_H */\r\n\r\n/* [EOF] ext_mode_types.h */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"C:\\Users\\m\\Desktop\\TestSimulinkCoder\\rtwdemo_secondOrderSystem_grt_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n *  rtmodel.h:\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"rtwdemo_secondOrderSystem\".\r\n *\r\n * Model version              : 5.4\r\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\r\n * C source code generated on : Fri Aug  5 15:49:16 2022\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtmodel_h_\r\n#define RTW_HEADER_rtmodel_h_\r\n#include \"rtwdemo_secondOrderSystem.h\"\r\n#define GRTINTERFACE                   0\r\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\r\n"},{"name":"rtiostream_tcpip.c","type":"source","group":"legacy","path":"E:\\Matlab\\toolbox\\coder\\rtiostream\\src\\rtiostreamtcpip","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2020 The MathWorks, Inc.\n *\n * File: rtiostream_tcpip.c     \n *\n * Abstract: This source file implements both client-side and server-side TCP/IP\n *  and UDP/IP communication. Typically, this driver is used to support host-target\n *  communication where the client-side device driver runs on the host and the\n *  server-side driver runs on the target. For this implementation, both\n *  client-side and server-side driver code has been combined into a single\n *  file.\n *\n *  If you are using this code as a starting point to implement a TCP/IP or \n *  UDP/IP driver for a custom target it is only necessary to include code \n *  for the server side of the connection.\n */\n\n#ifndef _WIN32\n/* Required BSD Unix extensions are not available by default on certain Unix\n * distributions */\n#define _DEFAULT_SOURCE     /* _DEFAULT_SOURCE must be defined to avoid\n                               _BSD_SOURCE deprecation warning\n                               for glibc >= 2.20 */\n#define _BSD_SOURCE         /* Required to support glibc <= 2.19 */\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <limits.h>\n#include \"rtiostream.h\"\n#include \"tmwtypes.h\"\n\n#ifdef _WIN32\n  /* WINDOWS */\n\n#if defined(_MSC_VER)\n /* temporarily disable warning triggered\n  * by windows.h */\n #pragma warning(push)\n #pragma warning(disable: 4255)\n#endif\n\n#include <windows.h>\n\n#if defined(_MSC_VER)\n /* restore warning */\n #pragma warning(pop)\n#endif\n\n# ifdef __LCC__\n# ifndef __LCC64__\n#   include <winsock2.h>\n# endif\n#   include <errno.h>\n# endif\n\n#define RTIOSTREAM_ECONNRESET WSAECONNRESET\n\n#elif defined(VXWORKS)\n /*VxWorks headers*/\n# include <selectLib.h>\n# include <sockLib.h>\n# include <inetLib.h>\n# include <ioLib.h>\n# include <taskLib.h>\n# include <netinet/tcp.h> \n\n#define RTIOSTREAM_ECONNRESET ECONNRESET\n\n#else\n  /* UNIX */\n# include <signal.h>\n# include <sys/time.h>      /* Linux */\n# include <sys/types.h>     /* Linux */\n# include <sys/socket.h>\n# include <sys/poll.h>\n# include <netinet/in.h>    /* Linux */\n# include <netinet/tcp.h>   /* Linux */\n# include <arpa/inet.h>     /* Linux */\n# include <netdb.h>\n# include <errno.h>\n# include <fcntl.h>  \n# include <unistd.h>\n\n#define RTIOSTREAM_ECONNRESET ECONNRESET\n#endif\n\n#if defined(_WIN32) || defined(VXWORKS)\n#define USE_SELECT  \n#endif\n\n#ifdef USE_MEXPRINTF\n#include \"mex.h\"\n#define printf mexPrintf\n#define SERVER_PORT_PRINTF(FORMAT, ARG1) mexPrintf(FORMAT, ARG1)\n#else\n/* If stdout is redirected to file, it is essential that the port number is \n * available immediately in the output file. With LCC, printf does not flush \n * correctly to the redirected output file - use fprintf & fflush instead. */\n#define SERVER_PORT_PRINTF(FORMAT, ARG1) fprintf(stdout, FORMAT, ARG1); \\\n                                         fflush(stdout)\n#endif\n\n/***************** DEFINES ****************************************************/                                         \n#define HOSTNAME_MAXLEN (64U)\n\n#define SERVER_PORT_NUM  (17725U)   /* sqrt(pi)*10000 */\n\n/* \n * EXT_BLOCKING  \n *\n * Depending on the implementation of the main program (e.g., grt_main.c,\n * rt_main.c), the EXT_BLOCKING flag must be set to either 0 or 1.\n *\n * rt_main.c (tornado/vxworks): rt_main.c is a real-time, multi-tasking target.\n * The upload and packet servers are called via background (low priority) tasks.\n * In this case, it is o.k. for the transport function to block as the blocked\n * tasks will simply be pre-empted in order to enable the model to run.  It is\n * desirable to block instead of to poll to free up the cpu for any other\n * potential work. \n */\n#ifdef VXWORKS\n# define EXT_BLOCKING (1)  \n#else\n# define EXT_BLOCKING (0)  \n#endif\n\n/* timeout of 0 means to return immediately */\n#define BLOCKING_RECV_TIMEOUT_NOWAIT (0)\n/* timeout of -1 means to wait indefinitely */\n#define BLOCKING_RECV_TIMEOUT_NEVER (-1)\n/* rogue value for blocking receive timeout */\n#define DEFAULT_BLOCKING_RECV_TIMEOUT (-2)\n/* timeout of -3 means to wait for 10 ms to avoid high CPU load */\n#define BLOCKING_RECV_TIMEOUT_10MS (-3)\n/* wake up from blocking every second */\n#define DEFAULT_BLOCKING_RECV_TIMEOUT_SECS_CLIENT (1) \n/* only wake up from blocking when data arrives */\n#define DEFAULT_BLOCKING_RECV_TIMEOUT_SECS_SERVER (BLOCKING_RECV_TIMEOUT_NEVER)\n/* server wait time for client to close its socket */\n#define BLOCKING_RECV_TIMEOUT_SOCK_SHUTDOWN (60)\n\n/* define a set of verbosity levels:\n *\n * 0: no verbose output\n * 1: verbose output with data\n * 2: extra verbose output including when data size is zero*/\ntypedef enum {VERBOSITY_LEVEL_0=0, VERBOSITY_LEVEL_1, VERBOSITY_LEVEL_2} VerbosityLevel;\n/* default verbosity value */\n#define DEFAULT_VERBOSITY VERBOSITY_LEVEL_0\n\n/* default protocol value */\n#define DEFAULT_PROTOCOL TCP_PROTOCOL\n/* allowed -protocol strings */\n#define TCP_PROTOCOL_STRING \"TCP\"\n#define UDP_PROTOCOL_STRING \"UDP\"\n#define UDP_PACKET_LOSS_DETECTON_PROTOCOL_STRING \"UDP_PACKET_LOSS_DETECTION\"\n\n/* default UDP max packet size \n *\n * The maximum size of UDP packets that are transmitted / received must be\n * consistent on the host and target otherwise receive errors will occur at \n * the side with the smaller buffer size specified.\n *\n * Use the \"-maxudppacketsize SIZE\" argument to specify a different packet size.\n * This option is particularly useful when using a custom server implementation\n * that uses a different max packet size to the default. \n *\n * The maximum UDP payload is 65507 bytes, which can be achieved for localhost\n * based communications on Linux and Windows, but Mac has a lower size of\n * 9216.\n */\n#define UDP_MAX_PACKET_SIZE 9216\n#define DEFAULT_MAX_UDP_PACKET_SIZE UDP_MAX_PACKET_SIZE\n/* increase the UDP socket receive size to decrease the \n * possibility of buffer overflow */\n#define DEFAULT_UDP_SOCKET_RECEIVE_SIZE_REQUEST (512 * 1024) \n#define DEFAULT_UDP_SOCKET_SEND_SIZE_REQUEST (512 * 1024) \n\n#define DEFAULT_IS_USING_SEQ_NUM 1\n\n#ifdef WIN32\n  /* WINDOWS */\n# define close closesocket\n# define SOCK_ERR SOCKET_ERROR\n#else\n  /* UNIX, VXWORKS */\n# define INVALID_SOCKET (-1)\n# define SOCK_ERR (-1)\n\n  typedef int SOCKET;\n#endif\n\n/*\n * send prototype differs on different platforms. The following typedefs\n * suppress compiler warnings.\n */\n#if defined(WIN32)\ntypedef const char * send_buffer_t;\n#elif defined(VXWORKS)\ntypedef char * send_buffer_t;\n#else\ntypedef const void * send_buffer_t;\n#endif\n\n/* MIN utility */\n#ifndef MIN\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#endif\n\n/***************** TYPEDEFS **************************************************/\n\n#if (defined(_WIN32)) || (defined(VXWORKS))\n   /* socklen_t may not be available */\n   typedef int rtiostream_socklen_t;\n#else\n   typedef socklen_t rtiostream_socklen_t;\n#endif\n\n/* Server specific data structure */\ntypedef struct ServerData_tag {\n    int       port;           /* port number associated with the server socket */\n    SOCKET    listenSock;     /* listening socket to accept incoming connections */\n    char      *serverInfoFile; /* the filename that is used to write the server \n                                 port number when dynamic port allocation is used */                      \n} ServerData;\n\n/* UDP send / receive buffer data structure */\ntypedef struct UDPPacketBuffer_tag {\n    char * buffer; /* pointer to the buffer */\n    char * dataPtr; /* pointer to the current position in the buffer */\n    int dataAvail; /* amount of data in the buffer */\n} UDPPacketBuffer;\n\n/* Type for the optional UDP sequence number */\ntypedef uint32_T udpSeqNum_T;\n/* byte size of the UDP sequence number */\n#define UDP_SEQ_NUM_SIZE ((int) sizeof(udpSeqNum_T))\n\n/* UDP specific data structure */\ntypedef struct UDPData_tag {\n   int isUsingSeqNum; /* is this connection using sequence numbers */\n   int maxPacketSize; /* max packet size (buffer size) */\n   UDPPacketBuffer * recvBuffer; /* buffer for an incoming datagram */\n   UDPPacketBuffer * sendBuffer; /* buffer for an outgoing datagram */\n   udpSeqNum_T sendSeqNum; /* sequence number to add to outgoing datagrams */\n   udpSeqNum_T expectedRecvSeqNum; /* expected sequence number in incoming \n                                   datagrams */\n   int resetExpectedRecvSeqNum; /* flags whether to reset expectedRecvSeqNum\n                                   to the sequence number of the next incoming\n                                   datagram */\n} UDPData;\n\n/* enum of supported communications protocols */\ntypedef enum {TCP_PROTOCOL, UDP_PROTOCOL} CommsProtocol;\n\n/* Data encapsulating a single client / server connection  */\ntypedef struct ConnectionData_tag {\n   int isInUse; /* is this ConnectionData instance currently in use? */\n   int isServer; /* is this ConnectionData instance a Server (or client)? */\n   int blockingRecvTimeout; /*    Timeout value in seconds. rtIOStreamRecv \n                                  blocks until at least some of the requested \n                                  data is available or the timeout expires.   \n                                  If a timeout occurs the receiveSize will be 0. \n\n                                  A value of BLOCKING_RECV_TIMEOUT_NOWAIT (0)\n                                  means to block for 0 seconds (polling mode). \n                                  rtIOStreamRecv processes \n                                  any pending data or, if no data is available, \n                                  returns immediately with a receiveSize of 0.\n\n                                  A value of BLOCKING_RECV_TIMEOUT_NEVER (-1)\n                                  means to block indefinitely (full blocking \n                                  mode). rtIOStreamRecv blocks\n                                  until at least some of the requested data is \n                                  available.   receiveSize should always be \n                                  greater than 0. \n\n                                  A value of BLOCKING_RECV_TIMEOUT_10MS (-3)\n                                  means to block for up to 10 ms to avoid high CPU \n                                  load.\n                             */\n   VerbosityLevel verbosity; /* enum indicating the level of verbosity to be displayed on the output */\n   CommsProtocol protocol; /* TCP or UDP protocol */\n   SOCKET sock; /* socket to send/receive packets */\n   ServerData * serverData; /* Server specific data - NULL for clients */\n   UDPData * udpData; /* UDP specific data - NULL for TCP */\n   int udpSendBufSize;\n   int udpRecvBufSize;\n} ConnectionData;\n\n/**************** LOCAL DATA *************************************************/\n\n/* All local data resides in the per client / \n * server instance ConnectionData structures to make sure each connection is\n * completely independent.\n *\n * Each ConnectionData does not use much memory; any optionally required \n * send / recv buffers are dynamically allocated and freed when the ConnectionData \n * actually becomes in use.\n *\n * The static array will be deallocated when the shared library is unloaded. \n *\n * Using an array rather than a linked list allows us to have fast direct lookup\n * of ConnectionData from connectionID during calls to rtIOStreamSend/Recv */\n#define MAX_NUM_CONNECTIONS (50)\nstatic ConnectionData connectionDataArray[MAX_NUM_CONNECTIONS];\n\n/************** LOCAL FUNCTION PROTOTYPES ************************************/\n\nstatic int initConnectionData(int connectionID, \n                          int isServer, \n                          CommsProtocol protocol, \n                          SOCKET sock, \n                          int blockingRecvTimeout,\n                          int maxPacketSize, \n                          int serverPort, \n                          char * serverInfoFile, \n                          VerbosityLevel verbosity, \n                          int isUsingSeqNum,\n                          int udpSendBufSize,\n                          int udpRecvBufSize); \n\nstatic int getConnectionID(void);\n\nstatic ConnectionData * getConnectionData(int connectionID);\n\nstatic void freeConnectionData(ConnectionData * connection);\n\nstatic UDPPacketBuffer * createUDPPacketBuffer(int maxPacketSize);\n\nstatic void freeUDPPacketBuffer(UDPPacketBuffer ** udpPacketBuffer);\n\nstatic void resetUDPPacketBuffer(UDPPacketBuffer * udpPacketBuffer);\n\nstatic int processUDPRecvSeqNum(ConnectionData * connection);\n\nstatic int initialUDPServerRecvfrom(ConnectionData * connection,\n                                    struct sockaddr * clientSA,\n                                    rtiostream_socklen_t * clientSALen);\n\nstatic int waitForClientClose(ConnectionData * connection);\n\nstatic int socketDataSet(\n    ConnectionData * connection, \n    const void *src,\n    const size_t size,\n    size_t *sizeSent);\n\nstatic int socketDataGet(\n    ConnectionData * connection, \n    char          *dst,\n    const size_t   size,\n    size_t        *sizeRecvd);\n\nstatic int socketDataPending(\n    const SOCKET sock,\n    ConnectionData * connection,\n    int    *outPending,\n    int timeoutSecs);\n\nstatic int serverStreamRecv( \n    ConnectionData * connection, \n    void * dst,\n    size_t size,\n    size_t * sizeRecvd);\n\nstatic SOCKET serverOpenSocket(int port, char * serverInfoFile, CommsProtocol protocol,int udpSendBufSize, int udpRecvBufSize);\n\n#if (!defined(VXWORKS))\nstatic SOCKET clientOpenSocket(char * hostName, unsigned int portNum, CommsProtocol protocol, int udpSendBufSize, int udpRecvBufSize);\n#endif\n\nstatic void serverAcceptSocket(ConnectionData * connection);\n\nstatic int processArgs(\n    const int          argc,\n    void            *  argv[],\n    char           **  hostName, \n    unsigned int    *  portNum,\n    unsigned int    *  isClient,\n    int             *  isBlocking,\n    int             *  recvTimeout, \n    char           **  serverInfoFile, \n    CommsProtocol   * protocol, \n    int             * maxPacketSize,\n    VerbosityLevel  * verbosity, \n    int             * isUsingSeqNum,\n    int             * udpSendBufSize,\n    int             * udpRecvBufSize);\n\n#if (!defined(VXWORKS))\nstatic unsigned long nameLookup(char * hostName);\n#endif\n\n/*************** LOCAL FUNCTIONS **********************************************/\n\n/* Function: initConnectionData =================================================\n * Abstract:\n *  Initializes a client / server ConnectionData for the specified protocol.\n *\n *  A return value of RTIOSTREAM_ERROR indicates an error.\n */\nstatic int initConnectionData(int connectionID, \n                          int isServer, \n                          CommsProtocol protocol, \n                          SOCKET sock, \n                          int blockingRecvTimeout,\n                          int maxPacketSize, \n                          int serverPort, \n                          char * serverInfoFile, \n                          VerbosityLevel verbosity, \n                          int isUsingSeqNum,\n                          int udpSendBufSize,\n                          int udpRecvBufSize) {\n   int retVal = RTIOSTREAM_NO_ERROR;\n   ConnectionData * connection = &connectionDataArray[connectionID];\n  \n   /* initialize the new ConnectionData */\n   connection->isInUse = 1;\n   connection->isServer = isServer;\n   connection->blockingRecvTimeout = blockingRecvTimeout;\n   connection->protocol = protocol;\n   connection->verbosity = verbosity;\n   connection->udpSendBufSize = udpSendBufSize;\n   connection->udpRecvBufSize = udpRecvBufSize;\n   /* initialize to NULL early so that calls to \n    * freeConnectionData on error will succeed */\n   connection->udpData = NULL;\n   connection->serverData = NULL;\n\n   if (connection->protocol == UDP_PROTOCOL) {      \n      /* initialize the UDP data */\n      connection->udpData = (UDPData *) malloc(sizeof(UDPData));\n      if (connection->udpData == NULL) {\n         printf(\"initConnectionData:UDPData malloc failed.\\n\");\n         freeConnectionData(connection);\n         retVal = RTIOSTREAM_ERROR;\n         return retVal; \n      }\n      /* initialize to NULL */\n      connection->udpData->recvBuffer = NULL;\n      connection->udpData->sendBuffer = NULL;\n      connection->udpData->isUsingSeqNum = isUsingSeqNum;\n      connection->udpData->maxPacketSize = maxPacketSize;\n      /* send sequence numbers always start from 0 */\n      connection->udpData->sendSeqNum = 0;\n      /* initially, seed the expectedRecvSeqNum from the first \n       * received packet */\n      connection->udpData->resetExpectedRecvSeqNum = 1;      \n      connection->udpData->recvBuffer = createUDPPacketBuffer(maxPacketSize);\n      if (connection->udpData->recvBuffer == NULL) {\n         printf(\"initConnectionData:createUDPPacketBuffer failed.\\n\");\n         freeConnectionData(connection);\n         retVal = RTIOSTREAM_ERROR;\n         return retVal; \n      }\n      if (maxPacketSize > UDP_MAX_PACKET_SIZE) {\n         /* packet size cannot exceed the maximum \n          * UDP packet size */\n         printf(\"initConnectionData: udpmaxpacketsize must be less than %d\\n\", UDP_MAX_PACKET_SIZE);\n         freeConnectionData(connection);\n         retVal = RTIOSTREAM_ERROR;\n         return retVal; \n      }\n      if (connection->udpData->isUsingSeqNum) {\n         /* packet size must be larger than the size\n          * of the sequence number */\n         if (maxPacketSize <= UDP_SEQ_NUM_SIZE) {\n            printf(\"initConnectionData: udpmaxpacketsize must be larger than %d\\n\", UDP_SEQ_NUM_SIZE);\n            freeConnectionData(connection);\n            retVal = RTIOSTREAM_ERROR;\n            return retVal; \n         }\n         /* send buffer will be required in order to add the sequence\n          * number to the outgoing data */\n         connection->udpData->sendBuffer = createUDPPacketBuffer(maxPacketSize);\n         if (connection->udpData->sendBuffer == NULL) {\n            printf(\"initConnectionData:createUDPPacketBuffer failed.\\n\");\n            freeConnectionData(connection);\n            retVal = RTIOSTREAM_ERROR;\n            return retVal; \n         }\n      }\n   }\n\n   if (isServer) {\n      /* initialize server data */\n      connection->serverData = (ServerData *) malloc(sizeof(ServerData));\n      if (connection->serverData == NULL) {\n         printf(\"initConnectionData:ServerData malloc failed.\\n\");\n         freeConnectionData(connection);\n         retVal = RTIOSTREAM_ERROR;\n         return retVal; \n      }\n      connection->serverData->port = serverPort;\n      connection->serverData->serverInfoFile = serverInfoFile;\n      /* provided sock is the listening sock */\n      connection->serverData->listenSock = sock;\n      /* later call to serverAcceptSocket will set sock */ \n      connection->sock = INVALID_SOCKET;\n   }\n   else {\n      /* store the provided socket */\n      connection->sock = sock;\n   }\n\n   if (verbosity) {\n      if (connection->protocol == TCP_PROTOCOL) {\n         printf(\"Connection id %d, protocol: TCP/IP\\n\", connectionID);\n      }\n      else if (connection->protocol == UDP_PROTOCOL) {\n         printf(\"Connection id %d, protocol: UDP/IP\\n\", connectionID);\n         printf(\"Connection id %d, maxPacketSize: %d\\n\", connectionID, \n                                                         connection->udpData->maxPacketSize);\n         printf(\"Connection id %d, isUsingSeqNum: %d\\n\", connectionID, \n                                                         connection->udpData->isUsingSeqNum);\n      }\n      else {\n         printf(\"initConnectionData:invalid protocol.\\n\");\n         freeConnectionData(connection);\n         retVal = RTIOSTREAM_ERROR;\n         return retVal; \n      }\n      {\n         /* display the size of the socket receive buffer */\n         rtiostream_socklen_t optionLen = sizeof(int);\n         int optionValue;\n         getsockopt(sock, SOL_SOCKET, SO_SNDBUF, (char *) &optionValue, &optionLen);\n         printf(\"Connection id %d, udpSendBufSize: %d\\n\", connectionID, optionValue);\n         getsockopt(sock, SOL_SOCKET, SO_RCVBUF, (char *) &optionValue, &optionLen);\n         printf(\"Connection id %d, udpRecvBufSize: %d\\n\", connectionID, optionValue);\n      }\n      printf(\"Connection id %d, blockingRecvTimeout: %d\\n\", connectionID, \n                                                            connection->blockingRecvTimeout);\n      if ((connection->isServer) && (connection->serverData != NULL)) {\n         printf(\"Connection id %d, type: server\\n\", connectionID);       \n         if (connection->serverData->serverInfoFile != NULL) {\n            printf(\"Connection id %d, server info file: %s\\n\", connectionID, \n                                                               connection->serverData->serverInfoFile);\n         }\n      }\n      else {\n         printf(\"Connection id %d, type: client\\n\", connectionID);\n      }\n      printf(\"Connection id %d, socket id %d\\n\", connectionID, (int) sock);\n      /* relevant to both clients and servers */\n      printf(\"Connection id %d, server port: %d\\n\", connectionID, serverPort);\n   }\n   return retVal;\n}\n\n/* Function: getConnectionData =================================================\n * Abstract:\n *  Retrieves a ConnectionData instance given its connectionID \n *  (as returned by initConnectionData) \n *\n * NOTE: An invalid connectionID will lead to a NULL pointer being returned \n */\nstatic ConnectionData * getConnectionData(int connectionID) {\n   /* return NULL for invalid or uninitialized connectionIDs */\n   ConnectionData * connection = NULL;\n   if ((connectionID >= 0) && (connectionID < MAX_NUM_CONNECTIONS)) {\n      if (connectionDataArray[connectionID].isInUse) {\n         connection = &connectionDataArray[connectionID];\n      }\n   }\n   return connection;\n}\n\n/* Function: getConnectionID =================================================\n * Abstract:\n *  Returns a connectionID corresponding to a ConnectionData that is not \n *  already in use.\n *\n *  Returns RTIOSTREAM_ERROR if all available ConnectionData instances are \n *  already in use.\n */\nstatic int getConnectionID(void) {\n   int connectionID;\n   int foundUnusedConnectionData = 0;\n   /* linear search for an unused ConnectionData */\n   for (connectionID = 0; connectionID < MAX_NUM_CONNECTIONS; connectionID++) {      \n      if (!connectionDataArray[connectionID].isInUse) {\n         foundUnusedConnectionData = 1;\n         break;\n      }\n   }\n   if (!foundUnusedConnectionData) {\n      /* all ConnectionData's are in use */\n      printf(\"getConnectionID: All %d available connections are in use.\\n\", MAX_NUM_CONNECTIONS);\n      connectionID = RTIOSTREAM_ERROR;\n   }\n   return connectionID;\n}\n\n/* Function: freeConnectionData =================================================\n * Abstract:\n *  Frees memory associated with the ConnectionData referenced by connectionID.\n *  Marks the ConnectionData instance as no longer in use.\n */\nstatic void freeConnectionData(ConnectionData * connection) {\n   /* mark the ConnectionData as not in use */\n   connection->isInUse = 0;\n   /* free dynamic memory */\n   if (connection->protocol == UDP_PROTOCOL) {\n      freeUDPPacketBuffer(&connection->udpData->recvBuffer);\n      /* freeConnectionData is called if connection->udpData did not allocate */\n      if (connection->udpData != NULL) {\n        if (connection->udpData->isUsingSeqNum) {\n            freeUDPPacketBuffer(&connection->udpData->sendBuffer);\n        }\n      }\n      free(connection->udpData);\n      connection->udpData = NULL;\n   }\n   if (connection->isServer) {\n      free(connection->serverData);\n      connection->serverData = NULL;\n   }\n}\n\n/* Function: createUDPPacketBuffer =================================================\n * Abstract:\n *  Allocates storage for and initializes a UDPPacketBuffer\n */\nstatic UDPPacketBuffer * createUDPPacketBuffer(int maxPacketSize) {\n   /* initialize the UDP packet buffer */\n   UDPPacketBuffer * udpPacketBuffer = (UDPPacketBuffer *) malloc(sizeof(UDPPacketBuffer));      \n   if (udpPacketBuffer == NULL) {\n      printf(\"createUDPPacketBuffer:UDPPacketBuffer malloc failed.\\n\");\n      return udpPacketBuffer; \n   }\n   /* allocate the buffer */\n   udpPacketBuffer->buffer = (char *) calloc((size_t)maxPacketSize, sizeof(char));\n   if (udpPacketBuffer->buffer == NULL) {\n      printf(\"createUDPPacketBuffer:UDPPacketBuffer buffer malloc failed.\\n\");\n      /* free everything we allocated */\n      free(udpPacketBuffer);\n      udpPacketBuffer = NULL;\n      return udpPacketBuffer; \n   }\n   resetUDPPacketBuffer(udpPacketBuffer);\n   return udpPacketBuffer;\n}\n\n/* Function: freeUDPPacketBuffer =================================================\n * Abstract:\n *  Frees memory associated with the referenced UDPPacketBuffer \n */\nstatic void freeUDPPacketBuffer(UDPPacketBuffer ** udpPacketBuffer) {\n   if (*udpPacketBuffer != NULL) {\n      /* free the buffer */\n      free((*udpPacketBuffer)->buffer);\n      (*udpPacketBuffer)->buffer = NULL;\n      /* free the container */\n      free(*udpPacketBuffer);\n      *udpPacketBuffer = NULL;\n   }\n}\n\n/* Function: resetUDPPacketBuffer =================================================\n * Abstract:\n *  Resets the referenced UDP Packet Buffer so that it is ready to receive fresh data\n */\nstatic void resetUDPPacketBuffer(UDPPacketBuffer * udpPacketBuffer) {\n   udpPacketBuffer->dataPtr = udpPacketBuffer->buffer;\n   udpPacketBuffer->dataAvail = 0;\n}\n\n/* Function: socketDataPending =================================================\n * Abstract:\n *  Returns true, via the 'pending' arg, if data is pending on the comm line.\n *  Returns false otherwise.\n *\n *  RTIOSTREAM_NO_ERROR is returned on success, RTIOSTREAM_ERROR on failure.\n */\nstatic int socketDataPending(\n    const SOCKET sock,\n    ConnectionData * connection,\n    int    *outPending, \n    int timeoutSecs)\n{\n    int retVal = RTIOSTREAM_NO_ERROR;\n    int pending = SOCK_ERR; /* assume failure until success */\n    \n    #ifdef USE_SELECT\n    /* Variables used with select() on Win32 & VXWorks */\n    struct timeval  tval;\n    struct timeval * tvalPtr;\n    fd_set          ReadFds;\n    #else\n    /* Variables used with poll() on Linux */\n    struct pollfd PollReadFd[1];\n    int tvalPoll;\n    int pollAttempt = 0;\n    #define MAX_POLL_RETRIES 5\n    #endif\n    \n    \n    if (connection->protocol == UDP_PROTOCOL) {\n       /* first check the UDP buffer */\n       UDPPacketBuffer * udpPacketBuffer = connection->udpData->recvBuffer;\n       if (udpPacketBuffer->dataAvail) {\n          *outPending = 1;\n          return retVal;\n       }\n    }\n\n    #ifdef USE_SELECT          /* Beginning of block for using select */\n    FD_ZERO(&ReadFds);\n    \n    #if defined(_WIN32) && defined(_MSC_VER)\n      /*temporarily disable warning C4127 caused by using FD_SET*/\n      #pragma warning(push)\n      #pragma warning(disable: 4127)\n    #endif\n\n    /* Using fd_set structure ReadFds on Win32/VXWorks */\n    FD_SET(sock, &ReadFds);\n    \n    #if defined(_WIN32) && defined(_MSC_VER)\n      /*enable the warning C4127*/\n      #pragma warning(pop)\n    #endif\n\n    /* Select() uses a timeval structure for specifying timeout */\n    switch (timeoutSecs) {\n       case BLOCKING_RECV_TIMEOUT_NEVER:\n          /* specify null pointer for blocking */\n          tvalPtr = NULL;\n          break;\n       case BLOCKING_RECV_TIMEOUT_10MS:\n          /* set up the 10ms time-val */\n          tval.tv_sec  = 0;\n          tval.tv_usec = 10000;\n          tvalPtr = &tval;\n          break;\n       default:\n          /* set up the time-val */\n          tval.tv_sec  = timeoutSecs;\n          tval.tv_usec = 0;\n          tvalPtr = &tval;\n          break;\n    }\n    #else                       /* Else block for using select */\n    /* Poll() uses an int specifying timeout in milliseconds */\n    switch (timeoutSecs) {\n       case BLOCKING_RECV_TIMEOUT_NEVER:\n          /* specify negative value for blocking */\n          tvalPoll = -1;\n          break;\n       case BLOCKING_RECV_TIMEOUT_10MS:\n          /* set up the 10ms time-val */\n          tvalPoll = 10;\n          break;\n       default:\n          /* set up the time-val */\n          tvalPoll = timeoutSecs*1000;\n          break;\n    }\n    #endif                      /* End of block for using select */\n\n    \n    #ifdef USE_SELECT\n    /* Use select() on Win32 and VxWorks */\n    /*\n     * Casting the first arg to int removes warnings on windows 64-bit\n     * platform.  It is safe to cast a SOCKET to an int here because on\n     * Linux SOCKET is typedef'd to int and on windows the first argument\n     * to select is ignored (so it doesn't matter what the value is).\n     */\n    pending = select((int)(sock + 1), &ReadFds, NULL, NULL, tvalPtr);\n    #else\n    /* Use poll() on Linux and Mac to avoid issues with sockets >= FD_SETSIZE */\n    PollReadFd[0].fd = sock;\n    PollReadFd[0].events = POLLIN;\n    \n    /* Timer interrupts may cause poll to fail with error EINTR.\n     * In these cases we should retry MAX_POLL_RETRIES times before\n     * concluding an error.\n     */\n    do {\n        pending = poll( PollReadFd, 1, tvalPoll);\n        pollAttempt++;\n    } while (pending == SOCK_ERR && errno == EINTR && pollAttempt < MAX_POLL_RETRIES);\n    #endif\n\n    #ifdef USE_SELECT\n    if (pending == SOCK_ERR) \n    #else\n    /* On Linux an extra check of POLLERR flag is needed to detect and report\n       an error if the other end suddenly crashes. The same flag doesn't seem to be\n       activated on Mac */\n    if ((pending == SOCK_ERR) || \n        (PollReadFd[0].revents & POLLERR))\n    #endif\n    {\n        retVal = RTIOSTREAM_ERROR;\n    }\n\n    *outPending = (pending==1) && (retVal == RTIOSTREAM_NO_ERROR);\n    return(retVal);    \n\n} /* end socketDataPending */ \n\n/* Function: initialUDPServerRecvfrom =====================================================\n * Abstract:\n *  Reads data from the client via \"recvfrom\" into the UDP packet buffer.\n *  The client sockaddr is returned via clientSA and clientSALen.\n *\n *  RTIOSTREAM_NO_ERROR is returned on success, RTIOSTREAM_ERROR is returned on\n *  failure.\n */\nstatic int initialUDPServerRecvfrom(ConnectionData * connection,\n                                    struct sockaddr * clientSA,\n                                    rtiostream_socklen_t * clientSALen) {\n   int nRead;\n   int retVal;\n   UDPPacketBuffer * udpPacketBuffer = connection->udpData->recvBuffer;\n   /* reset */ \n   resetUDPPacketBuffer(udpPacketBuffer);\n   /* initialize ahead of call to recvfrom */\n   *clientSALen = sizeof(*clientSA);\n   /* read into UDP buffer from the listenSock\n    * and get sockaddr of the client */\n   nRead = recvfrom(connection->serverData->listenSock, \n         udpPacketBuffer->dataPtr, \n                    (size_t)connection->udpData->maxPacketSize, \n         0U, \n         clientSA, \n         clientSALen);\n\n   if (nRead == SOCK_ERR) {\n      retVal = RTIOSTREAM_ERROR;\n   } else {\n      /* set dataAvail */\n      udpPacketBuffer->dataAvail = nRead;\n      /* handle optional sequence number */\n      retVal = processUDPRecvSeqNum(connection);\n   }\n   return retVal;\n}\n\n/* Function: processUDPRecvSeqNum =====================================================\n * Abstract:\n *  Processes sequence numbers in received UDP datagrams.\n *\n *  RTIOSTREAM_NO_ERROR is returned on success, RTIOSTREAM_ERROR is returned on\n *  failure.\n */\nstatic int processUDPRecvSeqNum(ConnectionData * connection) {\n   int retVal = RTIOSTREAM_NO_ERROR;\n   if (connection->udpData->isUsingSeqNum) {\n      UDPPacketBuffer * udpPacketBuffer = connection->udpData->recvBuffer;\n      /* process sequence number */\n      udpSeqNum_T recvSeqNum;\n      if (udpPacketBuffer->dataAvail < UDP_SEQ_NUM_SIZE) {\n         printf(\"No receive sequence number found.\\n\");\n         retVal = RTIOSTREAM_ERROR;\n         return retVal; \n      }\n      /* read sequence number from the buffer \n       *\n       * sequence number is always transmitted / received in \n       * host Endian */\n      memcpy(&recvSeqNum,\n            udpPacketBuffer->dataPtr,\n            UDP_SEQ_NUM_SIZE);\n      udpPacketBuffer->dataPtr += UDP_SEQ_NUM_SIZE;\n      udpPacketBuffer->dataAvail -= UDP_SEQ_NUM_SIZE;\n      if (connection->verbosity) {\n        printf(\"Received UDP packet with sequence number: %u\\n\", recvSeqNum);\n      }\n      if (connection->udpData->resetExpectedRecvSeqNum) {\n         /* reset the expected sequence number */\n         connection->udpData->expectedRecvSeqNum = recvSeqNum + 1;\n         connection->udpData->resetExpectedRecvSeqNum = 0;\n      }\n      else {\n         /* compare with expected receive seq num */\n         if (recvSeqNum != connection->udpData->expectedRecvSeqNum) {\n            printf(\"UDP packet sequence number mismatch. Expected #: %u, Actual #: %u\\n\", \n                  connection->udpData->expectedRecvSeqNum, recvSeqNum);\n            retVal = RTIOSTREAM_ERROR;\n         } \n         else {\n            /* increment expected receive seq num */\n            connection->udpData->expectedRecvSeqNum++;\n         }\n      }\n   }\n   return retVal;\n}\n\n/* Function: socketDataGet =====================================================\n * Abstract:\n *  Attempts to gets the specified number of bytes from the specified socket.\n *  The number of bytes read is returned via the 'sizeRecvd' parameter.\n *  RTIOSTREAM_NO_ERROR is returned on success, RTIOSTREAM_ERROR is returned on\n *  failure.\n *\n * NOTES:\n *  o it is not an error for 'sizeRecvd' to be returned as 0\n *  o this function blocks if no data is available\n */\nstatic int socketDataGet(ConnectionData * connection,\n    char          *dst,\n    const size_t   size,\n    size_t        *sizeRecvd)\n{\n    int nRead = 0;\n    int retVal = RTIOSTREAM_NO_ERROR; \n    /* Ensure size is not out of range for socket API recv function */\n    int sizeLim = (int) MIN(size, INT_MAX);\n\n    if (connection->protocol == TCP_PROTOCOL) {\n        nRead = recv(connection->sock, dst, (size_t)sizeLim, 0U);\n       if (nRead == SOCK_ERR) {\n          retVal = RTIOSTREAM_ERROR;\n       } else {\n          retVal = RTIOSTREAM_NO_ERROR;\n       }\n    }\n    else { \n       UDPPacketBuffer * udpPacketBuffer = connection->udpData->recvBuffer;\n       /* receive more data in to the buffer if required */\n       if (udpPacketBuffer->dataAvail == 0) {         \n          /* reset */ \n          resetUDPPacketBuffer(udpPacketBuffer);\n          /* read into buffer */\n          nRead = recv(connection->sock, \n                       udpPacketBuffer->dataPtr, \n                       (size_t)connection->udpData->maxPacketSize, \n                       0U);\n          \n          if (nRead == SOCK_ERR) {\n             retVal = RTIOSTREAM_ERROR;\n          } else {\n             udpPacketBuffer->dataAvail = nRead;\n             /* handle optional sequence number */\n             retVal = processUDPRecvSeqNum(connection);             \n             if (retVal == RTIOSTREAM_ERROR) {\n                return retVal;\n             }\n          }\n       }\n       /* get data from the buffer */\n       /* for the special case where we request a  */\n       /* size of 0 bytes, return the whole buffer */\n       if (udpPacketBuffer->dataAvail) {\n          if (size == 0) {\n            nRead = udpPacketBuffer->dataAvail;\n          } else {\n            nRead = MIN(udpPacketBuffer->dataAvail, sizeLim);\n          }\n          memcpy(dst, (void *) udpPacketBuffer->dataPtr, (size_t)nRead);\n          udpPacketBuffer->dataAvail -= nRead;\n          udpPacketBuffer->dataPtr += nRead;\n       }\n    }\n\n    if (retVal!=RTIOSTREAM_ERROR) {\n        *sizeRecvd = (size_t) nRead;\n    }\n\n    return retVal;\n} /* end socketDataGet */ \n\n\n/* Function: socketDataSet =====================================================\n * Abstract:\n *  Utility function to send data via the specified socket\n */\nstatic int socketDataSet(\n    ConnectionData * connection,\n    const void *src,\n    const size_t size,\n    size_t *sizeSent)\n{\n    int nSent;    \n    int retVal = RTIOSTREAM_NO_ERROR;\n    const void *sendSrc = src;    \n\n    /* Ensure size is not out of range for socket API send function */\n    int sizeLim = (int) MIN(size, INT_MAX);\n\n    if (connection->protocol == UDP_PROTOCOL) {\n       /* limit sends according to max packet size */\n       int maxPacketSize = connection->udpData->maxPacketSize;\n       if (connection->udpData->isUsingSeqNum) {          \n          int transferAmount;\n          UDPPacketBuffer * udpPacketBuffer = connection->udpData->sendBuffer;\n          /* need to apply sequence number and then increment it */\n          resetUDPPacketBuffer(udpPacketBuffer); \n          /* set data src */          \n          sendSrc = udpPacketBuffer->dataPtr;\n          /* add sequence number to the buffer \n           *\n           * sequence number is always transmitted / received in \n           * host Endian */\n          memcpy(udpPacketBuffer->dataPtr, \n                 &connection->udpData->sendSeqNum,\n                 UDP_SEQ_NUM_SIZE);\n          udpPacketBuffer->dataPtr += UDP_SEQ_NUM_SIZE;\n          udpPacketBuffer->dataAvail += UDP_SEQ_NUM_SIZE;                \n          /* copy the data - don't overflow the packet buffer */\n          transferAmount = MIN(sizeLim, maxPacketSize - udpPacketBuffer->dataAvail);\n          memcpy(udpPacketBuffer->dataPtr,\n                 src, \n                 (size_t)transferAmount);\n          udpPacketBuffer->dataAvail += transferAmount;                                   \n          sizeLim = udpPacketBuffer->dataAvail;\n       }\n       else {\n          sizeLim = MIN(maxPacketSize, sizeLim);\n       }\n    }\n\n    nSent = send(connection->sock, (send_buffer_t)sendSrc, (size_t)sizeLim, 0);\n    if (nSent == SOCK_ERR) {\n        retVal = RTIOSTREAM_ERROR;\n    } else { \n        if ((connection->protocol == UDP_PROTOCOL) &&\n            (connection->udpData->isUsingSeqNum) && \n            (nSent > 0)) {\n           if (nSent < (int) UDP_SEQ_NUM_SIZE) {\n              /* expected the sequence number to have transmitted */\n              retVal = RTIOSTREAM_ERROR;\n              return retVal;\n           }\n           else {\n              if (connection->verbosity) {\n                 printf(\"Sent UDP packet with sequence number: %u\\n\", connection->udpData->sendSeqNum);\n              }\n              /* increment sequence number */\n              connection->udpData->sendSeqNum++;\n              nSent -= UDP_SEQ_NUM_SIZE;\n           }          \n        }\n        *sizeSent = (size_t)nSent;\n    }\n\n    return retVal;\n}\n\n/* Function: serverStreamRecv =================================================\n * Abstract:\n *  Send data from the server-side\n */\nstatic int serverStreamRecv( \n    ConnectionData * connection, \n    void * dst,\n    size_t size,\n    size_t * sizeRecvd)\n{\n    int retVal = RTIOSTREAM_NO_ERROR;\n    *sizeRecvd = 0;\n\n    if (connection->sock == INVALID_SOCKET) {\n       /* Attempt to open connection */\n       serverAcceptSocket(connection);\n    }\n\n    if (connection->sock != INVALID_SOCKET) {\n        int pending;\n        if (connection->blockingRecvTimeout != BLOCKING_RECV_TIMEOUT_NEVER) {\n           /* only call costly \"select\" if necessary */\n           retVal = socketDataPending(connection->sock, \n                                      connection,\n                                      &pending, \n                                      connection->blockingRecvTimeout);\n        }\n        else {\n           /* block in \"recv\" if necessary */\n           pending = 1;\n        }\n\n        if ( (pending !=0) && (retVal==RTIOSTREAM_NO_ERROR) && (size>0) ) {\n           \n            retVal = socketDataGet(connection, (char *)dst, size, sizeRecvd);\n            \n            if (*sizeRecvd == 0) {\n                \n                if (errno == RTIOSTREAM_ECONNRESET) {\n                    /* If we are closing the connection and we received this\n                     * error, it means the other side of the connection was\n                     * already closed.  Since we are expecting this, we can\n                     * ignore this particular error.\n                     */\n                    retVal = RTIOSTREAM_NO_ERROR;\n                } else {\n                    /* Connection closed gracefully by client */\n                }\n\n                close(connection->sock);\n                connection->sock = INVALID_SOCKET;\n            }\n        }\n        \n        if ( retVal == RTIOSTREAM_ERROR ) {\n            close(connection->sock);\n            connection->sock = INVALID_SOCKET;\n        }\n    }\n\n    return retVal;\n}\n\n/* Function: serverOpenSocket =================================================\n * Abstract:\n *  Opens the listening socket to be used for accepting an incoming connection.\n */\nstatic SOCKET serverOpenSocket(int port, char * serverInfoFile, CommsProtocol protocol, int udpSendBufSize, int udpRecvBufSize)\n{\n\n    struct sockaddr_in serverAddr;\n    int sockStatus;\n    rtiostream_socklen_t sFdAddSize     = (rtiostream_socklen_t) sizeof(struct sockaddr_in);\n    SOCKET lFd;\n    int option;     \n\n    /*\n    * Create a TCP or UDP based socket.\n    */\n    memset((void *) &serverAddr,0,(size_t)sFdAddSize);\n    serverAddr.sin_family      = AF_INET;\n    serverAddr.sin_port        = htons((unsigned short int) port);\n    serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n    if (protocol == TCP_PROTOCOL) {\n        lFd = socket(AF_INET, SOCK_STREAM, 0);\n    }\n    else {\n        lFd = socket(AF_INET, SOCK_DGRAM, 0);\n    }\n    \n    if (lFd == INVALID_SOCKET) {\n        printf(\"socket() call failed.\\n\");\n    } else {\n        /*\n        * Listening socket should always use the SO_REUSEADDR option\n        * (\"Unix Network Programming - Networking APIs:Sockets and XTI\",\n        *   Volume 1, 2nd edition, by W. Richard Stevens).\n        */\n        option = 1;\n        sockStatus = \n            setsockopt(lFd,SOL_SOCKET,SO_REUSEADDR,(char*)&option,sizeof(option));\n        if (sockStatus == SOCK_ERR) {\n            printf(\"setsocketopt() call failed.\\n\");\n            close(lFd);\n            lFd = INVALID_SOCKET;\n        }\n        if (protocol == TCP_PROTOCOL)\n        {     \n            if (lFd != INVALID_SOCKET)\n            {\n                /* Disable Nagle's Algorithm*/ \n                option = 1;\n                sockStatus = \n                    setsockopt(lFd,IPPROTO_TCP,TCP_NODELAY,(char*)&option,sizeof(option));\n                if (sockStatus == SOCK_ERR) { \n                    printf(\"setsocketopt() TCP_NODELAY call failed.\\n\");\n                    close(lFd); \n                    lFd = INVALID_SOCKET; \n                }\n            }\n        } \n        if (protocol == UDP_PROTOCOL)\n        {\n            if (lFd != INVALID_SOCKET)\n            {\n\n                /* increase the UDP socket send size to increase the \n                * transfer rate */\n                sockStatus = \n                    setsockopt(lFd, SOL_SOCKET, SO_SNDBUF,(char*)&udpSendBufSize, sizeof(int));\n                if (sockStatus == SOCK_ERR) { \n                    printf(\"setsocketopt() SO_SNDBUF call failed.\\n\");\n                    close(lFd); \n                    lFd = INVALID_SOCKET; \n                }   \n            }\n\n            if (lFd != INVALID_SOCKET)\n            {\n                /* increase the UDP socket receive size to decrease the \n                * possibility of buffer overflow */\n                sockStatus = \n                    setsockopt(lFd, SOL_SOCKET, SO_RCVBUF,(char*)&udpRecvBufSize, sizeof(int));\n                if (sockStatus == SOCK_ERR) { \n                    printf(\"setsocketopt() SO_RCVBUF call failed.\\n\");\n                    close(lFd); \n                    lFd = INVALID_SOCKET; \n                } \n            }\n        }\n    }\n\n    if (lFd != INVALID_SOCKET) {\n        sockStatus = bind(lFd, (struct sockaddr *) &serverAddr, sFdAddSize);\n        if (sockStatus == SOCK_ERR) {\n            printf(\"bind() call failed: %s\\n\", strerror(errno));\n            close(lFd);\n            lFd = INVALID_SOCKET;\n        }\n    }\n\n    if (lFd != INVALID_SOCKET) {\n        if (port == 0) {\n            /* port 0 specifies dynamic free port allocation\n            * reuse serverAddr to store the actual address / port */\n            sockStatus = getsockname(lFd, (struct sockaddr *) &serverAddr, &sFdAddSize);           \n            if (sockStatus == SOCK_ERR) {\n                fprintf(stderr,\"getsockname() call failed: %s\\n\", strerror(errno));\n                close(lFd);\n                lFd = INVALID_SOCKET;               \n            } else { \n                if(serverInfoFile != NULL) {\n                    FILE* fh;\n                    uint16_T serverPortNo;\n                    int fprintfErr = 0;\n                    int fcloseErr = 0;\n                    \n                    /* Open file in append mode to save info already stored in the file*/\n                    fh = fopen(serverInfoFile,\"a\"); \n#ifdef __LCC64__\n                    /* This is needed due to an issue with LCC64, see the following geck:  g919889 */\n                    fseek ( fh, 0 , SEEK_END );\n#endif\n                    if (fh == NULL) {\n                        fprintf(stderr,\"Unable to open output file to write server port number: %s\\n\", strerror(errno));\n                        lFd = INVALID_SOCKET;\n                    }\n\n                    serverPortNo = ntohs(serverAddr.sin_port);\n                    fprintfErr = fprintf(fh, \"Server Port Number: %d\\n\", serverPortNo);\n                    if (fprintfErr < 0) {\n                        fprintf(stderr,\"Server port number is: %d\\nUnable to write server port number to output file: %s\\n\",\n                                serverPortNo, strerror(errno));\n                        lFd = INVALID_SOCKET;\n                    }\n                    \n                    fcloseErr = fclose(fh);\n                    if (fcloseErr == EOF) {\n                        fprintf(stderr,\"Server port number is: %d\\nUnable to close output file after writing server port number: %s\\n\", \n                                serverPortNo ,strerror(errno));\n                        lFd = INVALID_SOCKET;\n                    }\n                    \n                } else {\n                    /* write the server port number to stdout */\n                    SERVER_PORT_PRINTF(\"Server Port Number: %d\\n\", ntohs(serverAddr.sin_port));\n                }\n            }                 \n        }\n    }\n    if (protocol == TCP_PROTOCOL) {\n        if (lFd != INVALID_SOCKET) {\n            sockStatus = listen(lFd, 2);\n            if (sockStatus == SOCK_ERR) {\n                printf(\"listen() call failed.\\n\");\n                close(lFd);\n                lFd = INVALID_SOCKET;\n            }\n        }\n    }\n    return lFd;\n}\n/* Function: serverAcceptSocket =================================================\n * Abstract:\n *  Called when the target is not currently connected to the host, this \n *  function attempts to open the connection.  \n *\n *  In the case of sockets, this is a passive operation in that the host\n *  initiates contact, the target simply listens for connection requests.\n *\n * NOTES:\n \n * Blocks according to blockingRecvTimeout. When\n * polling, there may be no open requests pending.  In this case, this\n * function returns without making a connection; this is not an error.\n */\nstatic void serverAcceptSocket(ConnectionData * connection)\n{\n   struct sockaddr_in clientAddr;\n   rtiostream_socklen_t     sFdAddSize     = sizeof(struct sockaddr_in);\n   SOCKET  cFd            = INVALID_SOCKET;\n   int error             = RTIOSTREAM_NO_ERROR;\n   int pending;    \n\n   /* Check that the listening socket is still valid and open a new socket if\n    * not */\n   if (connection->serverData->listenSock == INVALID_SOCKET) {\n      connection->serverData->listenSock = serverOpenSocket(connection->serverData->port,\n            connection->serverData->serverInfoFile, \n            connection->protocol,\n            connection->udpSendBufSize, connection->udpRecvBufSize);\n   }\n\n   /* pass listenSock rather than sock */\n   error = socketDataPending(connection->serverData->listenSock, \n         connection,\n         &pending, \n         connection->blockingRecvTimeout);\n\n   if ( (pending > 0) && (error==RTIOSTREAM_NO_ERROR) ) {\n      if (connection->protocol == TCP_PROTOCOL) {\n         /*\n          * Wait to accept a connection on the comm socket.\n          */\n         cFd = accept(connection->serverData->listenSock, \n                     (struct sockaddr *)&clientAddr,\n                     &sFdAddSize);\n\n         if (cFd == INVALID_SOCKET) {\n            printf(\"accept() for comm socket failed.\\n\");\n            error = RTIOSTREAM_ERROR;\n         } \n\n         if (error == RTIOSTREAM_ERROR) {\n            close(connection->serverData->listenSock);\n            connection->serverData->listenSock = INVALID_SOCKET;\n         } \n      }\n      else {\n         /* UDP - data is pending */\n         struct sockaddr clientSA;\n         rtiostream_socklen_t clientSALen;\n         /* new connection, make sure we reset expectedRecvSeqNum, \n          * if sequence numbers are in use */\n         connection->udpData->resetExpectedRecvSeqNum = 1;\n         /* Do the initial UDP server \"recvfrom\" to get the \n          * client sockaddr.   Data read will be placed \n          * ready in the UDP packet buffer. */\n         error = initialUDPServerRecvfrom(connection, &clientSA, &clientSALen); \n         if (error == RTIOSTREAM_ERROR) {\n            close(connection->serverData->listenSock);\n            connection->serverData->listenSock = INVALID_SOCKET;\n            printf(\"initialUDPServerRecvfrom() failed.\\n\");\n         }\n         else {\n            /* connect exclusively to the client so we no longer\n             * have to use recvfrom / sendto */\n            if (connect(connection->serverData->listenSock, \n                        &clientSA, \n                        clientSALen) == SOCK_ERR) {\n               close(connection->serverData->listenSock);\n               connection->serverData->listenSock = INVALID_SOCKET;\n               printf(\"Server connect() failed.\\n\");\n            } \n         } \n         /* for UDP, the socket and listening socket are the same */\n         cFd = connection->serverData->listenSock;\n      }\n   }\n   /* set sock */\n   connection->sock = cFd;\n} \n\n\n/* Function: nameLookup =======================\n * Lookup target network name.\n */\n#if (!defined(VXWORKS))\nstatic unsigned long nameLookup(char * hostName) {\n\n    struct hostent * hp = NULL;\n    struct in_addr * iaddr = NULL;\n    unsigned long addr = INADDR_NONE;\n\n    /*\n     * Default to localhost if hostname not specified.\n     */\n    if (hostName == NULL) {\n        static char localhost[] = \"localhost\";\n        hostName = localhost;\n    }\n    \n    /*\n     * See if the address is an IPV4 dot separated address:\n     */\n    addr = inet_addr(hostName);\n\n    if (addr == INADDR_NONE) {\n        /* Since the address is not an IPV4 dot separated address, \n         * do a name lookup to get this: \n         */\n        hp = gethostbyname(hostName);\n        if (hp == NULL) {\n          printf(\"gethostbyname() call failed.\\n\");\n  \t  addr = INADDR_NONE;\n        } else {\n          iaddr = (struct in_addr *) hp->h_addr;\n          addr = iaddr->s_addr;\n        }\n    }\n    return(addr);\n}\n#endif\n\n/* Function: processArgs ====================================================\n * Abstract:\n *  Process the arguments specified by the user when opening the rtIOStream.\n *      \n *  If any unrecognized options are encountered, ignore them.\n *\n * Returns zero if successful or RTIOSTREAM_ERROR if \n * an error occurred.\n *\n *  o IMPORTANT!!!\n *    As the arguments are processed, their strings should be NULL'd out in\n *    the argv array. \n */\nstatic int processArgs(\n    const int         argc,\n    void            * argv[],\n    char           ** hostName, \n    unsigned int    * portNum,\n    unsigned int    * isClient,\n    int             * isBlocking,\n    int             * recvTimeout, \n    char           ** serverInfoFile, \n    CommsProtocol   * protocol, \n    int             * maxPacketSize, \n    VerbosityLevel  * verbosity, \n    int             * isUsingSeqNum,\n    int             * udpSendBufSize,\n    int             * udpRecvBufSize)\n{\n    int        retVal    = RTIOSTREAM_NO_ERROR;\n    int        count           = 0;\n\n    while(count < argc) {\n        const char *option = (char *)argv[count];\n        count++;\n\n        if (option != NULL) {\n\n            if ((strcmp(option, \"-hostname\") == 0) && (count != argc)) {\n\n                *hostName = (char *)argv[count];\n                count++;\n                argv[count-2] = NULL;\n                argv[count-1] = NULL;\n\n            } else if ((strcmp(option, \"-port\") == 0) && (count != argc)) {\n                char       tmpstr[2];\n                int itemsConverted;\n                const char *portStr = (char *)argv[count];\n\n                count++;     \n                \n                itemsConverted = sscanf(portStr,\"%d%1s\", (int *) portNum, tmpstr);\n                if ( (itemsConverted != 1) || \n                     ( ((*portNum != 0) && (*portNum < 255)) || (*portNum > 65535)) \n                    ) {\n                    \n                    retVal = RTIOSTREAM_ERROR;\n                } else {\n\n                    argv[count-2] = NULL;\n                    argv[count-1] = NULL;\n                }           \n                \n            } else if ((strcmp(option, \"-client\") == 0) && (count != argc)) {\n                \n                *isClient = ( strcmp( (char *)argv[count], \"1\") == 0 );\n\n                count++;\n                argv[count-2] = NULL;\n                argv[count-1] = NULL;\n\n            } else if ((strcmp(option, \"-blocking\") == 0) && (count != argc)) {\n                \n                *isBlocking = ( strcmp( (char *)argv[count], \"1\") == 0 );\n\n                count++;\n                argv[count-2] = NULL;\n                argv[count-1] = NULL;\n\n            } else if ((strcmp(option, \"-verbose\") == 0) && (count != argc)) {\n                int verbosityVal;\n                int itemsConverted;\n                const char *verbosityStr = (char *)argv[count];\n                count++;\n                itemsConverted = sscanf(verbosityStr,\"%d\", &verbosityVal);\n\n                if ((itemsConverted != 1) || (verbosityVal < 0)) {\n                    retVal = RTIOSTREAM_ERROR;\n                } else {\n                    *verbosity = (VerbosityLevel) verbosityVal;\n                    argv[count-2] = NULL;\n                    argv[count-1] = NULL;\n               }\n\n            } else if ((strcmp(option, \"-recv_timeout_secs\") == 0) && (count != argc)) {\n                char       tmpstr[2];\n                int itemsConverted;\n                const char *timeoutSecsStr = (char *)argv[count];\n\n                count++;     \n                \n                itemsConverted = sscanf(timeoutSecsStr,\"%d%1s\", (int *) recvTimeout, tmpstr);\n                if ( itemsConverted != 1 ) {\n                    retVal = RTIOSTREAM_ERROR;\n                } else {\n\n                    argv[count-2] = NULL;\n                    argv[count-1] = NULL;\n                }           \n\n            } else if((strcmp(option, \"-server_info_file\") == 0) && (count != argc)) {\n                *serverInfoFile= (char *) argv[count];\n                \n                count++;\n                argv[count-2] = NULL;\n                argv[count-1] = NULL;\n            } else if ((strcmp(option, \"-protocol\") == 0) && (count != argc)) {\n              char * protocolStr = (char *) argv[count];\n              count++;\n              argv[count-2] = NULL;\n              argv[count-1] = NULL;\n              /* initialize dependent properties */\n              *isUsingSeqNum = 0;\n              /* process protocolStr */\n              if (strcmp(protocolStr, TCP_PROTOCOL_STRING) == 0) {\n                 *protocol = TCP_PROTOCOL;                \n              }\n              else if (strcmp(protocolStr, UDP_PROTOCOL_STRING) == 0) {\n                 *protocol = UDP_PROTOCOL;\n              }\n              else if (strcmp(protocolStr, UDP_PACKET_LOSS_DETECTON_PROTOCOL_STRING) == 0) {\n                 *protocol = UDP_PROTOCOL;\n                 /* enable sequence number protocol */\n                 *isUsingSeqNum = 1;\n              }\n              else {\n                 /* unrecognized protocol */\n                 retVal = RTIOSTREAM_ERROR;\n              }            \n            } else if ((strcmp(option, \"-udpmaxpacketsize\") == 0) && (count != argc)) {\n               char       tmpstr[2];\n               int itemsConverted;\n               const char *maxUPDSizeStr = (char *)argv[count];\n\n               count++;     \n\n               itemsConverted = sscanf(maxUPDSizeStr,\"%d%1s\", maxPacketSize, tmpstr);\n               if ( itemsConverted != 1 ) {\n                  retVal = RTIOSTREAM_ERROR;\n               } else {\n                  argv[count-2] = NULL;\n                  argv[count-1] = NULL;\n               } \n             }else if ((strcmp(option, \"-udpsendbuffersize\") == 0) && (count != argc)) {\n               char       tmpstr[2];\n               int itemsConverted;\n               const char *udpSendBufSizeStr = (char *)argv[count];\n\n               count++;     \n\n               itemsConverted = sscanf(udpSendBufSizeStr,\"%d%1s\", udpSendBufSize, tmpstr);\n               if ( itemsConverted != 1 ) {\n                  retVal = RTIOSTREAM_ERROR;\n               } else {\n                  argv[count-2] = NULL;\n                  argv[count-1] = NULL;\n               } \n           }else if ((strcmp(option, \"-udpreceivebuffersize\") == 0) && (count != argc)) {\n               char       tmpstr[2];\n               int itemsConverted;\n               const char *udpRecvBufSizeStr = (char *)argv[count];\n\n               count++;     \n\n               itemsConverted = sscanf(udpRecvBufSizeStr,\"%d%1s\", udpRecvBufSize, tmpstr);\n               if ( itemsConverted != 1 ) {\n                  retVal = RTIOSTREAM_ERROR;\n               } else {\n                  argv[count-2] = NULL;\n                  argv[count-1] = NULL;\n               } \n            } else {\n                /* issue a warning for the unexpected argument: exception \n                 * is first argument which might be the executable name (\n                 * SIL/PIL and extmode use-cases). */\n                if ((count!=1) || (strncmp(option, \"-\", 1)==0)) {\n                    printf(\"The argument '%s' passed to rtiostream_tcpip is \"\n                            \"not valid and will be ignored.\\n\", option);\n                }\n            }\n        }\n    }\n    return retVal;\n}\n\n/* Function: clientOpenSocket =================================================\n * Abstract:\n *  Open a connection as Client\n */\n#if (!defined(VXWORKS))\nstatic SOCKET clientOpenSocket(char * hostName, unsigned int portNum, CommsProtocol protocol, int udpSendBufSize, int udpRecvBufSize) {\n    \n    struct sockaddr_in sa;\n    unsigned long addr = INADDR_NONE;\n    int errStatus = RTIOSTREAM_NO_ERROR;\n    SOCKET cSock = INVALID_SOCKET;\n\n    addr = nameLookup(hostName);\n\n    if (addr!=INADDR_NONE) {\n        \n         sa.sin_addr.s_addr = addr;\n         sa.sin_family = AF_INET; /*hp->h_addrtype;*/\n         sa.sin_port   = htons((unsigned short) portNum);\n\n        /*\n         * Create the sockets & make connections.\n         */\n        if (protocol == TCP_PROTOCOL) {\n           cSock = socket(PF_INET,SOCK_STREAM,0);\n        } \n        else {\n           cSock = socket(PF_INET,SOCK_DGRAM,0);\n        }\n        \n        if (cSock == INVALID_SOCKET) {\n            errStatus = RTIOSTREAM_ERROR;\n            printf(\"socket() call failed for comm socket.\\n\");\n        }\n    } else {\n      errStatus = RTIOSTREAM_ERROR;\n    }\n \n    if (protocol == UDP_PROTOCOL)\n    {\n        if (errStatus!=RTIOSTREAM_ERROR)\n        {\n            /* increase the UDP socket send size to increase the \n            * transfer rate */\n           int sockStatus = \n                setsockopt(cSock, SOL_SOCKET, SO_SNDBUF,(char*)&udpSendBufSize, sizeof(int));\n           if (sockStatus == SOCK_ERR) { \n              printf(\"setsocketopt() SO_SNDBUF call failed.\\n\");\n              cSock = INVALID_SOCKET;\n              errStatus = RTIOSTREAM_ERROR;\n           }    \n        }\n        if (errStatus!=RTIOSTREAM_ERROR)\n        {\n            /* increase the UDP socket receive size to decrease the \n            * possibility of buffer overflow */\n           int sockStatus = \n                setsockopt(cSock, SOL_SOCKET, SO_RCVBUF,(char*)&udpRecvBufSize, sizeof(int));\n           if (sockStatus == SOCK_ERR) { \n              printf(\"setsocketopt() SO_RCVBUF call failed.\\n\");\n              cSock = INVALID_SOCKET;\n              errStatus = RTIOSTREAM_ERROR;\n           } \n       }\n    }\n\n    if (errStatus!=RTIOSTREAM_ERROR) {\n        if (connect(cSock, (struct sockaddr *)&sa, sizeof(sa)) == SOCK_ERR) {\n            char tmp[1024];\n\n            sprintf(tmp,\n                    \"Attempting to establish connection with hostname '%s' \"\n                    \"through port %d.\\n\", \n                    hostName,\n                    ntohs(sa.sin_port));\n            cSock = INVALID_SOCKET;\n            printf(\"%s\",tmp);\n        } \n    }\n\n    return cSock;\n}\n#endif\n\n/* Function: waitForClientClose =============================================\n * Abstract:\n *\n * Allow the client to close its end of the socket connection before the server\n * closes its own socket.\n *\n * The server will receive any outstanding data on the socket.   When the server\n * receives 0 bytes, it indicates that it has acknowledged that the client \n * is closing its socket (this is essential for the client to complete\n * closing its socket without error) or that it timed out waiting for the client to \n * close its socket.\n *\n */\nstatic int waitForClientClose(ConnectionData * connection) {\n   int retVal = RTIOSTREAM_NO_ERROR;\n#define TMP_BUF_SIZE (40)\n   char * tmpBuf[TMP_BUF_SIZE];\n   size_t numRecvd;          \n   /* cache the original blockingRecvTimeout */\n   int savedBlockingRecvTimeout = connection->blockingRecvTimeout;      \n   /* wait time for client to close its socket */\n   connection->blockingRecvTimeout = BLOCKING_RECV_TIMEOUT_SOCK_SHUTDOWN;\n   do {         \n      retVal = serverStreamRecv(connection, (void *) tmpBuf, TMP_BUF_SIZE, &numRecvd);\n   } while ((numRecvd > 0) && (retVal == RTIOSTREAM_NO_ERROR));\n   /* restore blockingRecvTimeout */\n   connection->blockingRecvTimeout = savedBlockingRecvTimeout;\n#undef TMP_BUF_SIZE\n   return retVal;\n}\n\n/***************** VISIBLE FUNCTIONS ******************************************/\n\n/* Function: rtIOStreamOpen =================================================\n * Abstract:\n *  Open the connection with the target.\n */\nint rtIOStreamOpen(int argc, void * argv[])\n{\n    char               *xHostName = NULL; /* default */\n    char               *serverInfoFile = NULL; /* default */\n    unsigned int        xPortNum     = (SERVER_PORT_NUM); /* default */\n    unsigned int        isClient = 0; /* default */\n    CommsProtocol       protocol = DEFAULT_PROTOCOL;\n    int                 isBlockingRecv = EXT_BLOCKING; /* default */\n    int                 blockingRecvTimeout = DEFAULT_BLOCKING_RECV_TIMEOUT; /* rogue value */\n    int                 maxPacketSize = DEFAULT_MAX_UDP_PACKET_SIZE;\n    VerbosityLevel      verbosity = DEFAULT_VERBOSITY;\n    int                 isUsingSeqNum = DEFAULT_IS_USING_SEQ_NUM;\n    int                 udpSendBufSize = DEFAULT_UDP_SOCKET_SEND_SIZE_REQUEST;\n    int                 udpRecvBufSize = DEFAULT_UDP_SOCKET_RECEIVE_SIZE_REQUEST;\n    int result = RTIOSTREAM_NO_ERROR;\n    int streamID;\n    SOCKET sock = INVALID_SOCKET;\n\n    /* determine the streamID for this new connection */\n    streamID = getConnectionID();\n    if (streamID == RTIOSTREAM_ERROR) {\n       result = RTIOSTREAM_ERROR;\n       return result;\n    }\n\n    result = processArgs(argc, argv, \n                         &xHostName, \n                         &xPortNum, \n                         &isClient, \n                         &isBlockingRecv,\n                         &blockingRecvTimeout, \n                         &serverInfoFile, \n                         &protocol, \n                         &maxPacketSize, \n                         &verbosity, \n                         &isUsingSeqNum,\n                         &udpSendBufSize,\n                         &udpRecvBufSize);\n\n    if (result == RTIOSTREAM_ERROR) {\n       return result;\n    }\n\n    if (verbosity) {\n       printf(\"rtIOStreamOpen\\n\");\n    }\n\n    if (isBlockingRecv) {\n       /* blocking: if blockingRecvTimeout has not been set, initialize to the client or\n        * server specific default */\n       if ((blockingRecvTimeout == DEFAULT_BLOCKING_RECV_TIMEOUT) ||\n           (blockingRecvTimeout < BLOCKING_RECV_TIMEOUT_10MS)) {\n          if (isClient) {\n             blockingRecvTimeout = DEFAULT_BLOCKING_RECV_TIMEOUT_SECS_CLIENT;\n          }\n          else {\n             blockingRecvTimeout = DEFAULT_BLOCKING_RECV_TIMEOUT_SECS_SERVER;\n          }\n       }\n    }\n    else {\n       /* not blocking: set the timeout to return immediately */\n       blockingRecvTimeout = BLOCKING_RECV_TIMEOUT_NOWAIT;\n    }\n\n#ifdef VXWORKS /* UDP is not supported on VxWorks */\n    if (protocol == UDP_PROTOCOL) {\n       result = RTIOSTREAM_ERROR;\n       return result;\n    }\n#endif\n\n#ifdef _WIN32\n    {\n        WSADATA data;\n        if (WSAStartup((MAKEWORD(1,1)), &data)) {\n            result = RTIOSTREAM_ERROR;\n            printf(\"WSAStartup() call failed.\\n\");\n        }\n    }\n#endif\n\n    if (result != RTIOSTREAM_ERROR) { /* polyspace DEFECT:USELESS_IF [Not a defect:Unset] \"Needed for Windows\" */\n        if (isClient == 1) {\n#if (!defined(VXWORKS)) /* Client side connection not supported on VxWorks */\n            sock = clientOpenSocket(xHostName, xPortNum, protocol,udpSendBufSize,udpRecvBufSize);\n            if (sock == INVALID_SOCKET) {\n            result = RTIOSTREAM_ERROR;\n            }\n#endif\n        } else {           \n            sock = serverOpenSocket((int)xPortNum, serverInfoFile, protocol,udpSendBufSize,udpRecvBufSize);            \n            if (sock == INVALID_SOCKET) {\n                result = RTIOSTREAM_ERROR;\n            }\n        }\n    }\n\n    if (result != RTIOSTREAM_ERROR) {\n       int isServer;\n       if (isClient == 1) {\n          isServer = 0;   \n       }\n       else {\n          isServer = 1;\n       }\n       result = initConnectionData(streamID, \n             isServer, \n             protocol, \n             sock, \n             blockingRecvTimeout,\n             maxPacketSize, \n             (int)xPortNum, \n             serverInfoFile, \n             verbosity, \n             isUsingSeqNum,\n             udpSendBufSize,\n             udpRecvBufSize);\n    }\n    \n    if (result != RTIOSTREAM_ERROR) {\n       result = streamID;\n    }\n    else {\n       if (sock != INVALID_SOCKET) {\n          /* cleanup */\n          close(sock);\n       }\n    }\n    return result;\n}\n\n/* Function: rtIOStreamSend =====================================================\n * Abstract:\n *  Sends the specified number of bytes on the comm line. Returns the number of\n *  bytes sent (if successful) or a negative value if an error occurred. As long\n *  as an error does not occur, this function is guaranteed to set the requested\n *  number of bytes; the function blocks if tcpip's send buffer doesn't have\n *  room for all of the data to be sent\n */\nint rtIOStreamSend(\n    int streamID,\n    const void *src,\n    size_t size,\n    size_t *sizeSent)\n{\n    int retVal = RTIOSTREAM_NO_ERROR;\n    ConnectionData * connection = getConnectionData(streamID);\n    *sizeSent = 0;\n\n    if (connection == NULL) {\n       retVal = RTIOSTREAM_ERROR;\n       return retVal;\n    }\n\n    if (connection->isServer) {\n        if (connection->sock == INVALID_SOCKET) {\n            serverAcceptSocket(connection);\n        }\n\n        if (connection->sock != INVALID_SOCKET) {\n#ifndef VXWORKS\n           retVal = socketDataSet(connection, src, size, sizeSent);\n#else           \n           /*\n            * VXWORKS send prototype does not have src as const.  This suppresses\n            * the compiler warning.\n            */\n\n           retVal = socketDataSet(connection, (char *)src, size, sizeSent);\n#endif\n        }\n    } else { /* Client stream */\n        retVal = socketDataSet(connection, src, size, sizeSent);\n    }\n\n    if (connection->verbosity) {\n        if ((*sizeSent > 0) || (connection->verbosity >= VERBOSITY_LEVEL_2)) {\n            size_t currElement;\n            printf(\"rtIOStreamSend (connection id %d): size = %lu, sizeSent = %lu: \", \n                   streamID, \n                   (unsigned long) size, \n                   (unsigned long) *sizeSent);\n        \n            for (currElement = 0; currElement < *sizeSent; currElement++) {\n                printf(\"%02x \", ((const unsigned char *) src)[currElement]);\n            }\n            printf(\"\\n\");\n        }       \n    }\n\n    return retVal;\n}\n\n\n/* Function: rtIOStreamRecv ================================================\n * Abstract: receive data\n *\n */\nint rtIOStreamRecv(\n    int      streamID,\n    void   * dst, \n    size_t   size,\n    size_t * sizeRecvd) \n{\n    int retVal = RTIOSTREAM_NO_ERROR;\n    ConnectionData * connection = getConnectionData(streamID);\n\n    *sizeRecvd = 0;\n\n    if (connection == NULL) {\n       retVal = RTIOSTREAM_ERROR;\n       return retVal;\n    }\n\n    if (connection->isServer) {\n        retVal = serverStreamRecv(connection, dst, size, sizeRecvd); \n    } else { /* Client stream */\n        int pending;\n        if (connection->blockingRecvTimeout != BLOCKING_RECV_TIMEOUT_NEVER) {\n           /* only call costly \"select\" if necessary */\n           retVal = socketDataPending(connection->sock, \n                                      connection,\n                                      &pending, \n                                      connection->blockingRecvTimeout);\n        }\n        else {\n           /* block in \"recv\" if necessary */\n           pending = 1;\n        }\n        if (pending && (size>0))  {\n            retVal = socketDataGet(connection, (char *)dst, size, sizeRecvd);\n        }\n    }\n\n    if (connection->verbosity) {\n        if ((*sizeRecvd > 0 ) || (connection->verbosity >= VERBOSITY_LEVEL_2)) {\n            size_t currElement;\n            printf(\"rtIOStreamRecv (connection id %d): size = %lu, sizeRecvd = %lu: \", \n                   streamID,\n                   (unsigned long) size,\n                   (unsigned long) *sizeRecvd);\n\n            for (currElement = 0; currElement < *sizeRecvd; currElement++) {\n                printf(\"%02x \", ((const unsigned char *) dst)[currElement]);\n            }\n            printf(\"\\n\");\n        }\n    }\n    \n    return retVal;\n}\n\n/* Function: rtIOStreamClose ================================================\n * Abstract: close the connection.\n *\n */\nint rtIOStreamClose(int streamID)\n{\n    int retVal = RTIOSTREAM_NO_ERROR;\n    ConnectionData * connection = getConnectionData(streamID);\n    if (connection == NULL) {\n       retVal = RTIOSTREAM_ERROR;\n       return retVal;\n    }\n\n    if (connection->verbosity) {\n       printf(\"rtIOStreamClose (connection id %d)\\n\", streamID);\n    }\n\n    if (connection->isServer) {\n        /* Only if the client actually made a connection */\n        if (connection->sock != INVALID_SOCKET) {\n            if (connection->protocol == TCP_PROTOCOL) {\n                /* graceful shutdown */\n                retVal = waitForClientClose(connection);\n            }\n            \n            /* close the socket */\n            close(connection->sock);\n            connection->sock = INVALID_SOCKET;\n        }\n       if (connection->protocol == TCP_PROTOCOL) {\n          /* TCP: additionally close the listening socket\n           *\n           * for UDP, sock and listenSock are the same\n           * socket - avoid closing it twice */\n          close(connection->serverData->listenSock);\n       }\n       /* set to INVALID_SOCKET for all protocol types */\n       connection->serverData->listenSock = INVALID_SOCKET;       \n    } else {\n       SOCKET cSock = connection->sock;\n       close(cSock);\n\n    }\n    freeConnectionData(connection);\n    return retVal;\n}\n\n"},{"name":"xcp.c","type":"source","group":"legacy","path":"E:\\Matlab\\toolbox\\coder\\xcp\\src\\target\\slave\\protocol\\src","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2021 The MathWorks, Inc.\n*\n* File: xcp.c\n*\n* Abstract:\n*  Implementation of XCP Protocol Layer\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp.h\"\n#include \"xcp_internal.h\"\n#include \"xcp_transport_internal.h\"\n#include \"xcp_cfg.h\"\n#include \"xcp_types.h\"\n#include \"xcp_standard.h\"\n#include \"xcp_daq.h\"\n#include \"xcp_calibration.h\"\n#include \"xcp_mem.h\"\n\n\n/*****************************************************************************\n    Internal Global variables\n******************************************************************************/\n/* Initialization status */\nstatic boolean_T initialized = false;\n\n/** Current Status of the XCP Slave according to the Protocol Layer */\nstatic XcpStatus xcpStatus = XCP_DISCONNECTED;\n\n/** Current Session Status of the XCP Slave according to the Protocol Layer\n(see XCP Session Status bit masks) */\nstatic uint8_T xcpSessionStatus = 0;\n\n/** XCP Slave Resource Protection Status (see XCP Resource bit masks) */\nstatic uint8_T xcpResourceProtectionStatus = 0;\n\n/** XCP Session configuration Id\n@note xcpSessionConfigurationId has to be set with an XCP SET_REQUEST\n      before a STORE_DAQ_REQ set. This allows the master device to verify that\n      automatically started DAQ lists contain the expected data transfer\n      configuration.\n      However the (optional) SET_REQUEST command is not supported at the\n      moment, so this value is hard-coded to 0 and never changed. */\nstatic uint16_T xcpSessionConfigurationId = 0;\n\n/** This table contains the list of XcpPacketLookupFunction to be used\n    (for each packets group) to get access to the corresponding\n    Packet Input and Output handlers */\nstatic XcpPacketLookupFunction groupPacketLookup[XCP_PACKETS_GROUP_NUMBER];\n\n/*****************************************************************************\n    Internal Functions\n******************************************************************************/\n/** Free the msgBuffer and allocate a new buffer to host a XCP packet of newPacketSize */\nstatic XcpErrorCode msgBufferRealloc(void **msgBuffer, size_t *msgBufferSize, size_t *packetOffset, size_t newPacketSize)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    xcpPoolId_T reservedPoolId = xcpTransportCtoReservedMemPoolId();\n\n    /* Free the original buffer */\n    xcpMemFree(*msgBuffer);\n\n    /* Allocate a new buffer with the proper size */\n    *msgBufferSize = xcpTransportMsgBufferSize(newPacketSize, XCP_CTO);\n    *packetOffset = xcpTransportPacketOffset();\n\n    if (*msgBufferSize > 0) {\n        /* Using a reserved memory pool, to guarantee that the reply\n           gets always delivered to the XCP Master */\n        *msgBuffer = xcpMemAllocFromPool(reservedPoolId, *msgBufferSize);\n        if (*msgBuffer == NULL) {\n            errorCode = XCP_NO_MEMORY;\n        }\n    }\n    else {\n        errorCode = XCP_INV_SIZE;\n    }\n\n    return errorCode;\n}\n\n/** Input Packet Handler to be used for packets that need to be discarded */\nstatic XcpProtoErrorCode discardInputPacketHandler(void   *msgBuffer,\n                                                   size_t  xcpPacketOffset,\n                                                   size_t *outputPacketSize)\n{\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    XCP_PRINTF(\"Detected attempt to send packet ID %xH when the XCP connection has not been established\\n\", \n               *((uint8_T *) msgBuffer + xcpPacketOffset));\n\n    if (msgBuffer != NULL) {\n        xcpMemFree(msgBuffer);\n    }\n\n    *outputPacketSize = 0;\n\n    return XCP_PROTO_SUCCESS;\n}\n\n/** Input Packet Handler to be used for unknown commands */\nstatic XcpProtoErrorCode unknownInputPacketHandler(void   *msgBuffer,\n                                                   size_t  xcpPacketOffset,\n                                                   size_t *outputPacketSize)\n{\n    XCP_UNUSED_PARAM(msgBuffer);\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    XCP_PRINTF(\"Packet ID  %xH is not supported at the moment\\n\",\n    *((uint8_T *) msgBuffer + xcpPacketOffset));\n\n    *outputPacketSize = XCP_ERROR_PACKET_SIZE_IN_BYTES;\n\n    return XCP_PROTO_CMD_UNKNOWN;\n}\n\n/** The function returns the Group Id corresponding to a given Packet ID */\nstatic XcpPacketsGroupIdType xcpGetPacketGroupID(uint8_T pid, uint8_T level1Code)\n{\n    XcpPacketsGroupIdType groupId = XCP_UNKNOWN_PACKET_GROUP_ID;\n\n    if ((pid >= XCP_STANDARD_PACKETS_ID_MIN) /* && (pid <= XCP_STANDARD_PACKETS_ID_MAX) */) {\n        groupId = XCP_STANDARD_PACKETS_ID;\n    }\n    else if ((pid >= XCP_CALIBRATION_PACKETS_ID_MIN) && (pid <= XCP_CALIBRATION_PACKETS_ID_MAX)) {\n        groupId = XCP_CALIBRATION_PACKETS_ID;\n    }\n    else if (((pid >= XCP_DAQ_PACKETS_ID_MIN) && (pid <= XCP_DAQ_PACKETS_ID_MAX)) ||\n             ((pid == XCP_PID_LEVEL1_COMMAND) && \n             (level1Code >= XCP_DAQ_LEVEL1_CODE_MIN) && (level1Code <= XCP_DAQ_LEVEL1_CODE_MAX))) {\n        groupId = XCP_DAQ_PACKETS_ID;\n    }\n    else if ((pid >= XCP_PROGRAM_PACKETS_ID_MIN) && (pid <= XCP_PROGRAM_PACKETS_ID_MAX)) {\n        groupId = XCP_PROGRAM_PACKETS_ID;\n    }\n\n    return groupId;\n}\n\n/** Identify the internal packet handler functions responsible for processing a specific XCP packet.\n    @note If the status is XCP_DISCONNECTED, no packets are accepted except XCP_PID_CONNECT\n          If the command is not supported, the XCP slave has to reply with a ERR response packet\n          and ERR_CMD_UNKNOWN error code */\nstatic void xcpGetPacketHandlers(const uint8_T *packet,\n                                 size_t packetSize,\n                                 XcpInputPacketHandler  *inputHandler,\n                                 XcpOutputPacketHandler *outputHandler)\n{\n    /* uint8_T gets promoted to a higher data-type. On C2000, it is \n     * unsigned int. Since data is packed, a non-zero MSB in packet[0]\n     * can then make PID an invalid identifier. Explicitly mask to\n     * remove the upper byte if any.\n     */\n     const XcpLevel1CommandPacketFrame* command = (const XcpLevel1CommandPacketFrame*) packet;\n\n    uint8_T PID = command->PID; /* Retrieve Packet ID */\n    uint8_T level1CommandCode = 0;\n    if ((PID == XCP_PID_LEVEL1_COMMAND) && (packetSize > 1)) {\n        level1CommandCode = command->level1Code;\n    }\n\n    if (xcpStatus != XCP_DISCONNECTED) {\n        /* Check if the received XCP packet is supported and\n           retrieve the corresponding handler */\n        XcpPacketsGroupIdType groupId = xcpGetPacketGroupID(PID, level1CommandCode);\n        boolean_T found = false;\n\n        if (groupId != XCP_UNKNOWN_PACKET_GROUP_ID) {\n            XcpPacketLookupFunction getPacket = groupPacketLookup[groupId];\n            const XcpPacketHandlers *packetInfo = NULL;\n\n            if (getPacket != NULL) {\n                packetInfo = getPacket(PID);\n                found = (packetInfo != NULL);\n                if (found) {\n                    *inputHandler = packetInfo->inputHandler;\n                    *outputHandler = packetInfo->outputHandler;\n                }\n            }\n        }\n\n        if (!found) {\n            /* Packet is not supported*/\n            *inputHandler = unknownInputPacketHandler;\n            *outputHandler = genericOutputPacketHandler;\n        }\n    }\n    else {\n        /* If the XCP Slave is in the XCP_DISCONNECTED status,\n        * no other XCP packets are accepted except XCP_PID_CONNECT */\n        if (PID == XCP_PID_CONNECT) {\n            XcpPacketLookupFunction getPacket = groupPacketLookup[XCP_STANDARD_PACKETS_ID];\n\n            *inputHandler = NULL;\n            *outputHandler = NULL;\n\n            if (getPacket != NULL) {\n                const XcpPacketHandlers *connect = getPacket(XCP_PID_CONNECT);\n                if (connect != NULL) {\n                    /* Note: if the Protocol layer is correctly configured,\n                       the CONNECT command should be always implemented */\n                    *inputHandler = connect->inputHandler;\n                    *outputHandler = connect->outputHandler;\n                }\n            }\n        }\n        else {\n            /* Input packet must be ignored and discarded */\n            *inputHandler = discardInputPacketHandler;\n            *outputHandler = NULL;\n        }\n    }\n}\n\n/*****************************************************************************\n    Public Functions (shared across different XCP commands)\n******************************************************************************/\nXcpStatus xcpStatusGet(void)\n{\n    return xcpStatus;\n}\n\nvoid xcpStatusSet(XcpStatus status)\n{\n    xcpStatus = status;\n}\n\nuint8_T xcpSessionStatusGet(void)\n{\n    return xcpSessionStatus;\n}\n\nvoid xcpSessionStatusSet(uint8_T status)\n{\n    xcpSessionStatus = status;\n}\n\nvoid xcpSessionStatusSetMask(uint8_T mask)\n{\n    XCP_SET_MASK(xcpSessionStatus, mask);\n}\n\nvoid xcpSessionStatusClearMask(uint8_T mask)\n{\n    XCP_CLEAR_MASK(xcpSessionStatus, mask);\n}\n\nuint8_T xcpResourceProtectionStatusGet(void)\n{\n    return xcpResourceProtectionStatus;\n}\n\nvoid xcpResourceProtectionStatusSet(uint8_T status)\n{\n    xcpResourceProtectionStatus = status;\n}\n\nvoid xcpResourceProtectionSetMask(uint8_T mask)\n{\n    XCP_SET_MASK(xcpResourceProtectionStatus, mask);\n}\n\nvoid xcpResourceProtectionClearMask(uint8_T mask)\n{\n    XCP_CLEAR_MASK(xcpResourceProtectionStatus, mask);\n}\n\nuint16_T xcpSessionConfigurationIdGet(void)\n{\n    return xcpSessionConfigurationId;\n}\n\nvoid xcpSessionConfigurationIdSet(uint16_T id)\n{\n    xcpSessionConfigurationId = id;\n}\n\nvoid genericOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize)\n{\n    XCP_UNUSED_PARAM(packetSize);\n\n    if (inputCode == XCP_PROTO_SUCCESS) {\n        /* Send back a generic RES packet */\n        XcpGenericResPacketFrame *frame = (XcpGenericResPacketFrame *)packet;\n        frame->PID = XCP_PID_RES;\n    }\n    else {\n        XcpErrorPacketFrame *frame = (XcpErrorPacketFrame *)packet;\n        frame->PID = XCP_PID_ERR;\n\n        switch (inputCode) {\n        case XCP_PROTO_MEMORY_OVERFLOW:\n            frame->errorCode = XCP_ERR_MEMORY_OVERFLOW;\n            break;\n        case XCP_PROTO_SEQUENCE_ERROR:\n            frame->errorCode = XCP_ERR_SEQUENCE;\n            break;\n        case XCP_PROTO_OUT_OF_RANGE:\n            frame->errorCode = XCP_ERR_OUT_OF_RANGE;\n            break;\n        case XCP_PROTO_CMD_UNKNOWN:\n            frame->errorCode = XCP_ERR_CMD_UNKNOWN;\n            break;\n        case XCP_PROTO_SYNCH:\n            frame->errorCode = XCP_ERR_CMD_SYNC;\n            break;\n        case XCP_PROTO_WRITE_PROTECTED:\n            frame->errorCode = XCP_ERR_WRITE_PROTECTED;\n            break;\n        case XCP_PROTO_CMD_SYNTAX:\n            frame->errorCode = XCP_ERR_CMD_SYNTAX;\n            break;\n        case XCP_PROTO_DAQ_ACTIVE:\n            frame->errorCode = XCP_ERR_DAQ_ACTIVE;\n            break;\n        case XCP_PROTO_MODE_NOT_VALID:\n            frame->errorCode = XCP_ERR_MODE_NOT_VALID;\n            break;\n        case XCP_PROTO_DAQ_CONFIG_ERROR:\n            frame->errorCode = XCP_ERR_DAQ_CONFIG;\n            break;\n        case XCP_PROTO_BUSY:\n            frame->errorCode = XCP_ERR_CMD_BUSY;\n            break;\n        case XCP_PROTO_ACCESS_DENIED:\n            frame->errorCode = XCP_ERR_ACCESS_DENIED;\n            break;\n        case XCP_PROTO_SEGMENT_UNKNOWN:\n            frame->errorCode = XCP_ERR_SEGMENT_NOT_VALID;\n            break;\n        case XCP_PROTO_PAGE_UNKNOWN:\n            frame->errorCode = XCP_ERR_PAGE_NOT_VALID;\n            break;\n        case XCP_PROTO_GENERIC_ERROR:\n            frame->errorCode = XCP_ERR_GENERIC;\n            break;\n        default:\n            /* This should never happen */\n            XCP_PRINTF(\"genericOutputPacketHandler error: %xH input code is not supported\", inputCode);\n            frame->errorCode = XCP_ERR_CMD_UNKNOWN;\n        }\n    }\n}\n\n\nconst XcpPacketHandlers* xcpFindPacket(XcpRxPidCode pid, const XcpPacketHandlers* packets, size_t packetsNumber)\n{\n    const XcpPacketHandlers* packet = NULL;\n\n    if (packets != NULL) {\n        size_t i = 0;\n        for (i = 0; (i < packetsNumber) && (packet == NULL); i++) {\n            if (pid == packets[i].PID) {\n                packet = &packets[i];\n            }\n        }\n    }\n\n    return packet;\n}\n\n/*****************************************************************************\n    Public Functions (implementing the Protocol Layer interface)\n******************************************************************************/\nXcpErrorCode xcpInit(\n    int   argc,   /**< [in] number of init parameters              */\n    void *argv[]  /**< [in] array of parameters values (C strings) */\n    )\n{\n    XCP_UNUSED_PARAM(argc);\n    XCP_UNUSED_PARAM(argv);\n\n    XCP_ERROR_IF(initialized, XCP_ERROR, \"xcpInit: protocol layer already initialized\\n\");\n\n    /* Initialize Standard Commands support */\n    xcpStandardInit();\n    groupPacketLookup[XCP_STANDARD_PACKETS_ID] = xcpStandardGetPacketLookup();\n\n    /* Initialize DAQ lists (and STIM) support */\n    xcpDaqInit();\n    groupPacketLookup[XCP_DAQ_PACKETS_ID] = xcpDaqGetPacketLookup();\n\n    /* Initialize Calibration support */\n    xcpCalibrationInit();\n    groupPacketLookup[XCP_CALIBRATION_PACKETS_ID] = xcpCalibrationGetPacketLookup();\n\n    initialized = true;\n\n    return XCP_SUCCESS;\n}\n\nXcpErrorCode xcpRun(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *msgBuffer = NULL;\n    size_t   msgBufferSize = 0;\n    size_t   packetOffset = 0;\n    size_t   packetSize = 0;\n    size_t   outputPacketSize = 0;\n    uint8_T *packet = NULL;\n    XcpInputPacketHandler  inputHandler  = NULL;\n    XcpOutputPacketHandler outputHandler = NULL;\n\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpRun: protocol layer not initialized\\n\");\n\n    /* Extract a packet from the transport layer */\n    errorCode = xcpTransportRxPacketGet(XCP_TRANSPORT_RX_DEFAULT_QUEUE,\n                                       (void**)&msgBuffer, &msgBufferSize,\n                                       &packetOffset, &packetSize);\n    if ((errorCode != XCP_SUCCESS) &&\n        (errorCode != XCP_PKT_OUT_OF_SEQUENCE) && /* If a wrong packet counter is detected,       */\n        (errorCode != XCP_PKT_LOST)) {            /* the packet content is still considered valid */\n        goto error;\n    }\n\n    /* Check buffer sizes and retrieve the pointer to the XCP packet area */\n    if ((msgBuffer == NULL) || ((packetOffset + XCP_IN_HW_AG(packetSize)) > msgBufferSize)) { \n        errorCode = XCP_INV_SIZE;\n        goto error;\n    }\n\n    /* Identify the handler suitable for processing the given XCP packet */\n    packet = msgBuffer + packetOffset;\n    xcpGetPacketHandlers(packet, packetSize, &inputHandler, &outputHandler);\n\n    /* An input handler needs to be always present */\n    if (inputHandler == NULL) {\n        XCP_PRINTF(\"xcpRun: missing input handler for packet ID %xH\", packet[0]);\n        errorCode = XCP_ERROR;\n        goto error;\n    }\n\n    /* Process input packet */\n    protoErrorCode = inputHandler(msgBuffer, packetOffset, &outputPacketSize);\n\n    if ((outputHandler != NULL) && (outputPacketSize > 0)) {\n        errorCode = XCP_SUCCESS;\n\n        /* An Output Packet needs to be generated -> check if current message buffer is big enough for the response packet */\n        if (packetSize < outputPacketSize) {\n            errorCode = msgBufferRealloc((void **)&msgBuffer, &msgBufferSize, &packetOffset, outputPacketSize);\n        }\n\n        XCP_MEMSET(packet, 0, XCP_IN_HW_AG(packetSize));\n\n        if (errorCode == XCP_SUCCESS) {\n            /* Fill the response packet */\n            packet = msgBuffer + packetOffset;\n            outputHandler(protoErrorCode, packet, outputPacketSize);\n\n            /* Send the response back to the Transport Layer\n               @note to guarantee the maximum responsiveness even when the TX traffic\n                     is maxed out, the highest priority queue is used */\n            errorCode = xcpTransportTxPacketSet(XCP_TRANSPORT_TX_HIGHEST_PRIO_QUEUE,\n                                                XCP_TRANSPORT_NOT_A_DAQ,\n                                                msgBuffer, msgBufferSize,\n                                                packetOffset, outputPacketSize);\n            if (errorCode != XCP_SUCCESS) {\n                goto error;\n            }\n        }\n    }\n\n    return errorCode;\n\nerror:\n    if (msgBuffer != NULL) {\n        xcpMemFree(msgBuffer);\n    }\n\n    return errorCode;\n}\n\nXcpErrorCode xcpEvent(XcpEventIdType eventId)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    uint32_T timestamp = 0;\n\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpEvent: protocol layer not initialized\\n\");\n\n    timestamp = (uint32_T)XCP_TIMESTAMP_GET();\n    \n    /* Process DAQ Lists associated to the event */\n    errorCode = xcpDaqEvent(eventId, timestamp, false);\n\n    return errorCode;\n}\n\nXcpErrorCode xcpEventExternalTimestamp(XcpEventIdType eventId, uint32_T timestamp)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpEvent: protocol layer not initialized\\n\");\n\n    /* Process DAQ Lists associated to the event */\n    errorCode = xcpDaqEvent(eventId, timestamp, false);\n\n    return errorCode;\n}\n\nXcpErrorCode xcpEventNotificationReq(XcpEventCode eventCode, const void *eventData, size_t eventDataSize)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t packetOffset = xcpTransportPacketOffset();\n    size_t maxEventDataSize = xcpTransportMaxCtoSize() - XCP_EVENT_PACKET_SIZE_IN_BYTES;\n    size_t packetSize = 0;\n    uint8_T *msgBuffer = NULL;\n    size_t msgBufferSize = 0;\n\n    /* Validate input parameters */\n    XCP_ERROR_IF((eventDataSize > 0) && (eventData == NULL), XCP_INV_ARG, \"xcpEventNotificationReq: invalid eventData buffer\\n\");\n    XCP_ERROR_IF(eventDataSize > maxEventDataSize, XCP_INV_ARG, \"xcpEventNotificationReq: invalid eventDataSize\\n\");\n\n    /* Calculate the required message buffer size */\n    packetSize = eventDataSize + XCP_EVENT_PACKET_SIZE_IN_BYTES;\n\n    /* Allocate the message buffer */\n    msgBufferSize = xcpTransportMsgBufferSize(packetSize, XCP_CTO);\n    msgBuffer = (uint8_T *)xcpMemAlloc(msgBufferSize);\n\n    if (msgBuffer != NULL) {\n        XcpEventPacketFrame *frame = (XcpEventPacketFrame *) (msgBuffer + packetOffset);\n\n        /* Fill the EV packet information */\n        frame->PID = XCP_PID_EV;\n        frame->eventCode = eventCode;\n\n        if (eventDataSize > 0) {\n            uint8_T *packetEventData = msgBuffer + packetOffset + XCP_IN_HW_AG(XCP_EVENT_PACKET_SIZE_IN_BYTES);\n\n            /* Copy the optional event data */\n            XCP_MEMCPY(packetEventData, eventData, XCP_IN_HW_AG(eventDataSize));\n        }\n\n        /* Send the EV packet to the Transport Layer\n           @note to guarantee that this packet gets delivered as soon as possible\n                 to the XCP Master, the highest priority queue is used */\n        errorCode = xcpTransportTxPacketSet(XCP_TRANSPORT_TX_HIGHEST_PRIO_QUEUE,\n                                            XCP_TRANSPORT_NOT_A_DAQ,\n                                            msgBuffer, msgBufferSize,\n                                            packetOffset, packetSize);\n        if (errorCode != XCP_SUCCESS) {\n            xcpMemFree(msgBuffer);\n        }\n    }\n    else\n    {\n        errorCode = XCP_NO_MEMORY;\n    }\n\n    return errorCode;\n}\n\nXcpErrorCode xcpRemoteServiceReq(XcpReqServiceCode serviceReqCode, const void *serviceReqData, size_t serviceReqDataSize)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t packetOffset = xcpTransportPacketOffset();\n    size_t maxServiceReqDataSize = xcpTransportMaxCtoSize() - XCP_SERVICE_REQ_PACKET_SIZE_IN_BYTES;\n    size_t packetSize = 0;\n    uint8_T *msgBuffer = NULL;\n    size_t msgBufferSize = 0;\n\n    /* Validate input parameters */\n    XCP_ERROR_IF((serviceReqDataSize > 0) && (serviceReqData == NULL), XCP_INV_ARG, \"xcpRemoteServiceReq: invalid serviceReqData buffer\\n\");\n    XCP_ERROR_IF(serviceReqDataSize > maxServiceReqDataSize, XCP_INV_ARG, \"xcpRemoteServiceReq: invalid serviceReqDataSize\\n\");\n\n    /* Calculate the required message buffer size */\n    packetSize = serviceReqDataSize + XCP_SERVICE_REQ_PACKET_SIZE_IN_BYTES;\n\n    /* Allocate the message buffer */\n    msgBufferSize = xcpTransportMsgBufferSize(packetSize, XCP_CTO);\n    msgBuffer = (uint8_T *)xcpMemAlloc(msgBufferSize);\n\n    if (msgBuffer != NULL) {\n        XcpServiceReqPacketFrame *frame = (XcpServiceReqPacketFrame *) (msgBuffer + packetOffset);\n\n        /* Fill the SERV packet information */\n        frame->PID = XCP_PID_SERV;\n        frame->serviceReqCode = serviceReqCode;\n\n        if (serviceReqDataSize > 0) {\n            uint8_T *packetServiceReqData = msgBuffer + packetOffset + XCP_IN_HW_AG(XCP_SERVICE_REQ_PACKET_SIZE_IN_BYTES);\n\n            /* Copy the optional event data */\n            XCP_MEMCPY(packetServiceReqData, serviceReqData, XCP_IN_HW_AG(serviceReqDataSize));\n        }\n\n        /* Send the SERV packet to the Transport Layer\n           @note to guarantee that this packet gets delivered as soon as possible\n                 to the XCP Master, the highest priority queue is used */\n        errorCode = xcpTransportTxPacketSet(XCP_TRANSPORT_TX_HIGHEST_PRIO_QUEUE,\n                                            XCP_TRANSPORT_NOT_A_DAQ,\n                                            msgBuffer, msgBufferSize,\n                                            packetOffset, packetSize);\n        if (errorCode != XCP_SUCCESS) {\n            xcpMemFree(msgBuffer);\n        }\n    }\n    else\n    {\n        errorCode = XCP_NO_MEMORY;\n    }\n\n    return errorCode;\n}\n\nXcpStatus xcpGetStatus(void)\n{\n    return xcpStatus;\n}\n\nXcpErrorCode xcpReset(void)\n{\n    if (!initialized) {\n        XCP_PRINTF(\"xcpReset: protocol layer already reset\\n\");\n        /* Nothing to do: just printing out a warning message*/\n    }\n\n    /* Reset Calibration support */\n    xcpCalibrationReset();\n\n    /* Reset DAQ lists (and STIM) support */\n    xcpDaqReset();\n\n    /* Reset Standard Commands support */\n    xcpStandardReset();\n\n    XCP_MEMSET((void*)groupPacketLookup, 0, sizeof(groupPacketLookup));\n\n    initialized = false;\n\n    return XCP_SUCCESS;\n}\n\nXcpErrorCode xcpSetCustomPoolMemoryManager(XcpEventIdType eventId, XcpCustomAllocHandler allocHandler, XcpCustomFreeHandler freeHandler)\n{\n    XcpErrorCode errorCode;\n\n    /* Forward registration to DAQ list */\n    errorCode = xcpDaqSetCustomPoolMemoryManager(eventId, allocHandler, freeHandler);\n\n    return errorCode;\n}\n\nXcpErrorCode xcpGetCustomPoolMemoryManager(XcpEventIdType *eventId, XcpCustomAllocHandler *allocHandler, XcpCustomFreeHandler *freeHandler)\n{\n    XcpErrorCode errorCode;\n\n    /* Forward query to DAQ list */\n    errorCode = xcpDaqGetCustomPoolMemoryManager(eventId, allocHandler, freeHandler);\n\n    return errorCode;\n}\n\nXcpErrorCode xcpPackedModeEventsFlush(uint32_T timestamp)\n{\n    XcpErrorCode errorCode;\n\n    errorCode = xcpDaqEventsFlush(timestamp);\n\n    return errorCode;\n}\n\nXcpErrorCode xcpPackedModeEventReset(XcpEventIdType eventId)\n{\n    XcpErrorCode errorCode;\n    boolean_T resetSamples = true;\n\n    /* Reset the status of pending packed DAQ lists,\n       discarding incomplete packets. */\n    errorCode = xcpDaqEvent(eventId, 0, resetSamples);\n\n    return errorCode;\n}\n\n#ifdef XCP_INTERNAL_DAQ_CONFIG_ACCESS_SUPPORT\n\nXcpErrorCode xcpGetDaqOdtEntries(XcpEventIdType eventId,\n                                 XcpOdtEntry* entries,\n                                 size_t* entriesNumber,\n                                 size_t maxEntriesNumber)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    errorCode = xcpDaqGetOdtEntries(eventId, XCP_DIRECTION_DAQ,\n                                 entries, entriesNumber,\n                                 maxEntriesNumber);\n    return errorCode;\n}\n\n#endif /* XCP_INTERNAL_DAQ_CONFIG_ACCESS_SUPPORT */\n\n\n#ifndef XCP_DAQ_SUPPORT\n\nvoid xcpDaqInit(void) {}\nXcpPacketLookupFunction xcpDaqGetPacketLookup(void) {return NULL;}\nvoid xcpDaqSetPacketLookup(XcpPacketLookupFunction getPacket) {XCP_UNUSED_PARAM(getPacket);}\nXcpErrorCode xcpDaqEvent(XcpEventIdType eventId, uint32_T timestamp, boolean_T resetSamples) {XCP_UNUSED_PARAM(eventId); XCP_UNUSED_PARAM(timestamp); XCP_UNUSED_PARAM(resetSamples); return XCP_SUCCESS;}\nboolean_T xcpResetDaqListStatus(void) {return true;}\nXcpErrorCode xcpDaqEventsFlush(uint32_T timestamp) {XCP_UNUSED_PARAM(timestamp); return XCP_SUCCESS;}\nboolean_T xcpDaqLock(void) {return true;}\nvoid xcpDaqUnlock(void) {}\nvoid xcpDaqReset(void) {}\nXcpErrorCode xcpDaqSetCustomPoolMemoryManager(XcpEventIdType eventId, XcpCustomAllocHandler allocHandler, XcpCustomFreeHandler freeHandler) {\n    XCP_UNUSED_PARAM(eventId); XCP_UNUSED_PARAM(allocHandler); XCP_UNUSED_PARAM(freeHandler); return XCP_SUCCESS;}\nXcpErrorCode xcpDaqGetCustomPoolMemoryManager(XcpEventIdType *eventId, XcpCustomAllocHandler *allocHandler, XcpCustomFreeHandler *freeHandler) {\n    XCP_UNUSED_PARAM(eventId); XCP_UNUSED_PARAM(allocHandler); XCP_UNUSED_PARAM(freeHandler); return XCP_SUCCESS;}\n\n#ifdef XCP_INTERNAL_DAQ_CONFIG_ACCESS_SUPPORT\nXcpErrorCode xcpGetDaqOdtEntries(XcpEventIdType eventId, XcpOdtEntry* entries, size_t* entriesNumber, size_t maxEntriesNumber){\n    XCP_UNUSED_PARAM(eventId); XCP_UNUSED_PARAM(entries); XCP_UNUSED_PARAM(entriesNumber); XCP_UNUSED_PARAM(maxEntriesNumber); return XCP_SUCCESS;}\n#endif /* XCP_INTERNAL_DAQ_CONFIG_ACCESS_SUPPORT */\n\n#endif\n\n\n#ifndef XCP_CALIBRATION_SUPPORT\n\nvoid xcpCalibrationInit(void) {}\nXcpPacketLookupFunction xcpCalibrationGetPacketLookup(void) {return NULL;}\nvoid xcpCalibrationSetPacketLookup(XcpPacketLookupFunction getPacket) {XCP_UNUSED_PARAM(getPacket);}\nvoid xcpCalibrationReset(void) {}\n\n#endif\n"},{"name":"xcp_calibration.c","type":"source","group":"legacy","path":"E:\\Matlab\\toolbox\\coder\\xcp\\src\\target\\slave\\protocol\\src","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2017-2020 The MathWorks, Inc.\n*\n* File: xcp_calibration.c\n*\n* Abstract:\n*  Implementation of XCP Protocol Layer Calibration support\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp.h\"\n#include \"xcp_cfg.h\"\n#include \"xcp_calibration.h\"\n\n#ifdef XCP_CALIBRATION_SUPPORT\n\n#ifdef XCP_CALIBRATION_EXTENDED_SUPPORT\n#include \"xcp_calibration_ext.h\"\n#endif\n\n#include \"xcp_types.h\"\n#include \"xcp_calibration_types.h\"\n#include \"xcp_standard.h\"\n#include \"xcp_transport_internal.h\"\n\n/*****************************************************************************\n    Internal Functions specific to Calibration support\n******************************************************************************/\nstatic boolean_T isValidShortDownloadSize(uint8_T size)\n{\n    size_t addressGranularity = XCP_ADDRESS_GRANULARITY_BYTES_NUMBER;\n    size_t maxCtoSize = xcpTransportMaxCtoSize();\n\n    return (size <= ((maxCtoSize - 8) / addressGranularity));\n}\n\n#if XCP_SET_MTA_ENABLE == 1\n    static boolean_T isValidDownloadSize(uint8_T size)\n    {\n        size_t addressGranularity = XCP_ADDRESS_GRANULARITY_BYTES_NUMBER;\n        size_t maxCtoSize = xcpTransportMaxCtoSize();\n        \n        return ( (size >= 1)  && (size <= (maxCtoSize-2) / addressGranularity ) );\n    }\n#endif  /* XCP_SET_MTA_ENABLE == 1 */\n\n/** memcpy function used to copy data from packet to MTA address */\nstatic void xcpMemcpyToMTA(uint8_T *packet, uint8_T size)\n{\n    /* Retrieve memory address */\n    uint8_T *xcpMTARawPointer = xcpStandardGetAddressFromMta();\n\n    XCP_PRINTF(\"writing at address %p\\n\", xcpMTARawPointer);\n\n#ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n{\n    uint32_T address;\n    uint8_T addressExtension;\n    uint8_T dstOffsetBytes;\n    xcpStandardGetMta(&address, &addressExtension);\n    dstOffsetBytes = XCP_BYTE_OFFSET_GET(address);\n    xcpMemcpyByte(xcpMTARawPointer, dstOffsetBytes, packet, 0, size);\n}\n#else\n    XCP_MEMCPY(xcpMTARawPointer, packet, size);\n#endif\n}\n\n/*****************************************************************************\n    XCP DOWNLOAD\n******************************************************************************/\n#if XCP_SET_MTA_ENABLE == 1\n    static XcpProtoErrorCode downloadInputPacketHandler(void   *msgBuffer,\n        size_t  xcpPacketOffset,\n        size_t *outputPacketSize)\n    {\n        XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n        uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n        XcpDownloadCmdPacketFrame *frame = (XcpDownloadCmdPacketFrame *)packet;\n        boolean_T ok = false;\n        uint8_T *xcpMTARawPointer = xcpStandardGetAddressFromMta();\n\n        /* Check if the number of data elements is valid */\n        ok = isValidDownloadSize((uint8_T)frame->size);\n        XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n            (\"DOWNLOAD: invalid number of data elements (%d)\\n\", frame->size));\n            \n        /* Check if a valid MTA address is available */\n        XCP_INPUT_PKT_ERROR_IF((xcpMTARawPointer == 0) || (xcpMTARawPointer == NULL), \n            XCP_PROTO_ACCESS_DENIED, (\"DOWNLOAD: invalid address\\n\"));\n\n        XCP_PRINTF(\"DOWNLOAD: \");\n    \n        /* Update the value of the parameter with the data element content */\n        xcpMemcpyToMTA(packet + sizeof(XcpDownloadCmdPacketFrame), (uint8_T)frame->size);\n    \n        /* Post-increment MTA by the frame size in address granularity units */\n        xcpStandardIncrementMta((uint8_T)frame->size);\n        \n        *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n        return protoErrorCode;\n    }\n#endif  /* XCP_SET_MTA_ENABLE == 1 */\n\n/*****************************************************************************\n    XCP SHORT_DOWNLOAD\n******************************************************************************/\nstatic XcpProtoErrorCode shortDownloadInputPacketHandler(void   *msgBuffer,\n    size_t  xcpPacketOffset,\n    size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpShortDownloadCmdPacketFrame *frame = (XcpShortDownloadCmdPacketFrame *)packet;\n    boolean_T ok = false;\n\n    /* Check if the number of data elements is valid */\n    ok = isValidShortDownloadSize((uint8_T)frame->size);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"SHORT_DOWNLOAD: invalid number of data elements (%d)\\n\", frame->size));\n\n    /* Check if the memory address is valid and set the MTA pointer */\n    ok = xcpStandardSetMta(frame->address, (uint8_T)frame->addressExtension);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_ACCESS_DENIED, (\"SHORT_DOWNLOAD: invalid address\\n\"));\n\n    XCP_PRINTF(\"SHORT_DOWNLOAD: \");\n\n    /* Update the value of the parameter with the data element content */\n    xcpMemcpyToMTA(packet + sizeof(XcpShortDownloadCmdPacketFrame), (uint8_T)frame->size);\n\n    /* Post-increment MTA by the frame size in address granularity units */\n    xcpStandardIncrementMta((uint8_T)frame->size);\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n\n/** This table contains the list of supported Rx packets and the corresponding handlers */\nstatic const XcpPacketHandlers calibrationSupportedRxPacket[] =\n{\n#if XCP_SET_MTA_ENABLE == 1\n    { XCP_PID_DOWNLOAD,       downloadInputPacketHandler,     genericOutputPacketHandler },\n#endif\n    { XCP_PID_SHORT_DOWNLOAD, shortDownloadInputPacketHandler, genericOutputPacketHandler }\n};\n\n\n/*****************************************************************************\n    XCP Packet Lookup Function for basic calibration commands\n******************************************************************************/\n\n/* Default Calibration Packet Lookup function, supporting only basic commands\n   listed in the table above */\nstatic const XcpPacketHandlers* getPacket(XcpRxPidCode pid)\n{\n    return xcpFindPacket(pid, calibrationSupportedRxPacket,\n                         XCP_ELEMENTS_NUMBER(calibrationSupportedRxPacket));\n}\n\nstatic XcpPacketLookupFunction packetLookup = NULL;\n\n\n\n/*****************************************************************************\n    Public Functions (invoked within the Protocol Layer)\n******************************************************************************/\nvoid xcpCalibrationInit(void)\n{\n    /* Initialize the packet lookup function to support only basic\n       calibration commands */\n    xcpCalibrationSetPacketLookup(getPacket);\n\n#ifdef XCP_CALIBRATION_EXTENDED_SUPPORT\n    /* Initialize support for the extended list of calibration commands */\n    xcpCalibrationExtendedInit();\n#endif\n}\n\n\nXcpPacketLookupFunction xcpCalibrationGetPacketLookup(void)\n{\n    return packetLookup;\n}\n\n\nvoid xcpCalibrationSetPacketLookup(XcpPacketLookupFunction getPacket)\n{\n    packetLookup = getPacket;\n}\n\nvoid xcpCalibrationReset(void)\n{\n#ifdef XCP_CALIBRATION_EXTENDED_SUPPORT\n    /* Reset support for the extended list of calibration commands */\n    xcpCalibrationExtendedReset();\n#endif\n}\n\n#endif\n"},{"name":"xcp_daq.c","type":"source","group":"legacy","path":"E:\\Matlab\\toolbox\\coder\\xcp\\src\\target\\slave\\protocol\\src","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2021 The MathWorks, Inc.\n*\n* File: xcp_daq.c\n*\n* Abstract:\n*  Implementation of XCP Protocol Layer DAQ Lists (and STIM) support\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp.h\"\n#include \"xcp_internal.h\"\n#include \"xcp_cfg.h\"\n#include \"xcp_daq.h\"\n\n#ifdef XCP_DAQ_SUPPORT\n#include \"xcp_daq_ext.h\"\n#include \"xcp_transport_internal.h\"\n#include \"xcp_types.h\"\n#include \"xcp_daq_types.h\"\n#include \"xcp_mem.h\"\n\n/*****************************************************************************\n    Internal Global variables specific to DAQ support\n******************************************************************************/\n\n/** Dynamic DAQ Lists data structures */\nstatic XcpDaqLists xcpDynamicDaqLists;\n\n/** Number of event threads currently in execution */\nstatic size_t xcpRunningEventCounter = 0;\n\n/** ID of the selected DAQ List on START_STOP_DAQ_LIST command */\n#define XCP_INVALID_DAQ_LIST_ID -1\nstatic int32_T startStopDaqListId = XCP_INVALID_DAQ_LIST_ID;\n\n/** Pointer to current ODT entry */\nstatic XcpDaqPtr   xcpCurrentDaq = { 0xFFFF, 0xFF, 0xFF };\n\nstatic XcpEventCustomMemoryManager xcpEventCustomMemoryManager = {XCP_DAQ_CUSTOM_MEMORY_INVALID_EVENT_ID, NULL, NULL};\n\n#ifndef XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n/* XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT is typically enabled\n   for multi-core applications, where it is critical to limit\n   the interference between threads streaming data.\n   For this reason, by default we enable the independent lock\n   of the DAQ list data structures between events */\n#define XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK 1\n#else\n/* XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT is typically disabled\n   for single-core bare-metal applications, where it is critical\n   to limit the memory footprint of the target executable.\n   For this reason, by default we disable the independent lock\n   of the DAQ list data structures between events and use a single\n   mutex to protect the DAQ lists data structures */\n#define XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK 0\n#endif\n\n#endif\n\n\n#if !defined(XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK) || (XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK == 0)\n/* Mutex protecting against the concurrent access to DAQ Lists data structures */\nstatic XCP_MUTEX_DEFINE(daqLock);\n\nstatic boolean_T xcpDaqWriteLock(XcpEventIdType eventId)\n{\n    boolean_T locked = false;\n    XCP_UNUSED_PARAM(eventId);\n    XCP_WRITE_TRY_LOCK(daqLock, xcpRunningEventCounter, locked);\n\n    return locked;\n}\n\nstatic void xcpDaqWriteUnlock(XcpEventIdType eventId)\n{\n    XCP_UNUSED_PARAM(eventId);\n    XCP_WRITE_UNLOCK(daqLock);\n}\n\nstatic void xcpDaqReadLock(XcpEventIdType eventId)\n{\n    XCP_UNUSED_PARAM(eventId);\n    XCP_READ_LOCK(daqLock, xcpRunningEventCounter);\n}\n\nstatic void xcpDaqReadUnlock(XcpEventIdType eventId)\n{\n    XCP_UNUSED_PARAM(eventId);\n    XCP_READ_UNLOCK(daqLock, xcpRunningEventCounter);\n}\n\n#else\n/* Each XCP event has an independent mutex to protect the read/write access\n   to the DAQ list data structures */\n#ifndef XCP_MAX_EVENT_DATA_NUMBER\n#define XCP_MAX_EVENT_DATA_NUMBER XCP_MAX_EVENT_CHANNEL\n#endif\n\ntypedef struct XcpEventData {\n    XCP_MUTEX_DEFINE(lock);\n} XcpEventData;\n\n/** Array of event-specific data */\nstatic XcpEventData xcpEventData[XCP_MAX_EVENT_DATA_NUMBER];\n\nstatic boolean_T xcpDaqWriteLock(XcpEventIdType eventId)\n{\n    XCP_MUTEX_LOCK(xcpEventData[eventId].lock);\n    return true;\n}\n\nstatic void xcpDaqWriteUnlock(XcpEventIdType eventId)\n{\n    XCP_MUTEX_UNLOCK(xcpEventData[eventId].lock);\n}\n\nstatic void xcpDaqReadLock(XcpEventIdType eventId)\n{\n    XCP_MUTEX_LOCK(xcpEventData[eventId].lock);\n}\n\nstatic void xcpDaqReadUnlock(XcpEventIdType eventId)\n{\n    XCP_MUTEX_UNLOCK(xcpEventData[eventId].lock);\n}\n\n#endif\n\n\n/*****************************************************************************\n    Internal Functions specific to DAQ support\n******************************************************************************/\n\n/* When enabled, timestamp is required for first ODT in the DAQ list */\n#if XCP_TIMESTAMP_FIXED == 0\n#define IS_TIMESTAMP_REQUIRED(mode, odtNumber) ((odtNumber == 0) && \\\n            XCP_READ_BIT_VALUE(mode, XCP_DAQ_MODE_TIMESTAMP_MASK))\n#else\n#define IS_TIMESTAMP_REQUIRED(mode, odtNumber) (odtNumber == 0)\n#endif\n\n/* Incrementing pointer. byteOffset argument will have a valid value only when\n   we are emulating as a BYTE addressable target. Otherwise, it is 0. */\n#ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n#define XCP_HW_PTR_INCREMENT(ptr, incr, byteOffset) (uint8_T *)(byteOffset ? (ptr + XCP_IN_HW_AG(incr - 1)) : (ptr + XCP_IN_HW_AG(incr)))\n#else\n#define XCP_HW_PTR_INCREMENT(ptr, incr, byteOffset) (uint8_T *)(ptr + incr)\n#endif\n\n/* Update byteOffset when emulating as a BYTE addressable target */\n#ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n#define XCP_HW_BYTE_OFFSET_UPDATE(offset, size) ((offset + size) % XCP_HARDWARE_ADDRESS_GRANULARITY_BYTES_NUMBER)\n#else\n#define XCP_HW_BYTE_OFFSET_UPDATE(offset, size) 0\n#endif\n\n#define IS_USING_CUSTOM_POOL(x) (x == xcpEventCustomMemoryManager.eventId)\n\nstatic boolean_T isActiveDaqList(uint16_T daqListId)\n{\n    return (xcpDynamicDaqLists.daq[daqListId].status == XCP_DAQ_SELECTED) ||\n           (xcpDynamicDaqLists.daq[daqListId].status == XCP_DAQ_STARTED);\n}\n\nstatic boolean_T noActiveDaqLists(void)\n{\n    boolean_T found = 0;\n    uint16_T i = 0;\n\n    for (i = 0; (i < xcpDynamicDaqLists.daqCount) && !found; i++) {\n        found = isActiveDaqList(i);\n    }\n\n    return !found;\n}\n\nstatic boolean_T isValidDaqPtr(uint16_T daqListId, uint8_T odtId, uint8_T odtEntryId)\n{\n    boolean_T ret = (xcpDynamicDaqLists.daq != NULL) &&\n                    (daqListId < xcpDynamicDaqLists.daqCount) &&\n                    (xcpDynamicDaqLists.daq[daqListId].odt != NULL) &&\n                    (odtId < xcpDynamicDaqLists.daq[daqListId].odtCount) &&\n                    (xcpDynamicDaqLists.daq[daqListId].odt[odtId].entry != NULL) &&\n                    (odtEntryId < xcpDynamicDaqLists.daq[daqListId].odt[odtId].entriesCount);\n\n    return ret;\n}\n\nstatic boolean_T isValidDaqEntry(uint8_T bitOffset, uint8_T size, uint32_T address)\n{\n    boolean_T ret = false;\n    uint16_T  entrySize = size;     /* cast to 16-bit avoids -Werror=type-limits */\n\n    if (bitOffset == 0xFF) {\n        /* \"Normal\" (non-bitwise) access has been selected */\n        if ( (entrySize <= XCP_MAX_ODT_ENTRY_SIZE) &&\n             (entrySize % (XCP_ODT_ENTRY_SIZE_GRANULARITY/XCP_ADDRESS_GRANULARITY_BYTES_NUMBER) == 0) &&\n             (  address % (XCP_ODT_ENTRY_SIZE_GRANULARITY/XCP_ADDRESS_GRANULARITY_BYTES_NUMBER) == 0) ) {\n            ret = true;\n        }\n    }\n    else {\n        /* Bitwise access has been selected */\n        if ((bitOffset <= 0x1F) && (address % XCP_ODT_ENTRY_SIZE_GRANULARITY) &&\n            (entrySize == XCP_ODT_ENTRY_SIZE_GRANULARITY)) {\n            ret = true;\n        }\n    }\n\n    return ret;\n}\n\n/** The current supported mode includes:\n- alternating = 0\n- direction = 0 (DAQ only)\n- timestamp = 1 or 0\n- PID OFF = 0\n*/\nstatic boolean_T isSupportedDaqListMode(uint8_T mode)\n{\n    #if XCP_TIMESTAMP_FIXED == 0\n        return ( (mode & ~XCP_DAQ_MODE_TIMESTAMP_MASK) == 0 );\n    #else\n        return (mode == XCP_DAQ_MODE_TIMESTAMP_MASK);\n    #endif\n}\n\nstatic boolean_T isValidStartStopMode(uint8_T mode)\n{\n    boolean_T ret = false;\n\n    if ((mode == XCP_DAQ_LIST_STOP) ||\n        (mode == XCP_DAQ_LIST_START) ||\n        (mode == XCP_DAQ_LIST_SELECT))\n        ret = true;\n\n    return ret;\n}\n\nstatic boolean_T isValidStartStopSynchMode(uint8_T mode)\n{\n    boolean_T ret = false;\n\n    if ((mode == XCP_DAQ_LIST_STOP_ALL) ||\n        (mode == XCP_DAQ_LIST_START_SELECTED) ||\n        (mode == XCP_DAQ_LIST_STOP_SELECTED))\n        ret = true;\n\n    return ret;\n}\n\nstatic boolean_T absoluteOdtNumberIdentification(void)\n{\n    return (XCP_ID_FIELD_TYPE == XCP_ID_ABSOLUTE_ODT_NUMBER);\n}\n\nstatic boolean_T isDaqPackedModeEnabled(uint16_T daqListId)\n{\n    /* DAQ Packed Mode is only supported for event-grouped packing and \n       reserved memory pool */\n\n    boolean_T isEnabled = (xcpDynamicDaqLists.daq[daqListId].packedMode == XCP_DAQ_EVENT_GROUPED_PACKING) &&\n                          !IS_USING_CUSTOM_POOL(xcpDynamicDaqLists.daq[daqListId].eventId);\n    \n#if XCP_MEM_DAQ_RESERVED_POOLS_NUMBER > 0\n    isEnabled = isEnabled && (daqListId < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER);\n#endif\n\n    return isEnabled;\n}\n\n/* Try to allocate a reserved memory pool dedicated to the packets in the DAQ list.\n   @note depending on the configuration of the memory allocator, this may fail\n         so we just set daq->poolId to XCP_INVALID_POOL_ID in that case */\nstatic XcpErrorCode createDaqReservedPool(XcpDaq *daq)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t poolBlockSize = 0;\n    int i = 0;\n\n    /* Calculate the max size for the ODT packets in the given DAQ list */\n    for (i = 0; i < daq->odtCount; i++) {\n        /* Calculate the required message buffer size */\n        size_t packetSize = XCP_IN_BYTES(daq->odt[i].size * daq->sampleCount + XCP_IN_AG(XCP_ID_FIELD_SIZE));\n        size_t msgBufferSize = 0;\n\n        if (IS_TIMESTAMP_REQUIRED(daq->mode, i)) {\n            /* The first DTO should also contain the Timestamp info */\n            packetSize += XCP_TIMESTAMP_SIZE;\n        }\n\n        msgBufferSize = xcpTransportMsgBufferSize(packetSize, XCP_DTO);\n\n        if (msgBufferSize > poolBlockSize) {\n            poolBlockSize = msgBufferSize;\n        }\n    }\n\n    /* Try the allocation of the dedicate pool */\n    errorCode = xcpMemReservedPoolCreate(poolBlockSize,\n                                         XCP_MEM_DAQ_RESERVED_POOL_BLOCKS_NUMBER * daq->odtCount,\n                                         &daq->poolId);\n    if (errorCode != XCP_SUCCESS) {\n        daq->poolId = XCP_INVALID_POOL_ID;\n    }\n\n    return errorCode;\n}\n\nstatic void destroyDaqReservedPool(XcpDaq *daq)\n{\n    if (daq->poolId != XCP_INVALID_POOL_ID) {\n        xcpMemReservedPoolDestroy(daq->poolId);\n    }\n\n    daq->poolId = XCP_INVALID_POOL_ID;\n}\n\n\n/*****************************************************************************\n    XCP SET DAQ PTR\n******************************************************************************/\nstatic XcpProtoErrorCode setDaqPtrInputPacketHandler(void   *msgBuffer,\n                                                     size_t  xcpPacketOffset,\n                                                     size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpSetDaqPtrCmdPacketFrame *frame = (XcpSetDaqPtrCmdPacketFrame *) packet;\n    uint16_T daqListId  = (uint16_T)frame->daqListId;\n    uint8_T  odtId      = (uint8_T)frame->odtId;\n    uint8_T  odtEntryId = (uint8_T)frame->odtEntryId;\n    boolean_T ok = false;\n\n    /* Check if the selected ODT Entry is available */\n    ok = isValidDaqPtr(daqListId, odtId, odtEntryId);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"SET_DAQ_PTR: ODT entry not available (DAQ %d, ODT %d, Entry %d)\\n\", daqListId, odtId, odtEntryId));\n\n    /* Check if the DAQ list is currently active */\n    ok = !isActiveDaqList(daqListId);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_DAQ_ACTIVE, (\"SET_DAQ_PTR: DAQ list %d is currently active\\n\", daqListId));\n\n    /* Everything is fine -> proceed and update the current ODT entry pointer */\n    XCP_PRINTF(\"SET_DAQ_PTR: updating current ODT entry pointer to DAQ %d, ODT %d, Entry %d\\n\",\n               daqListId, odtId, odtEntryId);\n\n    xcpCurrentDaq.daqListId  = daqListId;\n    xcpCurrentDaq.odtId      = odtId;\n    xcpCurrentDaq.odtEntryId = odtEntryId;\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP WRITE DAQ\n******************************************************************************/\nstatic XcpProtoErrorCode writeDaqInputPacketHandler(void   *msgBuffer,\n                                                    size_t  xcpPacketOffset,\n                                                    size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpWriteDaqCmdPacketFrame *frame = (XcpWriteDaqCmdPacketFrame *)packet;\n    uint16_T daqListId = xcpCurrentDaq.daqListId;\n    uint8_T  odtId = xcpCurrentDaq.odtId;\n    uint8_T  odtEntryId = xcpCurrentDaq.odtEntryId;\n    XcpOdtEntry *entry = NULL;\n    boolean_T ok = false;\n\n    /* Check if the selected ODT Entry is available */\n    ok = isValidDaqPtr(daqListId, odtId, odtEntryId);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_WRITE_PROTECTED,\n        (\"WRITE_DAQ: current ODT entry not available for write operations (DAQ %d, ODT %d, Entry %d)\\n\", daqListId, odtId, odtEntryId));\n\n    /* Check if the DAQ list is currently active */\n    ok = !isActiveDaqList(daqListId);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_DAQ_ACTIVE, (\"XCP_WRITE_DAQ: DAQ list %d is currently active\\n\", daqListId));\n\n    /* Check if the Entry values are valid */\n    ok = isValidDaqEntry((uint8_T)frame->bitOffset, (uint8_T)frame->size, (uint32_T)frame->address);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"XCP_WRITE_DAQ: invalid DAQ %d ODT %d Entry %d value: bitOffset = %xH size = %d addressExtension = %dH address = %xH\\n\",\n         daqListId, odtId, odtEntryId, frame->bitOffset, frame->size, frame->addressExtension, frame->address));\n\n    /* Everything is fine -> proceed and write the entry */\n    XCP_PRINTF(\"XCP_WRITE_DAQ: writing DAQ %d ODT %d Entry %d: bitOffset = %xH size = %d addressExtension = %dH address = %xH\\n\",\n               daqListId, odtId, odtEntryId, frame->bitOffset, frame->size, frame->addressExtension, frame->address);\n\n    entry = &(xcpDynamicDaqLists.daq[daqListId].odt[odtId].entry[odtEntryId]);\n\n    entry->bitOffset        = (uint8_T)frame->bitOffset;\n    entry->size             = (uint8_T)frame->size;\n    entry->addressExtension = (uint8_T)frame->addressExtension;\n    entry->address          = (uint32_T)frame->address;\n\n    /* After a successful WRITE_DAQ, the xcpDaqPtr odtEntryId needs to be post incremented */\n    xcpCurrentDaq.odtEntryId++;\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP SET DAQ LIST MODE\n******************************************************************************/\nstatic XcpProtoErrorCode setDaqListModeInputPacketHandler(void   *msgBuffer,\n                                                          size_t  xcpPacketOffset,\n                                                          size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpSetDaqListModeCmdPacketFrame *frame = (XcpSetDaqListModeCmdPacketFrame *)packet;\n    XcpDaq *daqList = NULL;\n    boolean_T ok = false;\n\n    /* Check if the DAQ List is available */\n    ok = (xcpDynamicDaqLists.daq != NULL) && (frame->daqListId < xcpDynamicDaqLists.daqCount);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE, (\"SET_DAQ_LIST_MODE: DAQ list %d not available\\n\", frame->daqListId));\n\n    daqList = &(xcpDynamicDaqLists.daq[frame->daqListId]);\n\n    /* Check if the DAQ list is currently active */\n    ok = !isActiveDaqList((uint16_T)frame->daqListId);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_DAQ_ACTIVE, (\"SET_DAQ_LIST_MODE: DAQ list %d is currently active\\n\", frame->daqListId));\n\n    /* Check if the Event Id is valid */\n    ok = (frame->eventId < XCP_MAX_EVENT_CHANNEL);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE, (\"SET_DAQ_LIST_MODE: invalid event channel Id %d\\n\", frame->eventId));\n\n    /* Check DAQ list priority */\n    ok = (frame->priority == 0);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE, (\"SET_DAQ_LIST_MODE: priority not supported, must be zero\\n\"));\n\n    /* Check if DAQ list mode is supported */\n    ok = isSupportedDaqListMode((uint8_T)frame->mode);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_MODE_NOT_VALID, (\"SET_DAQ_LIST_MODE: DAQ list mode not supported %xH\\n\", frame->mode));\n\n    /* Everything is fine -> proceed and set the DAQ list mode */\n    XCP_PRINTF(\"SET_DAQ_LIST_MODE: setting DAQ list %d: mode = %xH, eventId = %d, prescaler = %d, priority = %d\\n\",\n        frame->daqListId, frame->mode, frame->eventId, frame->prescaler, frame->priority);\n\n    daqList->mode       = (uint8_T)frame->mode;\n    daqList->eventId    = (uint16_T)frame->eventId;\n    daqList->prescaler  = (uint8_T)frame->prescaler;\n    daqList->priority   = (uint8_T)frame->priority;\n\n    /* Assuming that prescaler = 0 means value that you are not interested in using it */\n    if (daqList->prescaler <= 1)\n        daqList->prescaler = 1;\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP START STOP DAQ LIST\n******************************************************************************/\nstatic XcpProtoErrorCode startStopDaqListInputPacketHandler(void   *msgBuffer,\n                                                            size_t  xcpPacketOffset,\n                                                            size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpStartStopDaqListCmdPacketFrame *frame = (XcpStartStopDaqListCmdPacketFrame *)packet;\n    XcpDaq *daqList = NULL;\n    int32_T daqListId = frame->daqListId;\n    boolean_T ok = false;\n    boolean_T locked = false;\n\n    /* Check if the DAQ List is available */\n    ok = (xcpDynamicDaqLists.daq != NULL) && (daqListId < xcpDynamicDaqLists.daqCount);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"START_STOP_DAQ_LIST: DAQ list %d not available\\n\", daqListId));\n\n    startStopDaqListId = daqListId;\n    daqList = &(xcpDynamicDaqLists.daq[daqListId]);\n\n    /* Check if requested mode is valid */\n    ok = isValidStartStopMode((uint8_T)frame->mode);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_MODE_NOT_VALID,\n        (\"START_STOP_DAQ_LIST: invalid mode %d selected \\n\", frame->mode));\n\n    /* Assign the Absolute ODT number */\n    if (absoluteOdtNumberIdentification()) {\n        if (daqList->status == XCP_DAQ_INIT) {\n            /* The DAQ list has never been started/stopped/selected before\n            -> PIDs for the ODTs needs to be reserved */\n            if (XCP_READ_BIT_VALUE(daqList->mode, XCP_DAQ_MODE_DIRECTION_MASK)) {\n                /* STIM */\n                ok = (daqList->odt != NULL) &&\n                       ((xcpDynamicDaqLists.firstAvailableStimPid +\n                        daqList->odtCount) <= XCP_MAX_STIM_ODT_NUMBER);\n\n                if (ok) {\n                    daqList->firstPid = xcpDynamicDaqLists.firstAvailableStimPid;\n                    xcpDynamicDaqLists.firstAvailableStimPid += daqList->odtCount;\n                }\n            }\n            else {\n                /* DAQ */\n                ok = (daqList->odt != NULL) &&\n                       ((xcpDynamicDaqLists.firstAvailableDaqPid +\n                        daqList->odtCount) <= XCP_MAX_DAQ_ODT_NUMBER);\n\n                if (ok) {\n                    daqList->firstPid = xcpDynamicDaqLists.firstAvailableDaqPid;\n                    xcpDynamicDaqLists.firstAvailableDaqPid += daqList->odtCount;\n                }\n            }\n\n            XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_DAQ_CONFIG_ERROR,\n                (\"START_STOP_DAQ_LIST: cannot assign PIDs for DAQ list %d \\n\", daqListId));\n        }\n    }\n\n    /* Check the ODT configuration and also if the ODT sizes fits the Max DTO size */\n    if ((frame->mode == XCP_DAQ_LIST_START) || (frame->mode == XCP_DAQ_LIST_SELECT)) {\n        int i = 0;\n\n        ok = true;\n        for (i = 0; (i < daqList->odtCount) && ok; i++) {\n            int j = 0;\n            size_t odtSize = 0;\n\n            /* Calculate the resulting ODT size */\n            for (j = 0; j < daqList->odt[i].entriesCount; j++) {\n                odtSize += daqList->odt[i].entry[j].size;\n            }\n\n            /* Check that the resulting ODT size is valid */\n            if (IS_TIMESTAMP_REQUIRED(daqList->mode, i)){\n                ok = (XCP_IN_BYTES(odtSize * daqList->sampleCount + XCP_IN_AG(XCP_ID_FIELD_SIZE)) + XCP_TIMESTAMP_SIZE) <= xcpTransportMaxDtoSize();\n            }\n            else{\n                ok = (XCP_IN_BYTES(odtSize * daqList->sampleCount + XCP_IN_AG(XCP_ID_FIELD_SIZE))) <= xcpTransportMaxDtoSize();\n            }\n            XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_DAQ_CONFIG_ERROR,\n                (\"START_STOP_DAQ_LIST: in DAQ list %d the ODT entries size is larger than Max DTO size for ODT %d \\n\", daqListId, i));\n\n            /* Update the ODT size */\n            daqList->odt[i].size = odtSize;\n        }\n    }\n\n    /* Everything is fine -> proceed and change the DAQ list status */\n    locked = xcpDaqWriteLock(daqList->eventId);\n\n    if (locked) {\n        XcpErrorCode createPoolError = XCP_SUCCESS;\n\n        switch (frame->mode) {\n        case XCP_DAQ_LIST_STOP:\n            XCP_PRINTF(\"START_STOP_DAQ_LIST: stopping DAQ list %d\\n\", daqListId);\n            daqList->status = XCP_DAQ_STOPPED;\n            if (noActiveDaqLists()) {\n                /* update status if this was the only active DAQ list */\n                xcpStatusSet(XCP_CONNECTED);\n                xcpSessionStatusClearMask(XCP_SESSION_DAQ_RUNNING_MASK);\n            }\n            break;\n\n        case XCP_DAQ_LIST_START:\n            XCP_PRINTF(\"START_STOP_DAQ_LIST: starting DAQ list %d\\n\", daqListId);\n\n            /* daqList->poolId is initialized with XCP_INVALID_POOL_ID in\n               allocDaqInputPacketHandler.\n\n               Allocate a reserved memory pool for the DAQ list, if needed. */\n            if (daqList->poolId == XCP_INVALID_POOL_ID) {\n                if (IS_USING_CUSTOM_POOL(daqList->eventId)) {\n                    /* Forward custom memory information to the memory manager */\n                    createPoolError = xcpMemCustomPoolCreate(\n                                          xcpEventCustomMemoryManager.allocHandler, \n                                          xcpEventCustomMemoryManager.freeHandler,\n                                          &daqList->poolId);\n                } else if (daqListId < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER) {\n                    /* Create a reserved memory pool, if not already created */\n                    createPoolError = createDaqReservedPool(daqList);\n                    daqList->currentSample = 0;\n                }\n            }\n\n            if (createPoolError == XCP_SUCCESS) {\n                daqList->status = XCP_DAQ_STARTED;\n                xcpStatusSet(XCP_SYNC_DATA_TRANSFER);\n                xcpSessionStatusSetMask(XCP_SESSION_DAQ_RUNNING_MASK);\n            }\n            break;\n\n        case XCP_DAQ_LIST_SELECT:\n            XCP_PRINTF(\"START_STOP_DAQ_LIST: selected DAQ list %d\\n\", frame->daqListId);\n            daqList->status = XCP_DAQ_SELECTED;\n            break;\n        }\n\n        xcpDaqWriteUnlock(daqList->eventId);\n\n        *outputPacketSize = XCP_START_STOP_DAQ_LIST_RES_PACKET_SIZE_IN_BYTES;\n        XCP_INPUT_PKT_ERROR_IF(createPoolError != XCP_SUCCESS, XCP_PROTO_MEMORY_OVERFLOW,\n                (\"START_STOP_DAQ_LIST: cannot allocate reserved memory pool for the DAQ list\\n\"));\n    }\n\n    /* Error if the command cannot be executed as the processing of\n       at least one event was in progress */\n    XCP_INPUT_PKT_ERROR_IF(!locked, XCP_PROTO_BUSY,\n        (\"START_STOP_DAQ_LIST: cannot be carried out as an event was processed\\n\"));\n\n    return protoErrorCode;\n}\n\nstatic void startStopDaqListOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize)\n{\n    if (inputCode == XCP_PROTO_SUCCESS) {\n        XcpStartStopDaqListResPacketFrame *frame = (XcpStartStopDaqListResPacketFrame *)packet;\n\n        /* Fill the response */\n        frame->PID      = XCP_PID_RES;\n        frame->firstPid = xcpDynamicDaqLists.daq[startStopDaqListId].firstPid;\n    }\n    else {\n        genericOutputPacketHandler(inputCode, packet, packetSize);\n    }\n}\n\n/*****************************************************************************\n    XCP START STOP SYNCH\n******************************************************************************/\nstatic XcpProtoErrorCode startStopSynchInputPacketHandler(void   *msgBuffer,\n                                                          size_t  xcpPacketOffset,\n                                                          size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpStartStopSynchCmdPacketFrame *frame = (XcpStartStopSynchCmdPacketFrame *)packet;\n    boolean_T ok = false;\n    boolean_T locked = false;\n    int32_T i = 0;\n\n    /* Check if requested mode is valid */\n    ok = isValidStartStopSynchMode((uint8_T)frame->mode);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_MODE_NOT_VALID,\n        (\"START_STOP_SYNCH: invalid mode %d selected \\n\", frame->mode));\n\n    /* Check if the DAQ Lists are available */\n    ok = (xcpDynamicDaqLists.daq != NULL) && (xcpDynamicDaqLists.daqCount > 0);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"START_STOP_SYNCH: DAQ lists not available\\n\"));\n\n    /* Everything is fine -> proceed and try to change the DAQ list status */\n\n    /* Need to get the lock to guarantee that they are all done in the same cycle */\n    locked = xcpDaqLock();\n\n    if (locked) {\n        XcpErrorCode createPoolError = XCP_SUCCESS;\n        uint16_T daqListId = 0;\n\n        switch (frame->mode) {\n        case XCP_DAQ_LIST_STOP_ALL:\n            for (i = 0; i < xcpDynamicDaqLists.daqCount; i++) {\n                if (xcpDynamicDaqLists.daq[i].status != XCP_DAQ_INIT) {\n                    XCP_PRINTF(\"START_STOP_SYNCH: stopping DAQ list %d\\n\", i);\n                    xcpDynamicDaqLists.daq[i].status = XCP_DAQ_STOPPED;\n                }\n            }\n\n            /* update status as there are no more active DAQ list */\n            xcpStatusSet(XCP_CONNECTED);\n            xcpSessionStatusClearMask(XCP_SESSION_DAQ_RUNNING_MASK);\n            break;\n\n        case XCP_DAQ_LIST_START_SELECTED:\n            /* xcpDynamicDaqLists.daq[i].poolId is initialized with\n               XCP_INVALID_POOL_ID in allocDaqInputPacketHandler.\n\n               Allocate a reserved memory pool for the DAQ list, if needed. */\n            for (i = 0; (i < xcpDynamicDaqLists.daqCount) && (createPoolError == XCP_SUCCESS); i++) {\n                if ((xcpDynamicDaqLists.daq[i].status == XCP_DAQ_SELECTED) && \n                    (xcpDynamicDaqLists.daq[i].poolId == XCP_INVALID_POOL_ID)) {\n                    if (IS_USING_CUSTOM_POOL(xcpDynamicDaqLists.daq[i].eventId)) {\n                        /* Allocate custom pool if custom memory functions are\n                           provided for this eventId */\n                        createPoolError = xcpMemCustomPoolCreate(\n                                              xcpEventCustomMemoryManager.allocHandler,\n                                              xcpEventCustomMemoryManager.freeHandler,\n                                              &xcpDynamicDaqLists.daq[i].poolId);\n                    } else if (i < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER) {\n                        /* Create a reserved memory pool, if not already created */\n                        createPoolError = createDaqReservedPool(&xcpDynamicDaqLists.daq[i]);\n                        xcpDynamicDaqLists.daq[i].currentSample = 0;\n                        daqListId = (uint16_T) i;\n                    }\n                }\n            }\n\n            if (createPoolError == XCP_SUCCESS) {\n                /* If the allocation went well for all the DAQ lists, start them */\n                for (i = 0; (i < xcpDynamicDaqLists.daqCount); i++) {\n                    if (xcpDynamicDaqLists.daq[i].status == XCP_DAQ_SELECTED) {\n                        XCP_PRINTF(\"START_STOP_SYNCH: starting DAQ list %d\\n\", i);\n\n                        xcpDynamicDaqLists.daq[i].status = XCP_DAQ_STARTED;\n                        xcpStatusSet(XCP_SYNC_DATA_TRANSFER);\n                        xcpSessionStatusSetMask(XCP_SESSION_DAQ_RUNNING_MASK);\n                    }\n                }\n            }\n            break;\n\n        case XCP_DAQ_LIST_STOP_SELECTED:\n            for (i = 0; i < xcpDynamicDaqLists.daqCount; i++) {\n                if (xcpDynamicDaqLists.daq[i].status == XCP_DAQ_SELECTED) {\n                    XCP_PRINTF(\"START_STOP_SYNCH: stopping DAQ list %d\\n\", i);\n                    xcpDynamicDaqLists.daq[i].status = XCP_DAQ_STOPPED;\n                }\n            }\n\n            if (noActiveDaqLists()) {\n                /* update status if this was the only active DAQ list */\n                xcpStatusSet(XCP_CONNECTED);\n                xcpSessionStatusClearMask(XCP_SESSION_DAQ_RUNNING_MASK);\n            }\n            break;\n        }\n\n        /* Unlock all the events */\n        xcpDaqUnlock();\n\n        (void)daqListId; /* to suppress unused-but-set-variable when XCP_PRINTF is empty */\n        XCP_INPUT_PKT_ERROR_IF(createPoolError != XCP_SUCCESS, XCP_PROTO_MEMORY_OVERFLOW,\n                (\"START_STOP_SYNCH: cannot allocate reserved memory pool for the DAQ list %d\\n\", daqListId));\n\n        *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n    }\n\n    /* Error if the command cannot be executed as the processing of\n       at least one event was in progress */\n    XCP_INPUT_PKT_ERROR_IF(!locked, XCP_PROTO_BUSY,\n        (\"START_STOP_SYNCH: cannot be carried out as an event was processed\\n\"));\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP GET DAQ PROCESSOR INFO\n******************************************************************************/\nstatic XcpProtoErrorCode getDaqProcessorInfoInputPacketHandler(void   *msgBuffer,\n                                                               size_t  xcpPacketOffset,\n                                                               size_t *outputPacketSize)\n{\n    XCP_UNUSED_PARAM(msgBuffer);\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    XCP_PRINTF(\"GET DAQ PROCESSOR INFO\\n\");\n\n    *outputPacketSize =  XCP_GET_DAQ_PROCESSOR_INFO_RES_PACKET_SIZE_IN_BYTES;\n\n    return XCP_PROTO_SUCCESS;\n}\n\nstatic void getDaqProcessorInfoOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize)\n{\n    XcpGetDaqProcessorInfoResPacketFrame *frame = (XcpGetDaqProcessorInfoResPacketFrame *)packet;\n\n    XCP_UNUSED_PARAM(inputCode);\n    XCP_UNUSED_PARAM(packetSize);\n\n    /* Fill Get Daq Processor Info response */\n    XCP_MEMSET(frame, 0, sizeof(*frame));\n\n    frame->PID = XCP_PID_RES;\n    frame->daqProperties = XCP_DAQ_PROPERTIES_VALUE;\n    frame->maxDaq = XCP_MAX_DAQ;\n    frame->maxEventChannel = XCP_MAX_EVENT_CHANNEL;\n    frame->minDaq = XCP_MIN_DAQ;\n    frame->daqKeyByte = XCP_DAQ_KEY_VALUE;\n\n    XCP_PRINTF(\"* DAQ Properties:    %xH\\n\", frame->daqProperties);\n    XCP_PRINTF(\"* MAX_DAQ:           %d\\n\", frame->maxDaq);\n    XCP_PRINTF(\"* MAX_EVENT_CHANNEL: %d\\n\", frame->maxEventChannel);\n    XCP_PRINTF(\"* MIN_DAQ:           %d\\n\", frame->minDaq);\n    XCP_PRINTF(\"* Daq Key Byte:      %xH\\n\", frame->daqKeyByte);\n}\n\n/*****************************************************************************\n    XCP GET DAQ RESOLUTION INFO\n******************************************************************************/\nstatic XcpProtoErrorCode getDaqResolutionInfoInputPacketHandler(void   *msgBuffer,\n    size_t  xcpPacketOffset,\n    size_t *outputPacketSize)\n{\n    XCP_UNUSED_PARAM(msgBuffer);\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    XCP_PRINTF(\"GET DAQ RESOLUTION INFO\\n\");\n\n    *outputPacketSize = XCP_GET_DAQ_RESOLUTION_INFO_RES_PACKET_SIZE_IN_BYTES;\n\n    return XCP_PROTO_SUCCESS;\n}\n\nstatic void getDaqResolutionInfoOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize)\n{\n    XcpGetDaqResolutionInfoResPacketFrame *frame = (XcpGetDaqResolutionInfoResPacketFrame *)packet;\n\n    XCP_UNUSED_PARAM(inputCode);\n    XCP_UNUSED_PARAM(packetSize);\n\n    /* Fill Get Daq Resolution Info response */\n    XCP_MEMSET(frame, 0, sizeof(*frame));\n\n    frame->PID = XCP_PID_RES;\n\n    /* @note in the current version the same limits apply for DAQ and STIM */\n    frame->daqOdtEntrySizeGranularity = XCP_ODT_ENTRY_SIZE_GRANULARITY;\n    frame->maxDaqOdtEntrySize = XCP_MAX_ODT_ENTRY_SIZE;\n    frame->stimOdtEntrySizeGranularity = XCP_ODT_ENTRY_SIZE_GRANULARITY;\n    frame->maxStimOdtEntrySize = XCP_MAX_ODT_ENTRY_SIZE;\n    frame->timestampMode = XCP_TIMESTAMP_MODE_VALUE;\n    frame->timestampTicks = XCP_TIMESTAMP_TICKS;\n\n    XCP_PRINTF(\"* DAQ ODT Entry size granularity:   %d\\n\",  frame->daqOdtEntrySizeGranularity);\n    XCP_PRINTF(\"* Max DAQ ODT Entry size:           %d\\n\",  frame->maxDaqOdtEntrySize);\n    XCP_PRINTF(\"* STIM ODT Entry size granularity:  %d\\n\",  frame->stimOdtEntrySizeGranularity);\n    XCP_PRINTF(\"* Max STIM ODT Entry size:          %d\\n\",  frame->maxStimOdtEntrySize);\n    XCP_PRINTF(\"* Timestamp Mode =                  %xH\\n\", frame->timestampMode);\n    XCP_PRINTF(\"* Timestamp Ticks =                 %d\\n\",  frame->timestampTicks);\n}\n\n/*****************************************************************************\n    XCP FREE_DAQ\n******************************************************************************/\nstatic XcpProtoErrorCode freeDaqInputPacketHandler(void   *msgBuffer,\n                                                   size_t  xcpPacketOffset,\n                                                   size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    boolean_T ok = false;\n\n    XCP_UNUSED_PARAM(msgBuffer);\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    XCP_PRINTF(\"FREE_DAQ: clearing existing dynamic DAQ lists\\n\");\n    ok = xcpResetDaqListStatus();\n\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_BUSY,\n        (\"FREE_DAQ: cannot be carried out as an event was processed\\n\"));\n\n    /* No DAQ lists are running -> XCP_SYNC_DATA_TRANSFER cannot be active anymore */\n    xcpStatusSet(XCP_CONNECTED);\n\n    /* Everything is fine -> send positive response */\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP ALLOC_DAQ\n******************************************************************************/\nstatic XcpProtoErrorCode allocDaqInputPacketHandler(void   *msgBuffer,\n                                                    size_t  xcpPacketOffset,\n                                                    size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpAllocDaqCmdPacketFrame *frame = (XcpAllocDaqCmdPacketFrame *) packet;\n    int32_T daqCount = (uint16_T)frame->daqCount;\n    XcpDaq *daq = NULL;\n    boolean_T ok = false;\n    int i = 0;\n\n    /* Check if DAQ lists have already been allocated */\n    ok = xcpDynamicDaqLists.daq == NULL;\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_SEQUENCE_ERROR,\n        (\"ALLOC_DAQ: sequence error detected, DAQ lists already allocated\\n\"));\n\n    /* Check if the number of DAQ lists requested is supported */\n    ok = (daqCount > 0) && (daqCount <= (XCP_MAX_DAQ - XCP_MIN_DAQ));\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"ALLOC_DAQ: invalid number of DAQ lists (%d)\\n\", daqCount));\n\n    /* Proceed and allocate the DAQ lists */\n    daq = (XcpDaq *)xcpMemAlloc((size_t) daqCount * sizeof(XcpDaq));\n    XCP_INPUT_PKT_ERROR_IF(daq == NULL, XCP_PROTO_MEMORY_OVERFLOW,\n        (\"ALLOC_DAQ: not enough memory to allocate %d DAQ lists\\n\", daqCount));\n\n    XCP_PRINTF(\"ALLOC_DAQ: allocating %d DAQ lists\\n\", daqCount);\n    XCP_MEMSET(daq, 0, (size_t)daqCount * sizeof(XcpDaq));\n\n    /* Make sure that the DAQ lists are available for use */\n    xcpDynamicDaqLists.daq = daq;\n    xcpDynamicDaqLists.daqCount = (uint16_T) daqCount;\n\n    for (i = 0; i < daqCount; i++) {\n        daq[i].poolId        = XCP_INVALID_POOL_ID;\n        daq[i].packedMode    = XCP_DAQ_DATA_NOT_PACKED;\n        daq[i].timestampMode = XCP_DAQ_SINGLE_TIMESTAMP_FIRST_SAMPLE;\n        daq[i].sampleCount   = 1;\n        daq[i].currentSample = 0;\n    }\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP ALLOC_ODT\n******************************************************************************/\nstatic XcpProtoErrorCode allocOdtInputPacketHandler(void   *msgBuffer,\n                                                    size_t  xcpPacketOffset,\n                                                    size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpAllocOdtCmdPacketFrame *frame = (XcpAllocOdtCmdPacketFrame *)packet;\n    uint16_T daqListId = (uint16_T)frame->daqListId;\n    uint8_T  odtCount  = (uint8_T)frame->odtCount;\n    boolean_T ok = false;\n\n    /* Check if DAQ lists have already been allocated */\n    ok = (xcpDynamicDaqLists.daq != NULL);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_SEQUENCE_ERROR,\n        (\"ALLOC_ODT: sequence error detected, DAQ lists not allocated\\n\"));\n\n    /* Check if the DAQ List Id is valid */\n    ok = (daqListId < xcpDynamicDaqLists.daqCount);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"ALLOC_ODT: DAQ list id %d is out of range\\n\", daqListId));\n\n    /* Check if the number of ODTs is valid */\n    ok = (odtCount > 0) && (odtCount <= XCP_MAX_DAQ_ODT_NUMBER);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"ALLOC_ODT: invalid number of ODT (%d) for DAQ list id %d\\n\", odtCount, daqListId));\n\n    /* Check if the ODTs have already been allocated */\n    ok = (xcpDynamicDaqLists.daq[daqListId].odt == NULL);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_SEQUENCE_ERROR,\n        (\"ALLOC_ODT: sequence error detected, ODT already allocated\\n\"));\n\n    /* Everything is fine -> proceed and allocate the ODTs */\n    xcpDynamicDaqLists.daq[daqListId].odt = (XcpOdt *)xcpMemAlloc(odtCount * sizeof(XcpOdt));\n    XCP_INPUT_PKT_ERROR_IF(xcpDynamicDaqLists.daq[daqListId].odt == NULL, XCP_PROTO_MEMORY_OVERFLOW,\n        (\"ALLOC_ODT: not enough memory to allocate %d ODT in DAQ list %d\\n\", odtCount, daqListId));\n\n    XCP_PRINTF(\"ALLOC_ODT: allocating %d ODTs in DAQ list %d\\n\", odtCount, daqListId);\n    XCP_MEMSET(xcpDynamicDaqLists.daq[daqListId].odt, 0, odtCount * sizeof(XcpOdt));\n\n    xcpDynamicDaqLists.daq[daqListId].odtCount = odtCount;\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP ALLOC_ODT_ENTRY\n******************************************************************************/\nstatic XcpProtoErrorCode allocOdtEntryInputPacketHandler(void   *msgBuffer,\n    size_t  xcpPacketOffset,\n    size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpAllocOdtEntryCmdPacketFrame *frame = (XcpAllocOdtEntryCmdPacketFrame *)packet;\n    uint16_T daqListId       = (uint16_T)frame->daqListId;\n    uint8_T  odtId           = (uint8_T)frame->odtId;\n    uint8_T  odtEntriesCount = (uint8_T)frame->odtEntriesCount;\n    boolean_T ok = false;\n\n    /* Check if the DAQ lists have already been allocated */\n    ok = (xcpDynamicDaqLists.daq != NULL);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_SEQUENCE_ERROR,\n        (\"ALLOC_ODT_ENTRY: sequence error detected, DAQ lists not allocated\\n\"));\n\n    /* Check if the DAQ List Id is valid */\n    ok = (daqListId < xcpDynamicDaqLists.daqCount);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"ALLOC_ODT_ENTRY: DAQ list id %d is out of range\\n\", daqListId));\n\n    /* Check if the ODTs have already been allocated */\n    ok = (xcpDynamicDaqLists.daq[daqListId].odt != NULL);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_SEQUENCE_ERROR,\n        (\"ALLOC_ODT_ENTRY: sequence error detected, ODTs not allocated\\n\"));\n\n    /* Check if the ODT Id is valid */\n    ok = (odtId < xcpDynamicDaqLists.daq[daqListId].odtCount);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"ALLOC_ODT_ENTRY: ODT id %d is out of range\\n\", odtId));\n\n    /* Check if the ODT entries have already been allocated */\n    ok = (xcpDynamicDaqLists.daq[daqListId].odt[odtId].entry == NULL);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_SEQUENCE_ERROR,\n        (\"ALLOC_ODT_ENTRY: sequence error detected, ODT Entries already allocated\\n\"));\n\n    /* Check if the number of ODT Entries is valid */\n    ok = (odtEntriesCount > 0);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"ALLOC_ODT_ENTRY: invalid number of ODT entries (%d) for ODT %d in DAQ list %d\\n\", odtEntriesCount, odtId, daqListId));\n\n    /* Everything is fine -> proceed and allocate the ODT entries */\n    xcpDynamicDaqLists.daq[daqListId].odt[odtId].entry = (XcpOdtEntry *)xcpMemAlloc(odtEntriesCount * sizeof(XcpOdtEntry));\n\n    XCP_INPUT_PKT_ERROR_IF(xcpDynamicDaqLists.daq[daqListId].odt[odtId].entry == NULL, XCP_PROTO_MEMORY_OVERFLOW,\n        (\"ALLOC_ODT_ENTRY: not enough memory to allocate %d ODT in DAQ list %d ODT %d\\n\", odtEntriesCount, daqListId, odtId));\n\n    XCP_PRINTF(\"ALLOC_ODT_ENTRY: allocating %d ODT Entries in DAQ list %d ODT %d\\n\", odtEntriesCount, daqListId, odtId);\n    XCP_MEMSET(xcpDynamicDaqLists.daq[daqListId].odt[odtId].entry, 0, odtEntriesCount * sizeof(XcpOdtEntry));\n\n    xcpDynamicDaqLists.daq[daqListId].odt[odtId].entriesCount = odtEntriesCount;\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP LEVEL1 COMMAND\n******************************************************************************/\n\n/* The only supported Level 1 command is SET DAQ PACKED MODE */\nstatic XcpProtoErrorCode setDaqPackedModeInputPacketHandler(void   *msgBuffer,\n                                                            size_t  xcpPacketOffset,\n                                                            size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpSetDaqPackedModeCmdPacketFrame *frame = (XcpSetDaqPackedModeCmdPacketFrame *)packet;\n    uint16_T daqListId        = (uint16_T) frame->daqListId;\n    uint8_T  daqPackedMode    = (uint8_T)  frame->daqPackedMode;\n    uint8_T  dpmTimestampMode = (uint8_T)  frame->dpmTimestampMode;\n    uint16_T dpmSampleCount   = (uint16_T) frame->dpmSampleCount;\n    boolean_T ok = true;\n\n    /* Check if the DAQ lists have already been allocated */\n    ok = (xcpDynamicDaqLists.daq != NULL);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_SEQUENCE_ERROR,\n        (\"SET_DAQ_PACKED_MODE: sequence error detected, DAQ lists not allocated\\n\"));\n\n    /* Check if the DAQ List Id is valid */\n    ok = (daqListId < xcpDynamicDaqLists.daqCount);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"SET_DAQ_PACKED_MODE: DAQ list id %d is out of range\\n\", daqListId));\n\n#if XCP_MEM_DAQ_RESERVED_POOLS_NUMBER > 0\n    /* DAQ Packed Mode is only supported for DAQ lists with a reserved memory pool */\n    ok = (daqListId < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_MODE_NOT_VALID,\n        (\"SET_DAQ_PACKED_MODE: packed mode is not supported for DAQ list id %d, with no reserved memory pool\\n\", daqListId));\n#else\n    ok = false;\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_MODE_NOT_VALID,\n        (\"SET_DAQ_PACKED_MODE: packed mode is not supported for DAQ list id %d, with no reserved memory pool\\n\", daqListId));\n#endif\n\n    /* Check if the selected DAQ packed mode is valid. \n       Currently we only support event-grouped data packing */\n    ok = ((daqPackedMode == XCP_DAQ_DATA_NOT_PACKED) || \n          (daqPackedMode == XCP_DAQ_EVENT_GROUPED_PACKING));\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_MODE_NOT_VALID,\n        (\"SET_DAQ_PACKED_MODE: DAQ Packed mode %d is not supported\\n\", daqPackedMode));\n\n    /* Check if the selected DAQ Timestamp mode is valid. \n       Currently we only support single timestamp of the first sample */\n    ok = (dpmTimestampMode == XCP_DAQ_SINGLE_TIMESTAMP_FIRST_SAMPLE);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_MODE_NOT_VALID,\n        (\"SET_DAQ_PACKED_MODE: DAQ Packed timestamp mode %d is not supported\\n\", dpmTimestampMode));\n\n    /* Check if the selected DAQ Packed sample count is valid. */\n    ok = ((daqPackedMode == XCP_DAQ_DATA_NOT_PACKED && (dpmSampleCount == 1)) ||\n         ((daqPackedMode != XCP_DAQ_DATA_NOT_PACKED) && (dpmSampleCount >= XCP_DAQ_PACKED_SAMPLE_COUNT_MIN)));\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_MODE_NOT_VALID,\n        (\"SET_DAQ_PACKED_MODE: DAQ Packed sample count %d is not supported.\\n\", dpmSampleCount));\n\n    /* Check that the DAQ list is not already running */\n    ok = !isActiveDaqList(daqListId);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_DAQ_ACTIVE,\n        (\"SET_DAQ_PACKED_MODE: packed mode configuration cannot be changed if the DAQ is running.\\n\"));\n\n    /* Finally: select the new configuration */\n    XCP_PRINTF(\"SET_DAQ_PACKED_MODE: setting packed mode %d timestamp mode %d sample count %d\\n\", \n               daqPackedMode, dpmTimestampMode, dpmSampleCount);\n\n    xcpDynamicDaqLists.daq[daqListId].packedMode    = daqPackedMode;\n    xcpDynamicDaqLists.daq[daqListId].timestampMode = dpmTimestampMode;\n    xcpDynamicDaqLists.daq[daqListId].sampleCount   = dpmSampleCount;\n    xcpDynamicDaqLists.daq[daqListId].currentSample = 0;\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\nstatic XcpProtoErrorCode level1CommandInputPacketHandler(void  *msgBuffer,\n                                                        size_t  xcpPacketOffset,\n                                                        size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    XcpLevel1CommandPacketFrame* command = (XcpLevel1CommandPacketFrame*) ((uint8_T *)msgBuffer + xcpPacketOffset);\n    boolean_T ok = (command->level1Code == XCP_DAQ_LEVEL1_CODE_SET_DAQ_PACKED_MODE);\n\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_CMD_UNKNOWN,\n        (\"DAQ LEVEL1 COMMAND: command code %d is not supported\\n\", command->level1Code));\n\n    /* The only supported Level 1 command is SET_DAQ_PACKED_MODE */\n    protoErrorCode = setDaqPackedModeInputPacketHandler(msgBuffer, xcpPacketOffset, outputPacketSize);\n\n    return protoErrorCode;\n}\n\n\n/** This table contains the list of supported Rx packets and the corresponding handlers */\nstatic const XcpPacketHandlers daqSupportedRxPacket[] =\n{\n    { XCP_PID_START_STOP_DAQ_LIST,     startStopDaqListInputPacketHandler,     startStopDaqListOutputPacketHandler },\n    { XCP_PID_START_STOP_SYNCH,        startStopSynchInputPacketHandler,       genericOutputPacketHandler },\n    { XCP_PID_GET_DAQ_PROCESSOR_INFO,  getDaqProcessorInfoInputPacketHandler,  getDaqProcessorInfoOutputPacketHandler},\n    { XCP_PID_GET_DAQ_RESOLUTION_INFO, getDaqResolutionInfoInputPacketHandler, getDaqResolutionInfoOutputPacketHandler },\n    { XCP_PID_SET_DAQ_PTR,             setDaqPtrInputPacketHandler,            genericOutputPacketHandler },\n    { XCP_PID_WRITE_DAQ,               writeDaqInputPacketHandler,             genericOutputPacketHandler },\n    { XCP_PID_SET_DAQ_LIST_MODE,       setDaqListModeInputPacketHandler,       genericOutputPacketHandler },\n    { XCP_PID_FREE_DAQ,                freeDaqInputPacketHandler,              genericOutputPacketHandler },\n    { XCP_PID_ALLOC_DAQ,               allocDaqInputPacketHandler,             genericOutputPacketHandler },\n    { XCP_PID_ALLOC_ODT,               allocOdtInputPacketHandler,             genericOutputPacketHandler },\n    { XCP_PID_ALLOC_ODT_ENTRY,         allocOdtEntryInputPacketHandler,        genericOutputPacketHandler },\n    { XCP_PID_LEVEL1_COMMAND,          level1CommandInputPacketHandler,        genericOutputPacketHandler }\n};\n\n\n\n/*****************************************************************************\n    XCP Packet Lookup Function for basic DAQ commands\n******************************************************************************/\n\n/* Default DAQ Packet Lookup function, supporting only basic commands\n   listed in the table above */\nstatic const XcpPacketHandlers* getPacket(XcpRxPidCode pid)\n{\n    return xcpFindPacket(pid, daqSupportedRxPacket,\n                         XCP_ELEMENTS_NUMBER(daqSupportedRxPacket));\n}\n\nstatic XcpPacketLookupFunction packetLookup = NULL;\n\n\n\n/*****************************************************************************\n    Public Functions (invoked within the Protocol Layer)\n******************************************************************************/\nvoid xcpDaqInit(void)\n{\n#if !defined(XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK) || (XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK == 0)\n    XCP_MUTEX_INIT(daqLock);\n#else\n    uint16_T i = 0;\n\n    /* Initialize Event locks */\n    for (i = 0; i < XCP_MAX_EVENT_DATA_NUMBER; i++) {\n        XCP_MUTEX_INIT(xcpEventData[i].lock);\n    }\n#endif\n\n    xcpRunningEventCounter = 0;\n    XCP_MEMSET(&xcpDynamicDaqLists, 0, sizeof(xcpDynamicDaqLists));\n\n    /* Initialize the packet lookup function to support only basic\n       DAQ commands */\n    xcpDaqSetPacketLookup(getPacket);\n\n    /* Initialize support for the extended list of DAQ commands\n       @note this may override the default Packet lookup function\n             by adding support for more (optional) commands */\n    xcpDaqExtendedInit();\n}\n\n\nXcpPacketLookupFunction xcpDaqGetPacketLookup(void)\n{\n    return packetLookup;\n}\n\n\nvoid xcpDaqSetPacketLookup(XcpPacketLookupFunction getPacket)\n{\n    packetLookup = getPacket;\n}\n\n\nXcpErrorCode xcpDaqEvent(XcpEventIdType eventId, uint32_T timestamp, boolean_T resetSamples)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    boolean_T error = false;\n\n    /* The lock is used to protect against the concurrent execution of XCP commands\n    (within xcpRun()) that can modify the DAQ list data structures */\n    xcpDaqReadLock(eventId);\n\n    if ((xcpDynamicDaqLists.daq != NULL) && (xcpDynamicDaqLists.daqCount > 0)) {\n        uint16_T i = 0;\n        XcpDaq *daq = xcpDynamicDaqLists.daq;\n\n        for (i = 0; (i < xcpDynamicDaqLists.daqCount) && !error; i++) {\n            boolean_T txReady = xcpTransportTxReady(XCP_TRANSPORT_TX_DEFAULT_QUEUE, i);\n            XcpTransportQueueType_T txQueue = txReady ? XCP_TRANSPORT_TX_DEFAULT_QUEUE :\n                                                        XCP_TRANSPORT_DEFERRED_TX_QUEUE;\n\n            if (!XCP_READ_BIT_VALUE(daq[i].mode, XCP_DAQ_MODE_DIRECTION_MASK) && /* it's a DAQ list */\n                (daq[i].status == XCP_DAQ_STARTED) &&                            /* it's running */\n                (daq[i].eventId == eventId)) {                                   /* and associated to this event */\n                int j = 0;\n                boolean_T daqPackedModeEnabled = isDaqPackedModeEnabled(i);\n                /* In packed Mode we only want to transmit when the expected number of \n                   samples has been reached */\n                boolean_T transmitRequest = !daqPackedModeEnabled ||\n                                            ((daq[i].currentSample + 1) == daq[i].sampleCount);\n\n            #ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n                if (txReady &&\n                   (daq[i].poolId != XCP_INVALID_POOL_ID)) {\n                    /* If the Tx queue is ready, it is safe to flush the free memory,\n                       so that the deferred free blocks become available for subsequent allocations */\n                    xcpMemReservedPoolFlushFreeMem(daq[i].poolId);\n                }\n            #endif\n\n                /* @note prescaler is not supported at the moment -> we send DTOs every time */                        \n                for (j = 0; (j < daq[i].odtCount) && !error; j++) {\n                    uint8_T *packet = NULL;\n                    size_t packetOffset = xcpTransportPacketOffset();\n                    size_t msgBufferSize = 0;\n                #ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n                    /* timestamp is always aligned to WORD boundary. Hence, srcOffsetBytes = 0. */\n                    uint8_T srcOffsetBytes = 0;\n                    uint8_T dstOffsetBytes = (XCP_IN_AG(XCP_ID_FIELD_SIZE)) % XCP_HARDWARE_ADDRESS_GRANULARITY_BYTES_NUMBER;\n                #else\n                    /* Dummy variable used when we are not emulating as BYTE addressable target */\n                    uint8_T dstOffsetBytes = 0;\n                #endif\n\n                    if (resetSamples) {\n                        if(daqPackedModeEnabled && (daq[i].currentSample != 0)) {\n                            /* When the reset of samples has been requested and the acquisition is in progress, \n                               we need to free memory as the pending packet needs to be discarded */\n                            xcpMemFree(daq[i].odt[j].msgBuffer);\n                        }\n                    } else {\n                        /* when packed mode is active the allocation occurs at the first sample */\n                        boolean_T requestNewMessageBuffer = !daqPackedModeEnabled || (daq[i].currentSample == 0);\n                        boolean_T needsTimestamp = IS_TIMESTAMP_REQUIRED(daq[i].mode, j);\n\n                        if (requestNewMessageBuffer) {\n                            /* Calculate the required XCP packet size */\n                            daq[i].odt[j].packetSize = XCP_IN_BYTES(daq[i].odt[j].size * daq[i].sampleCount + XCP_IN_AG(XCP_ID_FIELD_SIZE));\n\n                            if (needsTimestamp) {\n                                /* Adjust it to make sure that the first DTO also contains the Timestamp info */\n                                daq[i].odt[j].packetSize += XCP_TIMESTAMP_SIZE;\n                            }\n\n                            /* Calculate the overall message buffer */\n                            msgBufferSize = xcpTransportMsgBufferSize(daq[i].odt[j].packetSize, XCP_DTO);\n\n                            if (daq[i].poolId != XCP_INVALID_POOL_ID) {\n                                /* A dedicated memory pool is available */\n                                daq[i].odt[j].msgBuffer = (uint8_T *)xcpMemAllocFromPool(daq[i].poolId, msgBufferSize);\n                            } else {\n                                /* No memory pool available, use the Main memory instead */\n                                daq[i].odt[j].msgBuffer = (uint8_T *)xcpMemAlloc(msgBufferSize);\n                            }\n                            \n                            if (daq[i].odt[j].msgBuffer != NULL) {\n                                /* Allocation went well, let's fill the PID and timestamp field if required */\n                                packet = daq[i].odt[j].msgBuffer + packetOffset;\n\n                                /* Fill the Identification Field first\n                                @note this is hard-coded to support absolute ODT number at the moment */\n                                *packet = (uint8_T)(daq[i].firstPid + j);\n                                packet = XCP_HW_PTR_INCREMENT(packet, XCP_IN_AG(XCP_ID_FIELD_SIZE), dstOffsetBytes);\n\n                                /* Add the timestamp for the first DTO\n                                @note this is hard-coded to support timestamp size of 4 bytes */\n                                if (needsTimestamp) {\n                                #ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n                                    xcpMemcpyByte(packet, dstOffsetBytes, &timestamp, srcOffsetBytes, XCP_IN_HW_BYTES(sizeof(timestamp)));\n                                #else\n                                    XCP_MEMCPY(packet, &timestamp, sizeof(timestamp));\n                                #endif\n\n                                    packet = XCP_HW_PTR_INCREMENT(packet, XCP_IN_AG(XCP_TIMESTAMP_SIZE + dstOffsetBytes), dstOffsetBytes);\n                                    dstOffsetBytes = XCP_HW_BYTE_OFFSET_UPDATE(dstOffsetBytes, XCP_IN_AG(XCP_TIMESTAMP_SIZE));\n                                }                            \n                                daq[i].odt[j].currentSamplePtr = packet;\n                            } else {\n                                /* An issue occurred during the memory allocation */\n                                error = true;\n                                errorCode = XCP_NO_MEMORY;\n                            }\n                        }\n                    }\n\n                    if (!resetSamples && !error && (daq[i].odt[j].msgBuffer != NULL)) {\n                        if (!IS_USING_CUSTOM_POOL(eventId)) {\n                            int k = 0;\n\n                            /* Finally copy the ODT entries values \n                               @note this implementation only supports event-grouped data packing */\n                            if (daqPackedModeEnabled) {\n                                packet = daq[i].odt[j].currentSamplePtr;\n                            }\n\n                            for (k = 0; k < daq[i].odt[j].entriesCount; k++) {\n                                XcpOdtEntry *entry = &(daq[i].odt[j].entry[k]);\n                                uint8_T *address = XCP_ADDRESS_GET_INTERNAL(entry->addressExtension, entry->address);\n\n                                if (daq[i].odt[j].entry[k].bitOffset != 0xFF) {\n                                    /* Bitwise access has been selected */\n                                #ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n                                    uint32_T dword;\n                                    uint8_T bitValue;\n                                    srcOffsetBytes = XCP_BYTE_OFFSET_GET(entry->address);\n                                    xcpMemcpyByte(&dword, 0, address, srcOffsetBytes, 4);\n                                    bitValue = (uint8_T) ((dword & ((uint32_T)(1 << entry->bitOffset))) != 0);\n                                    xcpMemcpyByte(packet, dstOffsetBytes, &bitValue, 0, entry->size);\n                                #else\n                                    uint32_T *dword = (uint32_T *)address;\n                                    *packet = (uint8_T) ((*dword & ((uint32_T)(1 << entry->bitOffset))) != 0);\n                                #endif\n                                }\n                                else {\n                                    /* 'Normal' (non-bitwise) access has been selected */\n                                #ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n                                    srcOffsetBytes = XCP_BYTE_OFFSET_GET(entry->address);\n                                    xcpMemcpyByte(packet, dstOffsetBytes, address, srcOffsetBytes, entry->size);\n                                #else\n                                    XCP_MEMCPY(packet, address, entry->size);\n                                #endif\n                                }\n                            \n                                packet = XCP_HW_PTR_INCREMENT(packet, entry->size + dstOffsetBytes, dstOffsetBytes);\n                                dstOffsetBytes = XCP_HW_BYTE_OFFSET_UPDATE(dstOffsetBytes, entry->size);\n                            }\n                            if (daqPackedModeEnabled) {\n                                daq[i].odt[j].currentSamplePtr = packet;\n                            }\n                        }\n                        \n                        if (transmitRequest) {\n                            /* Send the response back to the Transport Layer */\n                            /* Calculate the overall message buffer */\n                            msgBufferSize = xcpTransportMsgBufferSize(daq[i].odt[j].packetSize, XCP_DTO);\n\n                            errorCode = xcpTransportTxPacketSet(txQueue,\n                                                                i,\n                                                                daq[i].odt[j].msgBuffer, msgBufferSize,\n                                                                packetOffset, daq[i].odt[j].packetSize);\n                            if (errorCode != XCP_SUCCESS) {\n                                xcpMemFree(daq[i].odt[j].msgBuffer);\n                            }\n                        }\n                    }\n                }\n\n                if (resetSamples) {\n                    daq[i].currentSample = 0;\n                } else {\n                    daq[i].currentSample++;\n                    if (daq[i].currentSample == daq[i].sampleCount) {\n                        daq[i].currentSample = 0;\n                    }\n                }\n\n                if (txReady) {\n                    /* Trigger the transmission of the packets that have been enqueued\n                       for this DAQ list */\n                    xcpTransportTxTrigger(XCP_TRANSPORT_TX_DEFAULT_QUEUE, i);\n                }\n            }\n        }\n    }\n\n    xcpDaqReadUnlock(eventId);\n\n    return errorCode;\n}\n\nXcpErrorCode xcpDaqEventsFlush(uint32_T timestamp)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    XCP_UNUSED_PARAM(timestamp);\n\n    if (xcpDynamicDaqLists.daq != NULL) {\n        boolean_T locked = xcpDaqLock();\n\n        if (locked) {\n            XcpDaq  *daq = xcpDynamicDaqLists.daq;\n            int32_T  daqCount = xcpDynamicDaqLists.daqCount;\n            uint16_T i = 0;\n\n            for (i = 0; i < daqCount; i++) {\n                boolean_T daqPackedModeEnabled = isDaqPackedModeEnabled(i);\n\n                if (daqPackedModeEnabled &&\n                    (daq[i].status == XCP_DAQ_STARTED) &&\n                    (daq[i].currentSample > 0)) {\n                    \n                    boolean_T txReady = xcpTransportTxReady(XCP_TRANSPORT_TX_DEFAULT_QUEUE, i);\n                    XcpTransportQueueType_T txQueue = txReady ? XCP_TRANSPORT_TX_DEFAULT_QUEUE :\n                                                            XCP_TRANSPORT_DEFERRED_TX_QUEUE;\n                    uint16_T j = 0;\n\n                    for (j = 0; j < daq[i].odtCount; j++) {\n                        if (daq[i].odt[j].msgBuffer != NULL) {\n                            size_t msgBufferSize = xcpTransportMsgBufferSize(daq[i].odt[j].packetSize, XCP_DTO);\n                            size_t packetOffset = xcpTransportPacketOffset();\n                            uint8_T *packet = daq[i].odt[j].msgBuffer + packetOffset;\n                            size_t notInitializedDataSize = XCP_IN_HW_AG(daq[i].odt[j].packetSize) - \n                                                             ((size_t) (daq[i].odt[j].currentSamplePtr - packet));\n\n                            XCP_MEMSET(daq[i].odt[j].currentSamplePtr, 0, notInitializedDataSize);\n\n                            errorCode = xcpTransportTxPacketSet(txQueue,\n                                                                i,\n                                                                daq[i].odt[j].msgBuffer, msgBufferSize,\n                                                                packetOffset, daq[i].odt[j].packetSize);\n                            if (errorCode != XCP_SUCCESS) {\n                                xcpMemFree(daq[i].odt[j].msgBuffer);\n                            }\n\n                        }\n                    }\n\n                    daq[i].currentSample = 0;\n                }\n            }\n\n            xcpDaqUnlock();\n        } else {\n            errorCode = XCP_BUSY;\n        }\n    }\n\n    return errorCode;\n}\n\n\n\nboolean_T xcpDaqLock(void)\n{\n    boolean_T locked = true;\n#if !defined(XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK) || (XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK == 0)\n    locked = xcpDaqWriteLock(0);\n#else\n    XcpEventIdType i = 0;\n\n    for(i = 0; i < XCP_MAX_EVENT_DATA_NUMBER; i++) {\n        xcpDaqWriteLock(i);\n    }\n#endif\n    return locked;\n}\n\n\n/* Unlock DAQ list transmission */\nvoid xcpDaqUnlock(void)\n{\n#if !defined(XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK) || (XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK == 0)\n    xcpDaqWriteUnlock(0);\n#else\n    XcpEventIdType i = 0;\n\n    for(i = 0; i < XCP_MAX_EVENT_DATA_NUMBER; i++) {\n        /* Unlock in reverse order, to prevent deadlock */\n    \txcpDaqWriteUnlock(XCP_MAX_EVENT_DATA_NUMBER - 1 - i);\n    }\n#endif\n}\n\n\nboolean_T xcpResetDaqListStatus(void)\n{\n    boolean_T locked = true;\n\n    if (xcpDynamicDaqLists.daq != NULL) {\n        XcpDaq *daq = xcpDynamicDaqLists.daq;\n        int32_T  daqCount = xcpDynamicDaqLists.daqCount;\n\n        locked = xcpDaqLock();\n\n        if (locked) {\n            /* No events were processed, it's safe to remove the DAQ lists */\n            int32_T i = 0;\n            int32_T j = 0;\n\n            /* No events are currently running,\n               it's safe to remove the DAQ lists */\n            xcpDynamicDaqLists.daq = NULL;\n            xcpDynamicDaqLists.daqCount = 0;\n            xcpDynamicDaqLists.firstAvailableDaqPid = 0;\n            xcpDynamicDaqLists.firstAvailableStimPid = 0;\n            \n            /* Reset ID of the DAQ List selected by START_STOP_DAQ_LIST command */\n            startStopDaqListId = XCP_INVALID_DAQ_LIST_ID;\n\n            /* Let's release the locks */\n            xcpDaqUnlock();\n\n            /* Prepare the Transport Layer for subsequent connections\n               (by resetting the Frame Handler counters and deleting the\n               existing packets in TX/RX fifos) */\n            xcpTransportRestart();\n\n            /* Delete all the Dynamic DAQ data structures and\n               reserved  memory pools */\n            for (i = 0; i < daqCount; i++) {\n                if (IS_USING_CUSTOM_POOL(daq[i].eventId)) {\n                    xcpMemCustomPoolDestroy(daq[i].poolId);\n                } else if (i < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER) {\n                    destroyDaqReservedPool(&daq[i]);\n                }\n\n                if (daq[i].odt != NULL) {\n                    for (j = 0; j < daq[i].odtCount; j++) {\n                        if (daq[i].odt[j].entry != NULL) {\n                            xcpMemFree(daq[i].odt[j].entry);\n                        }\n                    }\n\n                    xcpMemFree(daq[i].odt);\n                }\n            }\n\n            xcpMemFree(daq);\n\n            xcpSessionStatusClearMask(XCP_SESSION_DAQ_RUNNING_MASK);\n        }\n    }\n\n    return locked;\n}\n\n\nvoid xcpDaqReset(void)\n{\n    xcpResetDaqListStatus();\n\n    /* reset support for the extended list of DAQ commands */\n    xcpDaqExtendedReset();\n\n    /* Restore the original value for the lookup function */\n    xcpDaqSetPacketLookup(NULL);\n\n#if !defined(XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK) || (XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK == 0)\n    XCP_MUTEX_INIT(daqLock);\n#else\n    {\n        uint16_T i = 0;\n\n        for (i = 0; i < XCP_MAX_EVENT_DATA_NUMBER; i++) {\n            XCP_MUTEX_INIT(xcpEventData[i].lock);\n        }\n    }\n#endif\n}\n\n\nXcpErrorCode xcpDaqSetCustomPoolMemoryManager(XcpEventIdType eventId, \n                                              XcpCustomAllocHandler allocHandler, \n                                              XcpCustomFreeHandler freeHandler)\n{\n    if (allocHandler == NULL || freeHandler == NULL) {\n        return XCP_INV_ARG;\n    }\n\n    xcpEventCustomMemoryManager.eventId = eventId;\n    xcpEventCustomMemoryManager.allocHandler = allocHandler;\n    xcpEventCustomMemoryManager.freeHandler = freeHandler;\n\n    return XCP_SUCCESS;\n}\n\n\nXcpErrorCode xcpDaqGetCustomPoolMemoryManager(XcpEventIdType *eventId,\n                                              XcpCustomAllocHandler *allocHandler,\n                                              XcpCustomFreeHandler *freeHandler)\n{\n    if (xcpEventCustomMemoryManager.eventId == XCP_DAQ_CUSTOM_MEMORY_INVALID_EVENT_ID) {\n        return XCP_NOT_INITIALIZED;\n    }\n    if (allocHandler == NULL || freeHandler == NULL) {\n        return XCP_INV_ARG;\n    }\n\n    *eventId = xcpEventCustomMemoryManager.eventId;\n    *allocHandler = xcpEventCustomMemoryManager.allocHandler;\n    *freeHandler = xcpEventCustomMemoryManager.freeHandler;\n\n    return XCP_SUCCESS;\n}\n\n\n#ifdef XCP_INTERNAL_DAQ_CONFIG_ACCESS_SUPPORT\n\nXcpErrorCode xcpDaqGetOdtEntries(XcpEventIdType eventId, \n                                 XcpDaqDirection direction, \n                                 XcpOdtEntry* entries,\n                                 size_t* entriesNumber,\n                                 size_t maxEntriesNumber)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    XcpOdtEntry* currentEntry = entries;\n    size_t entriesCount = 0;\n    boolean_T memOverflow = false;\n\n    XCP_ERROR_IF(eventId >= XCP_MAX_EVENT_CHANNEL, XCP_INV_ARG, \"xcpDaqGetOdtEntries: invalid eventId\\n\");\n    XCP_ERROR_IF(direction != XCP_DIRECTION_DAQ, XCP_NOT_SUPPORTED, \"xcpDaqGetOdtEntries: direction not supported\\n\");\n    XCP_ERROR_IF(entries == NULL, XCP_INV_ARG, \"xcpDaqGetOdtEntries: invalid entries\\n\");\n    XCP_ERROR_IF(entriesNumber == NULL, XCP_INV_ARG, \"xcpDaqGetOdtEntries: invalid entriesNumber\\n\");\n    XCP_ERROR_IF(maxEntriesNumber == 0, XCP_INV_ARG, \"xcpDaqGetOdtEntries: invalid maxEntriesNumber\\n\");\n\n    /* Extract the ODT entries by navigating the whole DAQ List hierarchy */\n    if (xcpDynamicDaqLists.daq != NULL) {\n        uint16_T daqId = 0;\n        for (daqId = 0; (daqId < xcpDynamicDaqLists.daqCount) && !memOverflow; daqId++) {\n            XcpDaq *daq = &xcpDynamicDaqLists.daq[daqId];\n\n            if ((daq->eventId == eventId) &&\n                ((direction == XCP_DIRECTION_DAQ) &&\n                 !XCP_READ_BIT_VALUE(daq[daqId].mode, XCP_DAQ_MODE_DIRECTION_MASK)) &&\n                 isActiveDaqList(daqId)) {\n                /* only active DAQ lists are considered */\n                if (daq->odt != NULL) {\n                    uint8_T odtId = 0;\n\n                    for (odtId = 0; (odtId < daq->odtCount) && !memOverflow; odtId++) {\n                        XcpOdt *odt = &daq->odt[odtId];\n  \n                        if (odt->entry != NULL) {\n                            uint8_T entryId = 0;\n\n                            for (entryId = 0; (entryId < odt->entriesCount) && !memOverflow; entryId++) {\n                                XcpOdtEntry *odtEntry = &odt->entry[entryId];\n                                \n                                if (entriesCount < maxEntriesNumber) {\n                                    XCP_MEMCPY(currentEntry, odtEntry, sizeof(XcpOdtEntry));\n                                    currentEntry++;\n                                    entriesCount++;\n                                } else {\n                                    memOverflow = true;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    /* update number of entries copied and error code */\n    *entriesNumber = entriesCount;\n    if (memOverflow) {\n        errorCode = XCP_NO_MEMORY;\n    }\n\n    return errorCode;\n}\n\n#endif /* XCP_INTERNAL_DAQ_CONFIG_ACCESS_SUPPORT */\n\n\n#ifndef XCP_DAQ_EXTENDED_SUPPORT\n\nvoid xcpDaqExtendedInit(void) {}\nvoid xcpDaqExtendedReset(void) {}\n\n#endif\n\n#endif\n"},{"name":"xcp_drv_rtiostream.c","type":"source","group":"legacy","path":"E:\\Matlab\\toolbox\\coder\\xcp\\src\\target\\slave\\platform\\default","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2020 The MathWorks, Inc.\n*\n* File: xcp_drv_rtiostream.c\n*\n* Abstract:\n*  Implementation of XCP driver based on rtIOStream\n*/\n\n#include \"rtiostream.h\"\n#include \"xcp_common.h\"\n#include \"xcp.h\"\n#include \"xcp_drv.h\"\n\n#define INVALID_DRV_ID  -1\n\n/* Timeout expected for the reception of a packet, once the reception has started */\nstatic const uint32_T XCP_RECEIVE_PACKET_TIMEOUT_IN_MICROSECONDS  = 10000000L;  /* 10s */\n\n/* Delay before attempting the reception of new data */\nstatic const uint32_T XCP_RECEIVE_RETRY_TIME_IN_MICROSECONDS = 10L;  /* 10us */\n\n/* Timeout expected for the transmission of a packet, once the transmission has started */\nstatic const uint32_T XCP_SEND_PACKET_TIMEOUT_IN_MICROSECONDS = 2000000L;   /* 2s */\n\n/* Delay before attempting the transmission of new data */\nstatic const uint32_T XCP_SEND_RETRY_TIME_IN_MICROSECONDS = 10L;  /* 10us */\n\n\n/* According to the XCP standard, the XCP slave only supports the connection\n   with one XCP Master at a time. The active connection is identified by\n   a specific drvID */\nstatic int drvID = INVALID_DRV_ID;\n\n\n/* If set to true, force the xcpDrvSend and xcpDrvRecv APIs to be blocking */\nstatic boolean_T  forceBlocking = false;\n\n\nXcpErrorCode xcpDrvOpen(\n    int   argc,\n    void *argv[]\n    )\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    if (drvID != INVALID_DRV_ID) {\n        XCP_PRINTF(\"xcpDrvOpen: XCP driver already initialized\\n\");\n        return XCP_ERROR;\n    }\n\n    /* Open the actual communication channel */\n    drvID = rtIOStreamOpen(argc, argv);\n    if (drvID < 0) {\n        XCP_PRINTF(\"xcpDrvOpen: unable to open communication channel\\n\");\n        drvID = INVALID_DRV_ID;\n        errorCode = XCP_ERROR;\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpDrvIoctl(XcpDrvIoctlCommand cmd)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    XCP_ERROR_IF((cmd != XCP_DRV_RESTORE_DEFAULT_BLOCKING_SETUP) &&\n                 (cmd != XCP_DRV_FORCE_BLOCKING), XCP_INV_ARG,\n                 \"xcpDrvIoctl: invalid command\\n\");\n\n    forceBlocking = (cmd == XCP_DRV_FORCE_BLOCKING);\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpDrvSend(const void *src, size_t size)\n{\n    int ret = RTIOSTREAM_NO_ERROR;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t   sent = 0;\n    size_t sentBytesCounter = 0;\n    uint32_T elapsedTime = 0;\n    const uint8_T *dataPtr = NULL;\n    boolean_T done = false;\n\n    XCP_ERROR_IF(src == NULL, XCP_INV_ARG, \"xcpDrvSend: invalid src buffer\\n\");\n    XCP_ERROR_IF(size == 0, XCP_INV_ARG, \"xcpDrvSend: invalid size\\n\");\n    XCP_ERROR_IF(drvID == INVALID_DRV_ID, XCP_NOT_INITIALIZED, \"xcpDrvSend: XCP driver not initialized\\n\");\n\n    while (!done) {\n        dataPtr = (const uint8_T *)src + sentBytesCounter;\n        ret = rtIOStreamSend(drvID, dataPtr, (size - sentBytesCounter), &sent);\n\n        if (ret == RTIOSTREAM_NO_ERROR) {\n            if ((sent == 0) && (sentBytesCounter == 0) && !forceBlocking) {\n                /* This will only happen if the rtIOStreamSend function\n                   is non-blocking and we haven't started sending data yet */\n                errorCode = XCP_BUSY;\n            } else {\n                /* Send packet in progress, we need to complete it */\n                sentBytesCounter += sent;\n\n                done = (sentBytesCounter >= size) ;\n\n                if (!done) {\n                    if (elapsedTime >= XCP_SEND_PACKET_TIMEOUT_IN_MICROSECONDS) {\n                        errorCode = XCP_PKT_TX_TIMEOUT_ERROR;\n                    } else {\n                        XCP_SLEEP(0, XCP_SEND_RETRY_TIME_IN_MICROSECONDS);\n                        elapsedTime += XCP_SEND_RETRY_TIME_IN_MICROSECONDS;\n                    }\n                }\n            }\n        } else {\n            errorCode = XCP_ERROR;\n        }\n\n        done = done || (errorCode == XCP_BUSY) || (errorCode == XCP_ERROR) ||\n               (errorCode == XCP_PKT_TX_TIMEOUT_ERROR);\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpDrvRecv(void *dst, size_t size)\n{\n    int ret = RTIOSTREAM_NO_ERROR;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t receivedBytesCounter = 0;\n    size_t received = 0;\n    uint32_T elapsedTime = 0;\n    uint8_T *dataPtr = NULL;\n    boolean_T done = false;\n\n    XCP_ERROR_IF(dst == NULL, XCP_INV_ARG, \"xcpDrvRecv: invalid src buffer\\n\");\n    XCP_ERROR_IF(size == 0, XCP_INV_ARG, \"xcpDrvRecv: invalid size\\n\");\n    XCP_ERROR_IF(drvID == INVALID_DRV_ID, XCP_NOT_INITIALIZED, \"xcpDrvRecv: XCP driver not initialized\\n\");\n\n    while (!done) {\n        dataPtr = (uint8_T *)dst + receivedBytesCounter;\n\n        ret = rtIOStreamRecv(drvID, dataPtr, (size - receivedBytesCounter), &received);\n        if (ret == RTIOSTREAM_NO_ERROR) {\n            if ((received == 0) && (receivedBytesCounter == 0) && !forceBlocking) {\n                /* This will only happen if the rtIOStreamRecv function\n                   is non-blocking and we haven't started receiving data yet */\n                errorCode = XCP_EMPTY;\n            } else {\n                /* Receive packet in progress, we need to complete it */\n                receivedBytesCounter += received;\n                done = (receivedBytesCounter >= size);\n\n                if (!done) {\n                    if (elapsedTime >= XCP_RECEIVE_PACKET_TIMEOUT_IN_MICROSECONDS) {\n                        errorCode = XCP_PKT_RX_TIMEOUT_ERROR;\n                    } else {\n                        XCP_SLEEP(0, XCP_RECEIVE_RETRY_TIME_IN_MICROSECONDS);\n                        elapsedTime += XCP_RECEIVE_RETRY_TIME_IN_MICROSECONDS;\n                    }\n                }\n            }\n        }\n        else {\n            errorCode = XCP_ERROR;\n        }\n        \n        done = done || (errorCode == XCP_EMPTY) || (errorCode == XCP_ERROR) ||\n               (errorCode ==  XCP_PKT_RX_TIMEOUT_ERROR);\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpDrvRecvUnknownSize(void *dst, size_t *size, size_t maxSize)\n{\n    int ret = RTIOSTREAM_NO_ERROR;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t receivedBytes = 0;\n    uint8_T *dataPtr = NULL;\n\n    XCP_ERROR_IF(dst == NULL, XCP_INV_ARG, \"xcpDrvRecvUnknownSize: invalid dst buffer\\n\");\n    XCP_ERROR_IF(size == NULL, XCP_INV_ARG, \"xcpDrvRecvUnknownSize: invalid size pointer\\n\");\n    XCP_ERROR_IF(maxSize == 0, XCP_INV_ARG, \"xcpDrvRecvUnknownSize: invalid maxSize\\n\");\n    XCP_ERROR_IF(drvID == INVALID_DRV_ID, XCP_NOT_INITIALIZED, \"xcpDrvRecvUnknownSize: XCP driver not initialized\\n\");\n\n    dataPtr = (uint8_T *)dst;\n\n    ret = rtIOStreamRecv(drvID, dataPtr, maxSize, &receivedBytes);\n    if (ret == RTIOSTREAM_NO_ERROR) {\n        if (receivedBytes == 0) {\n            /* This will only happen if we haven't yet started receiving data */\n            errorCode = XCP_EMPTY;\n        }\n        else if (receivedBytes <= maxSize) {\n            /* Packet received. Hence, update the actual size */\n            *size = receivedBytes;\n            errorCode = XCP_SUCCESS;\n        }\n        else {\n            errorCode = XCP_ERROR;\n        }\n    }\n    else {\n        errorCode = XCP_ERROR;\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpDrvClose(void)\n{\n    int ret = RTIOSTREAM_NO_ERROR;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    if (drvID == INVALID_DRV_ID) {\n        XCP_PRINTF(\"xcpDrvClose: XCP driver already closed\\n\");\n        return XCP_SUCCESS; /* Nothing to do: just printing out a warning message*/\n    }\n\n    ret = rtIOStreamClose(drvID);\n\n    if (ret == RTIOSTREAM_NO_ERROR) {\n        drvID = INVALID_DRV_ID;\n        errorCode = XCP_SUCCESS;\n    }\n    else {\n        errorCode = XCP_ERROR;\n    }\n\n    return errorCode;\n}\n\n"},{"name":"xcp_ext_classic_trigger.c","type":"source","group":"legacy","path":"E:\\Matlab\\toolbox\\coder\\xcp\\src\\target\\ext_mode\\src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2020-2021 The MathWorks, Inc.\n *\n * File: xcp_ext_classic_trigger.c\n *\n * Abstract:\n *  This file contains the implementation of the External Mode\n *  \"Classic Trigger\" logic.\n *\n */\n\n#include \"xcp_ext_classic_trigger.h\"\n#include \"xcp_ext_common.h\"\n\n#define EXTMODE_TRIG_BASE_RATE_EVENT_ID EXTMODE_BASE_RATE_EVENT_ID\n\n#define DEFAULT_XCP_CLASSIC_TRIGGER_DURATION 1000\n\n\n/* Global variables directly accessible by the XCP Master */\nextmodeEventId_T volatile xcpClassicTriggerEventId = 0;\n\nuint32_T volatile xcpClassicTriggerSignalAddress = 0;\nuint8_T volatile  xcpClassicTriggerSignalAddressExtension = 0;\n\nextmodeClassicTriggerSignal_T volatile xcpClassicTriggerLevel = 0;\n\nuint32_T volatile xcpClassicTriggerDuration = DEFAULT_XCP_CLASSIC_TRIGGER_DURATION;\nuint32_T volatile xcpClassicTriggerHoldOff  = 0;\nint32_T  volatile xcpClassicTriggerDelay    = 0;\n\nXcpClassicTriggerDirection volatile xcpClassicTriggerDirection = XCP_EXTMODE_TRIGGER_RISING;\n\n#if defined(EXTMODE_TRIG_ARMED_ON_START) && EXTMODE_TRIG_ARMED_ON_START == 0\nboolean_T volatile xcpClassicTriggerArmRequest = false;\n#else\n/* Classic Trigger is armed by default */\nboolean_T volatile xcpClassicTriggerArmRequest = true;\n#endif\n\nboolean_T volatile xcpClassicTriggerCancelRequest = false;\n\nXcpClassicTriggerSource volatile xcpClassicTriggerSource = XCP_EXTMODE_TRIGGER_MANUAL;\n\nXcpClassicTriggerMode volatile xcpClassicTriggerMode = XCP_EXTMODE_TRIGGER_NORMAL;\n\nXcpClassicTriggerStatus volatile xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_UNARMED;\n\n\nXCP_STATIC extmodeClassicTriggerSignal_T xcpOldSignalValue = 0;\nXCP_STATIC boolean_T                     xcpOldSignalValueAvailable = false;\n\nXCP_STATIC XcpClassicTriggerSource       xcpOldClassicTriggerSource = XCP_EXTMODE_TRIGGER_MANUAL;\n\nXCP_STATIC boolean_T                     xcpTriggerEnabled = false;\nXCP_STATIC boolean_T                     xcpSignalTriggerFired = false;\nXCP_STATIC uint32_T                      xcpTriggerCount = 0;\n\nXCP_STATIC boolean_T                     xcpForcedTriggerEnabled = false;\nXCP_STATIC boolean_T                     xcpForceTriggerEnableRequest = false;\n\n/** The function is responsible for sampling the signal trigger value\n    and setting the xcpSignalTriggerFired boolean to true if\n    the trigger signal has the expected transition across the xcpClassicTriggerLevel.\n    The boolean will always be restored back to false by the base rate\n    when the event is acknowledged and the state transition completed.\n    The function is also setting xcpTriggerEnabled to true if no Delay is required. */\nstatic void sampleSignalTrigger(void)\n{\n    extmodeClassicTriggerSignal_T *signal = (extmodeClassicTriggerSignal_T *)\n                                            XCP_ADDRESS_GET_INTERNAL(xcpClassicTriggerSignalAddressExtension,\n                                                            xcpClassicTriggerSignalAddress);\n    if ((signal != NULL) &&\n       ((xcpClassicTriggerSignalAddressExtension != 0) ||\n        (xcpClassicTriggerSignalAddress != 0))) {\n        if ((xcpClassicTriggerStatus ==\tXCP_EXTMODE_TRIGGER_ARMED) &&\n            !xcpSignalTriggerFired) {\n            /* Read the new signal value */\n            extmodeClassicTriggerSignal_T signalValue = *signal;\n\n            if (xcpOldSignalValueAvailable) {\n                /* If the trigger is armed and not already fired,\n                   check for the expected transition */\n                boolean_T checkForRising =  (xcpClassicTriggerDirection == XCP_EXTMODE_TRIGGER_RISING) ||\n                                            (xcpClassicTriggerDirection == XCP_EXTMODE_TRIGGER_RISING_OR_FALLING);\n\n                boolean_T checkForFalling = (xcpClassicTriggerDirection == XCP_EXTMODE_TRIGGER_FALLING) ||\n                                            (xcpClassicTriggerDirection == XCP_EXTMODE_TRIGGER_RISING_OR_FALLING);\n\n                if (checkForRising &&\n                   (((signalValue >= xcpClassicTriggerLevel) && (xcpOldSignalValue <  xcpClassicTriggerLevel)) ||\n                    ((signalValue >  xcpClassicTriggerLevel) && (xcpOldSignalValue == xcpClassicTriggerLevel)))) {\n\n                    if (xcpClassicTriggerDelay == 0) {\n                        /* fire the event immediately if needed no Delay is required */\n                        xcpTriggerEnabled = true;\n                    }\n                    xcpSignalTriggerFired   = true; /* the transition from ARMED to FIRING is updated in base rate */\n                }\n                if (checkForFalling &&\n                   (((signalValue < xcpClassicTriggerLevel)  && (xcpOldSignalValue >= xcpClassicTriggerLevel)) ||\n                    ((signalValue == xcpClassicTriggerLevel) && (xcpOldSignalValue >  xcpClassicTriggerLevel)))) {\n\n                    if (xcpClassicTriggerDelay == 0) {\n                        /* fire the event immediately if needed no Delay is required */\n                        xcpTriggerEnabled = true;\n                    }\n                    xcpSignalTriggerFired   = true; /* the transition from ARMED to FIRING is updated in base rate */\n                }\n            }\n\n            /* Update the old signal value. Note: if we just fired, the sampling will start\n               next time the trigger is armed and therefore we reset xcpOldSignalValueAvailable */\n            xcpOldSignalValueAvailable = !xcpSignalTriggerFired;\n            xcpOldSignalValue = signalValue;\n        }\n    }\n}\n\n\n/** The function is executed in the base rate and it is responsible\n    for the handling of the triggering status transitions */\nstatic void updateTriggerStatus(void)\n{\n    /* Process user Arm/Cancel requests common to all states\n       and update the triggerFired variable (depending on the\n       active triggering source) */\n    boolean_T triggerFired = false;\n\n    if (xcpClassicTriggerStatus == XCP_EXTMODE_TRIGGER_UNARMED) {\n        /* This case deserves a separate handling\n           because we would like the transition to the ARMED status\n           to occur in the same cycle.\n           Since we are already UNARMED, any request to cancel \n           the trigger can be ignored */\n        xcpClassicTriggerCancelRequest = false;\n        xcpSignalTriggerFired = false;\n\n        if (xcpClassicTriggerArmRequest) {\n            /* Process arm request */\n            xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_ARMED;\n            xcpClassicTriggerArmRequest = false;\n\n            /* If we are using MANUAL trigger, we want to start \n               firing the trigger event straightaway, e.g.\n               when the user selects ExtModeArmWhenConnect */\n            if (xcpClassicTriggerSource == XCP_EXTMODE_TRIGGER_MANUAL) {\n                triggerFired = true;\n            }\n        }\n    } else {\n        /* We are already armed, ignore any request to arm the trigger */\n        xcpClassicTriggerArmRequest = false;\n\n        if (xcpClassicTriggerCancelRequest) {\n            /* No matter what the Status is, a cancel request should\n               always bring the status to UNARMED.\n               We implement the transition here, to avoid code\n               duplication in the states. */\n            xcpTriggerEnabled = false;\n            xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_UNARMED;\n            xcpClassicTriggerCancelRequest = false;\n        } else {\n            if (xcpClassicTriggerSource == XCP_EXTMODE_TRIGGER_MANUAL) {\n                /* when manual triggering is selected, we assume that\n                   the trigger event has always been fired when armed */\n                triggerFired = true;\n            } else {\n                /* when signal triggering is selected, we check the status\n                   of the xcpSignalTriggerFired (updated by the\n                   sampleSignalTrigger() logic */\n                triggerFired = xcpSignalTriggerFired;\n                xcpSignalTriggerFired = false;\n            }\n        }\n    }\n\n    /* Handle the remaining state transitions */\n    switch (xcpClassicTriggerStatus) {\n    case XCP_EXTMODE_TRIGGER_UNARMED:\n        if (xcpClassicTriggerArmRequest) {\n            /* Process arm request */\n            xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_ARMED;\n            xcpClassicTriggerArmRequest = false;\n        }\n        break;\n\n    case XCP_EXTMODE_TRIGGER_ARMED:\n        if (triggerFired) {\n            if ((xcpClassicTriggerDelay > 0) &&\n                (xcpClassicTriggerSource == XCP_EXTMODE_TRIGGER_SIGNAL)) {\n                /* We need to postpone the enabling of the trigger\n                   by xcpClassicTriggerDelay base periods */\n                xcpTriggerCount = (uint32_T) xcpClassicTriggerDelay;\n                xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_DELAYED;\n            } else {\n                /* Negative xcpClassicTriggerDelay are ignored.\n                   The parameter is also ignored if the xcpClassicTriggerSource\n                   is XCP_EXTMODE_TRIGGER_MANUAL\n                   If xcpClassicTriggerDelay is 0 we enable the trigger straight away */\n                if (xcpClassicTriggerDuration > 0) {\n                    xcpTriggerEnabled = true;\n                    xcpTriggerCount = xcpClassicTriggerDuration;\n                    xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_FIRING;\n                } else {\n                    /* If duration is 0, we would never be able to send any data.\n                       This situation should be prevented on the host,\n                       we just handle it gracefully here, in case it happens */\n                    XCP_PRINTF(\"Invalid duration value (0) detected.\\n\");\n                    xcpTriggerEnabled = false;\n                    xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_UNARMED;\n                }\n            }\n        }\n        break;\n\n    case XCP_EXTMODE_TRIGGER_FIRING:\n        /* Update the base rate counter */\n        if (xcpTriggerCount > 0) {\n            xcpTriggerCount--;\n        }\n\n        if (xcpTriggerCount == 0) {\n            /* Duration has expired */\n            if (xcpClassicTriggerMode == XCP_EXTMODE_TRIGGER_ONESHOT) {\n                /* In the one-shot scenario we just disable the trigger */\n                xcpTriggerEnabled = false;\n                xcpClassicTriggerStatus  = XCP_EXTMODE_TRIGGER_UNARMED;\n            } else {\n                /* In normal mode, we might have to handle the HoldOff and\n                   pause the triggering  */\n                if (xcpClassicTriggerHoldOff > 0) {\n                    xcpTriggerEnabled = false;\n                    xcpTriggerCount = xcpClassicTriggerHoldOff;\n                    xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_HOLDING_OFF;\n                } else {\n                    if (triggerFired) {\n                        /* If the trigger has been fired, we start another duration\n                           straight away */\n                        xcpTriggerCount = xcpClassicTriggerDuration;\n                        xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_FIRING;\n                    } else {\n                        /* We wait for the next trigger to be fired */\n                        xcpTriggerEnabled = false;\n                        xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_ARMED;\n                    }\n                }\n            }\n        }\n        break;\n\n    case XCP_EXTMODE_TRIGGER_DELAYED:\n        /* Update the base rate counter */\n        if (xcpTriggerCount > 0) {\n            xcpTriggerCount--;\n        }\n\n        if (xcpTriggerCount == 0) {\n            /* Delay is over, we can enable the trigger now */\n            if (xcpClassicTriggerDuration > 0) {\n                xcpTriggerEnabled = true;\n                xcpTriggerCount = xcpClassicTriggerDuration;\n                xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_FIRING;\n            } else {\n                /* If duration is 0, we would never be able to send any data.\n                   This situation should be prevented on the host,\n                   we just handle it gracefully here, in case it happens */\n                XCP_PRINTF(\"Invalid duration value (0) detected.\\n\");\n                xcpTriggerEnabled = false;\n                xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_UNARMED;\n            }\n        }\n        break;\n\n    case XCP_EXTMODE_TRIGGER_HOLDING_OFF:\n        /* Update the base rate counter */\n        if (xcpTriggerCount > 0) {\n            xcpTriggerCount--;\n        }\n\n        if (xcpTriggerCount == 0) {\n            /* HoldOff time has expired */\n            if (triggerFired) {\n                /* If the trigger has been fired, we start another duration\n                   straight away */\n                if (xcpClassicTriggerDuration > 0) {\n                    xcpTriggerEnabled = true;\n                    xcpTriggerCount = xcpClassicTriggerDuration;\n                    xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_FIRING;\n                } else {\n                    /* If duration is 0, we would never be able to send any data.\n                       This situation should be prevented on the host,\n                       we just handle it gracefully here, in case it happens */\n                    XCP_PRINTF(\"Invalid duration value (0) detected.\\n\");\n                    xcpTriggerEnabled = false;\n                    xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_UNARMED;\n                }\n            } else {\n                /* We wait for the next trigger to be fired */\n                xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_ARMED;\n            }\n        }\n        break;\n\n    default:\n        XCP_PRINTF(\"Invalid Trigger Status %d detected\\n\", xcpClassicTriggerStatus);\n        xcpTriggerEnabled = false;\n        xcpSignalTriggerFired = false;\n        xcpClassicTriggerCancelRequest = false;\n        xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_UNARMED;\n    }\n}\n\n\n\nXcpErrorCode xcpExtModeClassicTriggerInit(void)\n{\n    xcpOldSignalValue = 0;\n    xcpOldSignalValueAvailable = false;\n\n    xcpOldClassicTriggerSource = xcpClassicTriggerSource;\n\n    xcpTriggerEnabled = false;\n    xcpSignalTriggerFired = false;\n    xcpTriggerCount = 0;\n\n    xcpClassicTriggerStatus  = XCP_EXTMODE_TRIGGER_UNARMED;\n\n    return XCP_SUCCESS;\n}\n\n\n/** The function returns true if the external mode event must be triggered */\nboolean_T xcpExtModeClassicTriggerEnabled(extmodeEventId_T eventId)\n{\n    if (eventId == EXTMODE_TRIG_BASE_RATE_EVENT_ID) {\n        /* Whenever a change of the xcpClassicTriggerSource is detected\n           the xcpClassicTriggerStatus is reset */\n        boolean_T triggerSrcChangeDetected = (xcpClassicTriggerSource != xcpOldClassicTriggerSource);\n        xcpOldClassicTriggerSource = xcpClassicTriggerSource;\n\n        if (triggerSrcChangeDetected) {\n            xcpTriggerEnabled     = false;\n            xcpSignalTriggerFired = false;\n            xcpTriggerCount       = 0;\n\n            xcpClassicTriggerStatus  = XCP_EXTMODE_TRIGGER_UNARMED;\n        }\n\n        /* If XCP_EXTMODE_TRIGGER_SIGNAL is selected we want to start\n           processing the Arm request (or the Hold-off expiration) \n           straightaway and carry out the state transition before \n           sampling for the first time */\n        if ((xcpClassicTriggerSource == XCP_EXTMODE_TRIGGER_SIGNAL)  &&\n            (((xcpClassicTriggerStatus == XCP_EXTMODE_TRIGGER_UNARMED) &&\n               xcpClassicTriggerArmRequest) ||\n             ((xcpClassicTriggerStatus == XCP_EXTMODE_TRIGGER_HOLDING_OFF) &&\n              (xcpTriggerCount == 1)))) {\n               xcpTriggerCount = 0;\n               xcpClassicTriggerArmRequest = false;\n               xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_ARMED;\n        }\n    }\n\n    if ((xcpClassicTriggerSource == XCP_EXTMODE_TRIGGER_SIGNAL) &&\n        (eventId == xcpClassicTriggerEventId))  {\n        /* Since we are running at the correct eventID, sample the\n           trigger signal value to determine if the trigger signal\n           needs to be enabled.\n           Note: this will update the boolean straight away and request\n           the state transition (updated at the next base rate) */\n        sampleSignalTrigger();\n    }\n\n    if (eventId == EXTMODE_TRIG_BASE_RATE_EVENT_ID) {\n        /* update trigger status to fulfill user requests */\n        updateTriggerStatus();\n\n        /* If the base rate task has run, then reset the\n         * xcpForceTriggerEnableRequest flag.  The state machine\n         * is up to date. */\n        xcpForceTriggerEnableRequest = false;\n    } else if (xcpForceTriggerEnableRequest) {\n        return xcpForcedTriggerEnabled;\n    }\n\n    return xcpTriggerEnabled;\n}\n\n\n/** Reset External Mode classic triggering logic, by restoring the default status */\nXcpErrorCode xcpExtModeClassicTriggerReset(void)\n{\n    xcpOldSignalValue = 0;\n    xcpOldSignalValueAvailable = false;\n\n    xcpClassicTriggerStatus  = XCP_EXTMODE_TRIGGER_UNARMED;\n    xcpOldClassicTriggerSource = XCP_EXTMODE_TRIGGER_MANUAL;\n    xcpClassicTriggerEventId = 0;\n    xcpTriggerEnabled = false;\n    xcpSignalTriggerFired = false;\n    xcpTriggerCount = 0;\n    xcpForcedTriggerEnabled = false;\n    xcpForceTriggerEnableRequest = false;\n\n    xcpClassicTriggerSignalAddress = 0;\n    xcpClassicTriggerSignalAddressExtension = 0;\n\n    xcpClassicTriggerLevel    = 0;\n    xcpClassicTriggerDuration = DEFAULT_XCP_CLASSIC_TRIGGER_DURATION;\n    xcpClassicTriggerHoldOff  = 0;\n    xcpClassicTriggerDelay    = 0;\n\n    xcpClassicTriggerDirection = XCP_EXTMODE_TRIGGER_RISING;\n\n#if defined(EXTMODE_TRIG_ARMED_ON_START) && EXTMODE_TRIG_ARMED_ON_START == 0\n    xcpClassicTriggerArmRequest = false;\n#else\n/* Classic Trigger is armed by default */\n    xcpClassicTriggerArmRequest = true;\n#endif\n\n    xcpClassicTriggerCancelRequest = false;\n\n    xcpClassicTriggerSource = XCP_EXTMODE_TRIGGER_MANUAL;\n    xcpClassicTriggerMode = XCP_EXTMODE_TRIGGER_NORMAL;\n\n    return XCP_SUCCESS;\n}\n\n\n/** When Manual triggering is enabled, force output of xcpExtModeClassicTriggerEnabled to\n *  match pending Arm or Cancel request for all non-base rate events until requests are \n *  processed at the next base rate event.\n * \n *  In the concurrent execution workflow, it is used to avoid omission\n *  of logging data points if a non-base rate task completes\n *  before the base rate at t = 0.\n * \n *  This is a NO-OP when XCP_EXTMODE_TRIGGER_SIGNAL is active.\n */\nvoid xcpExtModeClassicTriggerForceEnableStatusUpdate(void) {\n    if (xcpClassicTriggerSource == XCP_EXTMODE_TRIGGER_MANUAL) {\n        if (xcpClassicTriggerArmRequest && !xcpClassicTriggerCancelRequest) {\n            /* Force xcpExtModeClassicTriggerEnabled to return true\n            * until the next base rate event. */\n            xcpForcedTriggerEnabled = true;\n            xcpForceTriggerEnableRequest = true;\n        } else if (xcpClassicTriggerCancelRequest & !xcpClassicTriggerArmRequest) {\n            xcpForcedTriggerEnabled = false;\n            xcpForceTriggerEnableRequest = true;\n        } else {\n            xcpForceTriggerEnableRequest = false;\n        }\n    }\n}\n"},{"name":"xcp_ext_common.c","type":"source","group":"legacy","path":"E:\\Matlab\\toolbox\\coder\\xcp\\src\\target\\ext_mode\\src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2018-2021 The MathWorks, Inc.\n *\n * File: xcp_ext_common.c\n *\n * Abstract:\n *  This file contains the implementation of the common functionalities\n *  used within the XCP External Mode Platform Abstraction layer.\n *\n *  This includes the handling of absolute simulation time and the global\n *  variables to control the execution of the model on the target\n *  (and accessed remotely via XCP communication protocol).\n */\n#if !defined(INTEGER_CODE) || INTEGER_CODE == 0\n#include <float.h>         /* for DBL_EPSILON */\n#include <math.h>\n#endif\n\n#include \"xcp_ext_common.h\"\n#include \"xcp_ext_param.h\"\n#include \"xcp.h\"\n#include \"xcp_internal.h\"\n#include \"xcp_transport.h\"\n#include \"xcp_cfg.h\"\n\n#include \"rtw_extmode.h\"\n\n#ifdef XCP_CUSTOM_ADDRESS_TRANSLATION\nvoid xcpInitCustomAddressGet(void);\n#endif\n\n#ifndef EXTMODE_FLUSH_ALL_DATA_DELAY_TIME_IN_MICROSECONDS\n/* Dummy delay, that forces the background task to pause the execution\n   and reduces the packets transmission rate. \n   This is useful for host-based targets to prevent the saturation\n   of transmission buffers */\n#define EXTMODE_FLUSH_ALL_DATA_DELAY_TIME_IN_MICROSECONDS  10L  /* 10us */\n#endif\n\n\n/* XCP Master can 'directly' access these global variables, in order to control\n   the model state machine */\n\n#if defined(ON_TARGET_WAIT_FOR_START) && ON_TARGET_WAIT_FOR_START == 1\nboolean_T volatile xcpModelStartRequest = false;\n#else\nboolean_T volatile xcpModelStartRequest = true;\n#endif\nboolean_T volatile xcpModelStopRequest = false;\nXcpExtModeStatus volatile xcpModelStatus = XCP_EXTMODE_STATUS_RESET;\n\nuint32_T volatile xcpModelChecksum0   = 0;\nuint32_T volatile xcpModelChecksum1   = 0;\nuint32_T volatile xcpModelChecksum2   = 0;\nuint32_T volatile xcpModelChecksum3   = 0;\nuint32_T volatile xcpModelIntegerCode = 0;\n\n/* Global variable defined when a non-BYTE addressable target is\n   being emulated as a BYTE addressable target. Currently defined \n   only for WORD addressable targets (Eg.:C2000). But, can be\n   extended to DWORD addressable targets */\n#ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\nuint8_T volatile xcpEmulateWordTargetAsByteTarget = 1;\n#endif\n\n#if defined(INTEGER_CODE) && INTEGER_CODE == 1\nextmodeSimulationTime_T volatile xcpExtmodeFinalSimulationTime = EXTMODE_SIMULATION_RUN_FOREVER;\n#else\nextmodeSimulationTime_T volatile xcpExtmodeFinalSimulationTime = EXTMODE_SIMULATION_TIME_NOT_INITIALIZED;\n#endif\n\nboolean_T               volatile xcpExtmodeSimulationComplete  = false;\n\n#if !defined(INTEGER_CODE) || INTEGER_CODE == 0\n/* Dummy double variable, required to obtain the size of double data type on the target \n   using the symbols parser. */\nextmodeDouble_T volatile xcpDummyDoubleVariable = (extmodeDouble_T) 0;\n#endif\n\n/* Definition of a dummy printf function */\nvoid xcp_void_printf(const char_T *fmt,...){UNUSED_PARAMETER(fmt);}\n\n\n#if (defined(INTEGER_CODE) && INTEGER_CODE == 1) || defined(XCP_EXTMODE_SIMULATION_TIME_IN_TICKS)\n\n/* The mutex is used to protect against the concurrent access to the global\n   variables (related to the simulation time) when xcpExtModeUpdateTime()\n   is executed by different threads.\n   In particular it guarantees that the state of the variables is updated\n   atomically and it is always consistent when the function is executed */\nstatic XCP_MUTEX_DEFINE(xcpExtModeLock);\n\n\nuint32_T xcpCurrentSimulationTimeInTicks[2] = {0};\n\n/* The variable contains the last value of model simulation time \n   received via extmodeEvent() for the Base Rate thread.\n   In particular, the extmodeSimulationTime_T represents absolute time \n   (in baserate ticks)\n   Note: xcpBaseRateSimulationTime is assumed to be monotonically increasing, \n         but a counter overflow could occur */\nXCP_STATIC extmodeSimulationTime_T xcpBaseRateSimulationTime = 0;\n\n/* When LifeSpan is short, the xcpBaseRateSimulationTime variable could \n  \"overflow earlier than expected\", as the generated code may use only \n  a 16bit counter to store the baserate ticks.\n\n  The purpose of xcpTicksCounterL is to convert the xcpBaseRateSimulationTime \n  into a \"normal\" 32bit variable (and it relies on the EXTMODE_MAX_BASE_RATE_SIMULATION_TIME\n  value to understand when the overflow is supposed to occur).\n\n  xcpTicksCounterL and xcpTicksCounterH are then used to obtain \n  the xcpCurrentSimulationTimeInTicks global tick counter */\nXCP_STATIC uint32_T xcpTicksCounterL = 0;\nXCP_STATIC uint32_T xcpTicksCounterH = 0;\n\n/* The variable contains the last value of simulation time converted into a 32 bit\n   value with XCP_TIMESTAMP_UNIT resolution. This variable is only updated when\n   base rate is executed */\nXCP_STATIC uint32_T xcpBaseRateSimulationTimestamp = 0;\n\n#else /* INTEGER_CODE == 0 */\n\nuint32_T xcpCurrentSimulationTimeInMs[2] = {0};\nXCP_STATIC extmodeSimulationTime_T xcpBaseRateSimulationTime = 0;\n\n#endif\n\n#ifndef XCP_BIG_ENDIAN\n\nXCP_STATIC void xcpCopyTimeValue(volatile uint32_T *dst, uint32_T lsb, uint32_T msb)\n{\n    dst[0] = lsb;\n    dst[1] = msb;\n}\n\n#else /* BIG ENDIAN*/\n\n#define XCP_BYTES_SWAP(value)    ((((value) >> 24) & 0x000000ff)| \\\n                                  (((value) >> 8)  & 0x0000ff00)| \\\n                                  (((value) << 8)  & 0x00ff0000)| \\\n                                  (((value) << 24) & 0xff000000))\n\nXCP_STATIC void xcpCopyTimeValue(volatile uint32_T *dst, uint32_T lsb, uint32_T msb)\n{\n    dst[0] = XCP_BYTES_SWAP(lsb);\n    dst[1] = XCP_BYTES_SWAP(msb);\n}\n\n#endif /* BIG ENDIAN*/\n\n\n#if (defined(INTEGER_CODE) && INTEGER_CODE == 1) || defined(XCP_EXTMODE_SIMULATION_TIME_IN_TICKS)\n\n/* Define the XCP_TIMESTAMP_UNITS_PER_MICROSECOND value based on the\n   selected XCP_TIMESTAMP_UNIT */\n#if (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1US)\n#define XCP_TIMESTAMP_UNITS_PER_MICROSECOND     1\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10US)\n#define XCP_TIMESTAMP_UNITS_PER_MICROSECOND     10\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100US)\n#define XCP_TIMESTAMP_UNITS_PER_MICROSECOND     100\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1MS)\n#define XCP_TIMESTAMP_UNITS_PER_MICROSECOND     1000\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10MS)\n#define XCP_TIMESTAMP_UNITS_PER_MICROSECOND     10000\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100MS)\n#define XCP_TIMESTAMP_UNITS_PER_MICROSECOND     100000\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1S)\n#define XCP_TIMESTAMP_UNITS_PER_MICROSECOND     1000000\n#else\n#error \"Invalid XCP_TIMESTAMP_UNIT value. When Purely Integer code is selected, it must be greater than or equal to XCP_TIMESTAMP_UNIT_1US.\"\n#endif\n\n\nstatic extmodeSimulationTime_T xcpExtModeMaxBaseRateSimulationTime = EXTMODE_MAX_BASE_RATE_SIMULATION_TIME;\n\n\n/* Internal function that updates absolute simulation time variables:\n   - xcpCurrentSimulationTimeInTicks \n   - xcpBaseRateSimulationTime\n   - xcpBaseRateSimulationTimestamp\n   and detect if the simulation is actually complete\n   (by updating xcpExtmodeSimulationComplete variable)\n \n   The function returns the 32bit XCP Timestamp counter value \n   (in XCP_TIMESTAMP_UNITs) corresponding to the given newTime\n \n   Note: the newTime input represents the model simulation time in base rate ticks */\nstatic uint32_T updateTime(extmodeSimulationTime_T newTime, extmodeEventId_T eventId)\n{\n    uint32_T timestamp = 0;\n\n    XCP_MUTEX_LOCK(xcpExtModeLock);\n    \n    if (eventId == EXTMODE_BASE_RATE_EVENT_ID) {\n        /* Absolute time variables are only updated when \n           base rate thread is executed */\n        extmodeSimulationTime_T ticksIncrement;\n        extmodeSimulationTime_T newCounterTicks;\n\n        /* Detect increment (in ticks) */\n        if (newTime >= xcpBaseRateSimulationTime) {\n            ticksIncrement = newTime - xcpBaseRateSimulationTime;\n        } else {\n            ticksIncrement = newTime + EXTMODE_MAX_BASE_RATE_SIMULATION_TIME - xcpBaseRateSimulationTime + 1;\n        }\n    \n        /* Update xcpTicksCounterL and xcpTicksCounterH tick counters */\n        newCounterTicks = xcpTicksCounterL + ticksIncrement;\n    \n        if (newCounterTicks < xcpTicksCounterL) {\n            xcpTicksCounterH++;\n        }\n        xcpTicksCounterL = newCounterTicks;\n\n        /* Update absolute simulation time values */\n        xcpCopyTimeValue(xcpCurrentSimulationTimeInTicks, xcpTicksCounterL, xcpTicksCounterH);\n\n        /* Save last received base rate simulation time */\n        xcpBaseRateSimulationTime = newTime;\n    \n        /* Update the 32bit XCP Timestamp counter for the base rate, using 32bit unsigned integer arithmetic */\n        xcpBaseRateSimulationTimestamp += ticksIncrement * EXTMODE_STEP_SIZE_IN_MICROSECONDS * XCP_TIMESTAMP_UNITS_PER_MICROSECOND;\n\n        timestamp = xcpBaseRateSimulationTimestamp;\n        \n        /* Check if simulation is complete */\n        if ((xcpExtmodeFinalSimulationTime != EXTMODE_SIMULATION_RUN_FOREVER) &&\n            (xcpExtmodeFinalSimulationTime != EXTMODE_SIMULATION_TIME_NOT_INITIALIZED)) {\n            /* By default, assuming EXTMODE_SIMULATION_RUN_FOREVER */\n            xcpExtmodeSimulationComplete = (xcpTicksCounterL >= xcpExtmodeFinalSimulationTime);\n        }\n    } else {\n        /* For threads different from the base rate, if the execution is\n           really concurrent, the simulationTime value might be different \n           from xcpBaseRateSimulationTime (ahead or behind).\n           The resulting timestamp value is calculated starting from \n           xcpBaseRateSimulationTimestamp and adding/subtracting the \n           difference */\n        extmodeSimulationTime_T ticksIncrement = 0;\n        extmodeSimulationTime_T ticksDecrement = 0;\n        \n        if (xcpExtModeMaxBaseRateSimulationTime < MAX_extmodeSimulationTime_T) {\n            /* If the size of extmodeSimulationTime_T data type allows\n               the representation of numbers bigger than EXTMODE_MAX_BASE_RATE_SIMULATION_TIME\n               then the newTime value needs to be \"converted\" to just use the same\n               amount of bits as the Base Rate (ClockTick0)\n               Note: this happens for example when ClockTicks are uint16_T and\n               extmodeSimulationTime_T is uint32_T. If the first subrate is half\n               of the base rate then\n                   newTime = ClockTick1 * 2\n               and this time would end up being bigger than EXTMODE_MAX_BASE_RATE_SIMULATION_TIME */\n            newTime = newTime % (xcpExtModeMaxBaseRateSimulationTime + 1);\n        }\n\n        if (newTime >= xcpBaseRateSimulationTime) {\n            /* We need to identify one of the two cases:\n               - newTime is ahead of xcpBaseRateSimulationTime\n               - newTime is behind but an overflow occurred\n             */\n            ticksIncrement = newTime - xcpBaseRateSimulationTime;\n            ticksDecrement = xcpBaseRateSimulationTime + EXTMODE_MAX_BASE_RATE_SIMULATION_TIME - newTime + 1;\n\n            if (ticksDecrement <= ticksIncrement) {\n                /* Assuming that newTime is behind and an overflow has occurred */\n                ticksIncrement = 0;\n            } else {\n            \t/* assuming that newTime is ahead */\n                ticksDecrement = 0;\n            }\n        } else {\n            /* We need to identify one of the two cases:\n               - newTime is behind of xcpBaseRateSimulationTime\n               - newTime is ahead but an overflow occurred\n             */\n            ticksIncrement = newTime + EXTMODE_MAX_BASE_RATE_SIMULATION_TIME - xcpBaseRateSimulationTime + 1;\n            ticksDecrement = xcpBaseRateSimulationTime - newTime;\n\n            if (ticksDecrement <= ticksIncrement) {\n                /* Assuming that newTime is behind, as more likely */\n                ticksIncrement = 0;\n            } else {\n            \t/* assuming that newTime is ahead and an overflow has occurred */\n                ticksDecrement = 0;\n            }\n        }\n\n        if (ticksIncrement > 0) {\n            timestamp = xcpBaseRateSimulationTimestamp +\n                        (ticksIncrement * EXTMODE_STEP_SIZE_IN_MICROSECONDS * XCP_TIMESTAMP_UNITS_PER_MICROSECOND);\n        } else {\n            timestamp = xcpBaseRateSimulationTimestamp -\n                        (ticksDecrement * EXTMODE_STEP_SIZE_IN_MICROSECONDS * XCP_TIMESTAMP_UNITS_PER_MICROSECOND);\n        }\n    }\n\n    XCP_MUTEX_UNLOCK(xcpExtModeLock);\n    \n    return timestamp;\n}\n\n/* Update absolute simulation time variables\n   and detect if the simulation is actually complete\n\n   Note: the newTime input represents the current model simulation time */\nvoid xcpExtModeUpdateTime(extmodeSimulationTime_T newTime, extmodeEventId_T eventId)\n{\n    updateTime(newTime, eventId);\n}\n\n/* In addition to updating absolute simulation time variables\n   and detecting if the simulation is actually complete, \n   the function returns the 32bit XCP Timestamp counter value\n   (in XCP_TIMESTAMP_UNITs) corresponding to the given newTime\n\n   Note: the newTime input represents the model simulation time */\nuint32_T xcpExtModeGetUpdatedTimestamp(extmodeSimulationTime_T newTime, extmodeEventId_T eventId)\n{\n    return updateTime(newTime, eventId);\n}\n\n\n#ifdef XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME\n\n/* Return value in XCP_TIMESTAMP_UNITs, based on the current model simulation time */\nuint32_T xcpGetTimestamp(void)\n{\n    uint32_T timestamp;\n\n    /* @note: theoretically the base thread could pre-preempt any thread during the\n       read operation. Since the read of a 32bit value may not be atomic\n       in some architectures we have to protect it with a mutex.\n       We may be able to remove this lock if we extend the Platform Abstraction Layer\n       to include atomic read operations */\n    XCP_MUTEX_LOCK(xcpExtModeLock);\n\n    timestamp = xcpBaseRateSimulationTimestamp;\n\n    XCP_MUTEX_UNLOCK(xcpExtModeLock);\n\n    return timestamp;\n}\n\n#endif /* XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME */\n\n#else /* INTEGER_CODE == 0 */\n\n/* Define the XCP_TIMESTAMP_UNITS_PER_SECOND value based on the\n   selected XCP_TIMESTAMP_UNIT */\n#if (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1NS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e9\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10NS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e8\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100NS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e7\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1US)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e6\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10US)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e5\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100US)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e4\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1MS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e3\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10MS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e2\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100MS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e1\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1S)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND            1\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1PS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND         1e12\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10PS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND         1e11\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100PS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND         1e10\n#else\n#error \"invalid XCP_TIMESTAMP_UNIT value\"\n#endif\n\n\n/* Update absolute simulation time variable xcpCurrentSimulationTimeInMs\n   and detect if the simulation is actually complete\n   (by updating xcpExtmodeSimulationComplete variable)\n\n   The function returns the 32bit XCP Timestamp counter value\n   (in XCP_TIMESTAMP_UNITs) corresponding to the given newTime\n\n   Note: the newTime input represents the model simulation time in seconds */\nvoid xcpExtModeUpdateTime(extmodeSimulationTime_T newTime, extmodeEventId_T eventId)\n{\n    if (eventId == EXTMODE_BASE_RATE_EVENT_ID) {\n        /* Absolute time variables are only updated when base rate\n           thread is executed, no need to use any lock */\n        real_T   timeInMs = newTime * 1000.0;\n        uint32_T timeInMsL = (uint32_T)fmod(timeInMs, (extmodeSimulationTime_T)MAX_uint32_T + 1);\n        uint32_T timeInMsH = 0;\n\n        if (timeInMs > MAX_uint32_T) {\n            /* cast truncates, rounding to zero */\n            timeInMsH = (uint32_T)(timeInMs / MAX_uint32_T);\n        }\n\n        /* Update absolute simulation time variables */\n        xcpCopyTimeValue(xcpCurrentSimulationTimeInMs, timeInMsL, timeInMsH);\n\n        /* Check if simulation is complete */\n        if ((xcpExtmodeFinalSimulationTime != EXTMODE_SIMULATION_RUN_FOREVER) &&\n            (xcpExtmodeFinalSimulationTime != EXTMODE_SIMULATION_TIME_NOT_INITIALIZED)) {\n            /* By default, assuming EXTMODE_SIMULATION_RUN_FOREVER */\n           xcpExtmodeSimulationComplete = (xcpExtmodeFinalSimulationTime - newTime) <\n                                          (newTime * (DBL_EPSILON));\n        }\n\n        /* Update the current simulation time */\n        xcpBaseRateSimulationTime = newTime;\n    }\n}\n\n/* In addition to updating absolute simulation time variables\n   and detecting if the simulation is actually complete, \n   the function returns the 32bit XCP Timestamp counter value\n   (in XCP_TIMESTAMP_UNITs) corresponding to the given newTime\n\n   Note: the newTime input represents the model simulation time */\nuint32_T xcpExtModeGetUpdatedTimestamp(extmodeSimulationTime_T newTime, extmodeEventId_T eventId)\n{\n    uint32_T timestamp = 0;\n\n    xcpExtModeUpdateTime(newTime, eventId);\n\n    /* Convert the newTime into the 32 bits XCP Timestamp counter, based on XCP configuration */\n    timestamp = (uint32_T)fmod(newTime * (extmodeSimulationTime_T) XCP_TIMESTAMP_UNITS_PER_SECOND + 0.5, \n                              (extmodeSimulationTime_T)MAX_uint32_T + 1);\n\n    return timestamp;\n}\n\n\n#ifdef XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME\n\n/* This function is supposed to return the value of the XCP Timestamp in XCP_TIMESTAMP_UNITs.\n   Specifically it is invoked within the xcpEvent().\n   When XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME is defined, both extmodeEvent() and \n   rtExtModeUpload() use xcpEventExternalTimestamp() instead, so we should never hit this function.\n   However we need to provide a dummy implementation as the function is required by the \n   Platform Abstraction Layer. */\nuint32_T xcpGetTimestamp(void)\n{\n#ifndef EXTMODE_CODE_EXEC_PROFILING\n    return 0;\n#else\n    /* Even if not thread-safe, this implementation has been added for backward compatibility \n       as Code Execution Profiling was invoking the xcpEvent() API directly */\n    return xcpExtModeGetUpdatedTimestamp(xcpBaseRateSimulationTime, EXTMODE_BASE_RATE_EVENT_ID);\n#endif\n}\n\n#endif /* XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME */\n\n#endif /* INTEGER_CODE == 1 */\n\n\nXcpErrorCode xcpExtModeInit(void)\n{\n    int_T parNumber = 0;\n    void **parList = NULL;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    \n#if !defined(INTEGER_CODE) || INTEGER_CODE == 0\n    /* Use dummy variable to prevent optimization in some compilers */\n    xcpDummyDoubleVariable = (extmodeDouble_T) 0;\n#endif\n\n#if defined(INTEGER_CODE) && INTEGER_CODE == 1\n    XCP_MUTEX_INIT(xcpExtModeLock);\n#endif\n\n#ifdef XCP_CUSTOM_ADDRESS_TRANSLATION\n    xcpInitCustomAddressGet();\n#endif\n\n    /* Retrieve XCP Transport Layer initialization parameters */\n    xcpTransportGetInitParameters(&parNumber, &parList);\n\n    /* Initialize XCP Transport Layer */\n    errorCode = xcpTransportInit(parNumber, parList);\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpExtModeInit: xcpTransportInit error\\n\");\n        return errorCode;\n    }\n\n    /* Retrieve XCP Protocol Layer initialization parameters */\n    xcpGetInitParameters(&parNumber, &parList);\n\n    /* Initialize XCP Protocol layer */\n    errorCode = xcpInit(parNumber, parList);\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpExtModeInit: xcpInit error: code %d\\n\", errorCode);\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpExtModeRunBackground(boolean_T flushAllData)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    boolean_T done = false;\n\n    /* Add a dummy delay, that forces the task to pause the execution\n       (leaving the 'running' state). This gives Simulink the opportunity\n       to run when connecting to host-based targets in External Mode */\n    XCP_SLEEP(0, 0);\n\n    do {\n        boolean_T dataAvailable = false;\n\n        /* Retrieve a new Rx packet from interface */\n        errorCode = xcpTransportRx();\n\n        if ((errorCode != XCP_SUCCESS) && (errorCode != XCP_EMPTY)) {\n            XCP_PRINTF(\"xcpExtModeRunBackground: xcpTransportRx error, code %d\\n\", errorCode);\n            done = true;\n        } else {\n            dataAvailable = dataAvailable || (errorCode != XCP_EMPTY);\n        }\n\n        if (!done) {\n            /* Process it within the protocol layer.\n               By checking the return code value, diagnostic info on\n               XCP packet processing can be collected.\n               Every run corresponds to the processing of one single XCP packet */\n            errorCode = xcpRun();\n\n            if ((errorCode != XCP_SUCCESS) && (errorCode != XCP_EMPTY)) {\n                XCP_PRINTF(\"xcpExtModeRunBackground: xcpRun error, code %d\\n\", errorCode);\n                done = true;\n            } else {\n                dataAvailable = dataAvailable || (errorCode != XCP_EMPTY);\n            }\n        }\n\n        if (!done) {\n            /* Send one of the pending Tx packets over the network */\n            errorCode = xcpTransportTx();\n            if ((errorCode != XCP_SUCCESS) && (errorCode != XCP_EMPTY)) {\n                XCP_PRINTF(\"xcpExtModeRunBackground: xcpTransportTx error, code %d\\n\", errorCode);\n                done = true;\n            } else {\n                dataAvailable = dataAvailable || (errorCode != XCP_EMPTY);\n            }\n        }\n\n        if (flushAllData) {\n#if EXTMODE_FLUSH_ALL_DATA_DELAY_TIME_IN_MICROSECONDS > 0\n            /* Dummy delay, that forces the background task to pause the execution\n               and reduces the packets transmission rate, for host-based targets. */\n            XCP_SLEEP(0, EXTMODE_FLUSH_ALL_DATA_DELAY_TIME_IN_MICROSECONDS);\n#endif\n            /* The xcpExtModeRunBackground will continue to process packets until\n               the TX and RX queues are empty or an error occurred. */\n            done = done || !dataAvailable;\n        } else {\n            /* The xcpExtModeRunBackground will only carry out one iteration and then return.\n               The remaining packets will be processed at the next round. */\n            done = true;\n        }\n    } while (!done);\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpExtModeReset(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    extmodeRealTime_T elapsedTime;\n    XcpStatus status;\n\n    if (xcpExtmodeSimulationComplete) {\n        /* When DAQ Packed Mode is enabled, if we reached the nominal end of the\n           simulation we trigger the transmission of a packet containing the samples \n           received so far. The trailing '0's will be removed and not displayed\n           in the output of the simulation */\n        xcpPackedModeEventsFlush(0);\n    }\n\n    /* Wait for the XCP master to complete the clean disconnection procedure */\n    status = xcpGetStatus();\n\n    elapsedTime = 0;\n    while ((elapsedTime < EXTMODE_SHUTDOWN_TIMEOUT_IN_MICROSECONDS) &&\n           (status != XCP_DISCONNECTED)) {\n\n        XCP_SLEEP(0, EXTMODE_RETRY_TIME_IN_MICROSECONDS);\n        elapsedTime += EXTMODE_RETRY_TIME_IN_MICROSECONDS;\n\n        /* Run the XCP Stack to keep the communication 'alive',\n           forcing the flush of all data */\n        xcpExtModeRunBackground(true);\n\n        /* Check the XCP stack status again */\n        status = xcpGetStatus();\n    }\n\n    /* Reset XCP Protocol Layer */\n    errorCode = xcpReset();\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpReset error: code %d\\n\", errorCode);\n    }\n\n    /* Reset XCP Transport Layer */\n    errorCode = xcpTransportReset();\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportReset error: code %d\\n\", errorCode);\n    }\n\n    /* Restore the global variables to the default value */\n#if defined(ON_TARGET_WAIT_FOR_START) && ON_TARGET_WAIT_FOR_START == 1\n    xcpModelStartRequest = false;\n#else\n    xcpModelStartRequest = true;\n#endif\n\n    xcpModelStopRequest = false;\n\n    xcpModelChecksum0   = 0;\n    xcpModelChecksum1   = 0;\n    xcpModelChecksum2   = 0;\n    xcpModelChecksum3   = 0;\n    xcpModelIntegerCode = 0;\n\n#if defined(INTEGER_CODE) && INTEGER_CODE == 1\n    xcpExtmodeFinalSimulationTime = EXTMODE_SIMULATION_RUN_FOREVER;\n\n    xcpBaseRateSimulationTime = 0;\n\n    xcpTicksCounterL = 0;\n    xcpTicksCounterH = 0;\n\n    xcpBaseRateSimulationTimestamp = 0;\n#else\n    xcpExtmodeFinalSimulationTime = EXTMODE_SIMULATION_TIME_NOT_INITIALIZED;\n#endif\n\n    xcpExtmodeSimulationComplete  = false;\n\n#if (defined(INTEGER_CODE) && INTEGER_CODE == 1) || defined(XCP_EXTMODE_SIMULATION_TIME_IN_TICKS)\n    XCP_MEMSET(xcpCurrentSimulationTimeInTicks, 0, sizeof(xcpCurrentSimulationTimeInTicks));\n\n    xcpBaseRateSimulationTime = 0;\n\n    xcpTicksCounterL = 0;\n    xcpTicksCounterH = 0;\n\n    xcpBaseRateSimulationTimestamp = 0;\n#else\n    XCP_MEMSET(xcpCurrentSimulationTimeInMs, 0, sizeof(xcpCurrentSimulationTimeInMs));\n    xcpBaseRateSimulationTime = 0;\n#endif\n\n    return errorCode;\n}\n"},{"name":"xcp_ext_param_default_tcp.c","type":"source","group":"legacy","path":"E:\\Matlab\\toolbox\\coder\\xcp\\src\\target\\ext_mode\\src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2017-2018 The MathWorks, Inc.\n *\n * File: xcp_ext_param_default_tcp.c     \n *\n * Abstract:\n *  The file provides the implementation of the xcp_ext_param.h \n *  interface specific for the XCP Default Platform Abstraction Layer\n *  for the TCP/IP transport layer.\n */\n\n#include \"rtwtypes.h\"\n#include \"rtw_extmode.h\"\n\n#include \"xcp_common.h\"\n#include \"xcp_ext_param.h\"\n\n#ifndef EXTMODE_DISABLE_ARGS_PROCESSING\n\n/* This IDs need to match with the xcpTransportLayerParams below */\ntypedef enum {\n    XCP_PARAM_PORT_ID,\n    XCP_PARAM_PORT_VALUE_ID,\n    XCP_PARAM_BLOCKING_ID,\n    XCP_PARAM_BLOCKING_VALUE_ID,\n    XCP_PARAM_PROTOCOL_ID,\n    XCP_PARAM_PROTOCOL_VALUE_ID,\n    XCP_PARAM_CLIENT_ID,\n    XCP_PARAM_CLIENT_VALUE_ID,\n    XCP_PARAM_VERBOSE_ID,\n    XCP_PARAM_VERBOSE_VALUE_ID\n} XcpTransportLayerParams;\n \n \n /** Transport Layer initialization parameters \n     @note the default values can be overwritten when parsing the\n           External Mode command line arguments */\nstatic const void* xcpTransportLayerParams[] =\n{\n    \"-port\", \"17725\",\n    \"-blocking\", \"0\",\n    \"-protocol\", \"TCP\",\n    \"-client\", \"0\",     /* this is the only setting that cannot be overwritten */\n    \"-verbose\", \"0\",\n};\n\n#endif /* EXTMODE_DISABLE_ARGS_PROCESSING */\n\nvoid xcpExtModeParseArgs(int_T argc, const char_T *argv[])\n{\n#ifdef  EXTMODE_DISABLE_ARGS_PROCESSING\n    /* Some targets do not support command line args */\n    UNUSED_PARAMETER(argc);\n    UNUSED_PARAMETER(argv);\n#else\n    if ((argv != NULL) && (argc > 0)) {\n        int_T optionId = 1;\n\n        while (optionId < argc) {\n            const char_T *option = argv[optionId];\n\n            optionId++;\n\n            if ((option != NULL) && (optionId != argc)) {\n                boolean_T isXcpOption = false;\n\n                if (strcmp(option, xcpTransportLayerParams[XCP_PARAM_PORT_ID]) == 0) {\n                    /* Overwrite \"-port\" value, if specified */\n                    xcpTransportLayerParams[XCP_PARAM_PORT_VALUE_ID] = argv[optionId];\n                    isXcpOption = true;\n                }\n                else if (strcmp(option, xcpTransportLayerParams[XCP_PARAM_BLOCKING_ID]) == 0) {\n                    /* Overwrite \"-blocking\" value, if specified */\n                    xcpTransportLayerParams[XCP_PARAM_BLOCKING_VALUE_ID] = argv[optionId];\n                    isXcpOption = true;\n                }\n                else if (strcmp(option, xcpTransportLayerParams[XCP_PARAM_PROTOCOL_ID]) == 0) {\n                    /* Overwrite \"-protocol\" value, if specified */\n                    xcpTransportLayerParams[XCP_PARAM_PROTOCOL_VALUE_ID] = argv[optionId];\n                    isXcpOption = true;\n                }\n                else if (strcmp(option, xcpTransportLayerParams[XCP_PARAM_VERBOSE_ID]) == 0) {\n                    /* Overwrite \"-verbose\" value, if specified */\n                    xcpTransportLayerParams[XCP_PARAM_VERBOSE_VALUE_ID] = argv[optionId];\n                    isXcpOption = true;\n                }\n\n                if (isXcpOption) {\n                    /* Mark arguments as \"processed\" */\n                    argv[optionId - 1] = NULL;\n                    argv[optionId] = NULL;\n                }\n                \n                optionId++;\n            }\n        }\n    }\n#endif\n}\n\nvoid xcpTransportGetInitParameters(int_T *parNumber, void **parList[])\n{\n#ifdef  EXTMODE_DISABLE_ARGS_PROCESSING\n    if ((parNumber != NULL) && (parList != NULL)) {\n        /* No Transport Layer parameters defined (assuming rtiostream default) */\n        *parNumber = 0;\n        *parList = NULL;\n    }\n#else\n    if ((parNumber != NULL) && (parList != NULL)) {\n        *parNumber = XCP_ELEMENTS_NUMBER(xcpTransportLayerParams);\n        *parList = (void **) &xcpTransportLayerParams;\n    }\n#endif\n}\n\nvoid xcpGetInitParameters(int_T *parNumber, void **parList[])\n{\n    if ((parNumber != NULL) && (parList != NULL)) {\n        /* No Protocol Layer parameters available at the moment */\n        *parNumber = 0;\n        *parList = NULL;\n    }\n}\n\n\n"},{"name":"xcp_ext_work.c","type":"source","group":"legacy","path":"E:\\Matlab\\toolbox\\coder\\xcp\\src\\target\\ext_mode\\src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2017-2021 The MathWorks, Inc.\n *\n * File: xcp_ext_work.c     \n *\n * Abstract:\n *  The file provides the \"XCP version\" of the ext_work.h APIs \n */\n\n#if !defined(EXTMODE_DISABLEPRINTF) || !defined(EXTMODE_DISABLE_ARGS_PROCESSING)\n#include <stdio.h>\n#endif\n\n#include <stdlib.h>        /* for exit() */\n#include <string.h>        /* optional for strcmp */\n#include <math.h>\n\n#include \"xcp_ext_common.h\"\n#include \"xcp_ext_param.h\"\n#include \"xcp_internal.h\"\n\n#include \"ext_types.h\"\n#include \"rtw_extmode.h\"\n\n#include \"ext_work.h\" /* includes all VxWorks headers */\n\n\n#ifdef EXTMODE_XCP_TRIGGER_SUPPORT\n\n#include \"xcp_ext_classic_trigger.h\"\n\n#endif\n\n\n\n/* Function ====================================================================\n * Pause the process (w/o hogging the cpu) until the XCP Master has modified the\n * xcpModelStartRequest value to true or until we are no longer in the paused state.  \n * The XCP stack must continue to process events (otherwise the host would not \n * be able to communicate with the target).\n */\nvoid rtExtModePauseIfNeeded(RTWExtModeInfo *ei,\n    int_T          numSampTimes,\n    boolean_T      *stopReqPtr)\n{\n    XCP_UNUSED_PARAM(ei);\n    XCP_UNUSED_PARAM(numSampTimes);\n\n    if (stopReqPtr == NULL) {\n        XCP_PRINTF(\"rtExtModePauseIfNeeded error: invalid stopReqPtr\\n\");\n        return;\n    }\n\n    while ((xcpModelStatus == XCP_EXTMODE_STATUS_PAUSED) && !xcpModelStartRequest && !(*stopReqPtr)) {\n        XCP_SLEEP(0, EXTMODE_RETRY_TIME_IN_MICROSECONDS);\n        xcpExtModeRunBackground(DEFAULT_XCP_EXTMODE_RUN_BACKGROUND_FLUSH);\n        *stopReqPtr = xcpModelStopRequest;\n    }\n\n    xcpModelStartRequest = false; /* reset to false - if we were stepped we want to\n                                   *                  stop again next time we get\n                                   *                  back here.\n                                   */\n} /* end rtExtModePauseIfNeeded */\n\n/* Function ====================================================================\n * Pause the process (w/o hogging the cpu) until the XCP Master has modified the\n * xcpModelStart value to true.  \n * The XCP stack must continue to process events (otherwise the host would not \n * be able to communicate with the target)\n */\nvoid rtExtModeWaitForStartPkt(RTWExtModeInfo *ei,\n                              int_T          numSampTimes,\n                              boolean_T      *stopReqPtr)\n{\n    XCP_UNUSED_PARAM(numSampTimes);\n\n    if (stopReqPtr == NULL) {\n        XCP_PRINTF(\"rtExtModeWaitForStartPkt error: invalid stopReqPtr\\n\");\n        return;\n    }\n\n    xcpModelStatus = XCP_EXTMODE_STATUS_WAITING_TO_START;\n    \n    /* Initialize the model checksum information */\n    xcpModelChecksum0 = rteiGetChecksum0(ei);\n    xcpModelChecksum1 = rteiGetChecksum1(ei);\n    xcpModelChecksum2 = rteiGetChecksum2(ei);\n    xcpModelChecksum3 = rteiGetChecksum3(ei);\n\n#if defined(INTEGER_CODE) && INTEGER_CODE == 1\n    xcpModelIntegerCode = 1;\n#else\n    xcpModelIntegerCode = 0;\n#endif\n\n    /*\n     * Pause until the XCP master modifies the xcpModelStartRequest value\n     */\n    while(!xcpModelStartRequest && !(*stopReqPtr)) {\n        XCP_SLEEP(0L, EXTMODE_RETRY_TIME_IN_MICROSECONDS);\n        xcpExtModeRunBackground(DEFAULT_XCP_EXTMODE_RUN_BACKGROUND_FLUSH);\n        *stopReqPtr = xcpModelStopRequest;\n    }\n    if (xcpModelStatus != XCP_EXTMODE_STATUS_PAUSED) {\n        xcpModelStatus = XCP_EXTMODE_STATUS_READY_TO_RUN;\n    } else {\n        /* leave in pause mode */\n    }\n}\n\nvoid rtExtModeOneStep(RTWExtModeInfo *ei,\n                      int_T          numSampTimes,\n                      boolean_T      *stopReqPtr)\n{\n    UNUSED_PARAMETER(ei);\n    UNUSED_PARAMETER(numSampTimes);\n\n    if (stopReqPtr == NULL) {\n        XCP_PRINTF(\"rtExtModeOneStep error: invalid stopReqPtr\\n\");\n        return;\n    }\n\n    /*\n     * Call the XCP background task\n     */\n    if (xcpModelStatus != XCP_EXTMODE_STATUS_PAUSED) {\n        xcpExtModeRunBackground(DEFAULT_XCP_EXTMODE_RUN_BACKGROUND_FLUSH);\n        *stopReqPtr = xcpModelStopRequest;\n    }\n}\n\nvoid rtExtModeUpload(int_T tid, real_T taskTime)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    extmodeEventId_T eventId = 0;\n    extmodeSimulationTime_T simulationTime = (extmodeSimulationTime_T)  taskTime;\n    boolean_T triggerEnable = true;\n\n    if ((tid < 0) || (tid > EXTMODE_MAX_EVENT_ID)) {\n        XCP_PRINTF(\"rtExtModeUpload error: invalid tid (%d)\\n\", tid);\n        return;\n    }\n\n    if ((xcpModelStatus == XCP_EXTMODE_STATUS_READY_TO_RUN) ||\n        (xcpModelStatus == XCP_EXTMODE_STATUS_INITIALIZED)) {\n        /* Update model status, as soon as the rtExtModeUpload() gets invoked */\n        xcpModelStatus = XCP_EXTMODE_STATUS_RUNNING;\n    }    \n    \n    eventId = (extmodeEventId_T) tid;\n\n#ifdef EXTMODE_XCP_TRIGGER_SUPPORT\n    {\n        XcpStatus xcpStatus = xcpGetStatus();\n        if (xcpStatus == XCP_SYNC_DATA_TRANSFER) {\n            triggerEnable = xcpExtModeClassicTriggerEnabled(eventId);\n        }\n    }\n#endif\n\n    {\n#ifdef XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME\n        /* Update local absolute time variables*/\n        uint32_T timestampBasedOnSimTime = xcpExtModeGetUpdatedTimestamp(simulationTime, eventId);\n#else\n        /* Update local absolute time variables*/\n        xcpExtModeUpdateTime(simulationTime, eventId);\n#endif\n\n        if (triggerEnable) {\n#ifdef XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME\n            /* Notify XCP Stack about the eventId */\n            errorCode = xcpEventExternalTimestamp(eventId, timestampBasedOnSimTime);\n#else\n            /* Notify XCP Stack about the eventId, using the timestamp read\n           from the HW timer supported by XCP Platform Abstraction layer */\n            errorCode = xcpEvent(eventId);\n#endif\n        } else {\n            /* reset pending packed DAQ lists if the trigger did not fire so that we do not send\n               packets with non-consecutive samples */\n            xcpPackedModeEventReset(eventId);\n        }\n    }\n\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"rtExtModeUpload error: code %d\\n\", errorCode);\n    }\n}\n\nvoid rtExtModeCheckEndTrigger(void)\n{\n}\n\nvoid rtExtModeUploadCheckTrigger(int_T numSampTimes)\n{\n    UNUSED_PARAMETER(numSampTimes);\n}\n\nvoid rtExtModeCheckInit(int_T numSampTimes)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    UNUSED_PARAMETER(numSampTimes);\n\n#ifdef EXTMODE_XCP_TRIGGER_SUPPORT\n    xcpExtModeClassicTriggerInit();\n#endif\n\n    /* Initialize the platform abstraction layer common services */\n    errorCode = xcpExtModeInit();\n\n    if (errorCode != XCP_SUCCESS) {\n        exit(EXIT_FAILURE);\n    }\n    \n    xcpModelStatus = XCP_EXTMODE_STATUS_INITIALIZED;\n}\n\nvoid rtExtModeShutdown(int_T numSampTimes)\n{\n    UNUSED_PARAMETER(numSampTimes);\n\n    xcpModelStatus = XCP_EXTMODE_STATUS_RESETTING;\n\n    xcpExtModeReset();\n\n#ifdef EXTMODE_XCP_TRIGGER_SUPPORT\n    xcpExtModeClassicTriggerReset();\n#endif\n    \n    xcpModelStatus = XCP_EXTMODE_STATUS_RESET;\n}\n\nvoid rtExtModeParseArgs(int_T        argc, \n                        const char_T *argv[],\n                        real_T       *unused)\n{\n    UNUSED_PARAMETER(unused);\n\n#ifdef  EXTMODE_DISABLE_ARGS_PROCESSING\n\n    /* Some targets do not support command line args */\n    UNUSED_PARAMETER(argc);\n    UNUSED_PARAMETER(argv);\n\n#else   \n\n    {/* Extract the \"-w\" option (wait for packet from host), if present.\n        Note: in Classic External mode this parameter is handled within rtiostream_interface.c,\n        but this file is no longer present in XCP-based External Mode.\n        Let all the remaining parameters pass through to XCP-based external mode for parsing.  \n        NULL out the \"-w\" argument so that it can then be ignored once handled. */\n        int_T  count = 1;\n\n        while (count < argc) {\n            const char_T *option = argv[count++];\n\n            if ((option != NULL) && (strcmp(option, \"-w\") == 0)) {\n                xcpModelStartRequest = false;\n                argv[count - 1] = NULL;\n            }\n        }\n    }\n\n    /* Extract XCP specific initialization parameters */\n    xcpExtModeParseArgs(argc, argv);\n\n#endif  /* EXTMODE_DISABLE_ARGS_PROCESSING */\n}\n\n/* Start of ERT specific functions and data \n   @note even with the XCP-based solution the \"Classic External Mode\" \n         command line interface is still valid */\n\n\n#ifndef  EXTMODE_DISABLE_ARGS_PROCESSING\n\nstatic void displayUsage(void)\n{\n    XCP_PRINTF(\"usage: model_name -tf <finaltime> -w -port <TCPport>\\n\");\n    XCP_PRINTF(\"arguments:\\n\");\n    XCP_PRINTF(\"  -tf <finaltime> - overrides final time specified in \"\n               \"Simulink (inf for no limit).\\n\");\n    XCP_PRINTF(\"  -w              - waits for Simulink to start model \"\n               \"in External Mode.\\n\");\n    XCP_PRINTF(\"  -port <TCPport> - overrides 17725 default port in \"\n                  \"External Mode, valid range 256 to 65535.\\n\");\n}\n\n#endif /* EXTMODE_DISABLE_ARGS_PROCESSING */\n\nvoid rtERTExtModeSetTFinal(real_T *rtmTFinal)\n{\n    if (xcpExtmodeFinalSimulationTime != EXTMODE_SIMULATION_TIME_NOT_INITIALIZED) {\n        *rtmTFinal = (real_T) xcpExtmodeFinalSimulationTime;\n    } else {\n#if (defined(INTEGER_CODE) && INTEGER_CODE == 1)  || defined(XCP_EXTMODE_SIMULATION_TIME_IN_TICKS)\n        /* If the model final simulation time in External Mode has NOT been initialized,\n           then EXTMODE_SIMULATION_RUN_FOREVER is assumed, as the Real-time Model\n           structure doesn't contain any final time information when PurelyIntegerCode\n           is selected */\n        xcpExtmodeFinalSimulationTime = EXTMODE_SIMULATION_RUN_FOREVER;\n#else\n        /* If the model final simulation time in External Mode has NOT been initialized,\n           then the finalTime argument is considered an INPUT */\n        xcpExtmodeFinalSimulationTime = *rtmTFinal;\n#endif\n    }\n}\n\nvoid rtSetTFinalForExtMode(real_T *rtmTFinal)\n{\n    rtERTExtModeSetTFinal(rtmTFinal);\n}\n\nvoid rtParseArgsForExtMode(int_T        argc, \n                           const char_T *argv[])\n{\n#ifdef  EXTMODE_DISABLE_ARGS_PROCESSING\n\n    /* Some targets do not support command line args */\n    UNUSED_PARAMETER(argc);\n    UNUSED_PARAMETER(argv);\n\n#else    \n\n    /* parse command line args */\n    int_T  oldStyle_argc;\n    const char_T *oldStyle_argv[5];\n\n    if ((argc > 1) && (argv[1][0] != '-')) {\n        /* at least one command line argument has been provided without\n           specifying an option with '-', using the old style */\n        if ( argc > 3 ) {\n            displayUsage();\n            exit(EXIT_FAILURE);\n        }\n\n        /* using the old style the first argument is always the final time */\n        oldStyle_argc = 3;\n        oldStyle_argv[0] = argv[0];\n        oldStyle_argv[1] = \"-tf\";\n        oldStyle_argv[2] = argv[1];\n\n        if (argc == 3) {\n            oldStyle_argc = 5;\n\n            oldStyle_argv[3] = \"-port\";\n            oldStyle_argv[4] = argv[2];\n        }\n\n        argc = oldStyle_argc;\n        argv = oldStyle_argv;\n    }\n\n    {\n        /* new style: */\n    \textmodeSimulationTime_T  timeValue = 0;\n        char_T tmpStr2[200];\n        int_T  count      = 1;\n        int_T  parseError = false;\n\n        /*\n         * Parse the standard RTW parameters.  Let all unrecognized parameters\n         * pass through to external mode for parsing.  NULL out all args handled\n         * so that the external mode parsing can ignore them.\n         */\n        while (count < argc) {\n            const char_T *option = argv[count++];\n\n            if (option != NULL) {\n                /* final time */\n                if ((strcmp(option, \"-tf\") == 0) && (count != argc)) {\n                    const char_T *tfStr = argv[count++];\n\n                    sscanf(tfStr, \"%200s\", tmpStr2);\n                    if (strcmp(tmpStr2, \"inf\") == 0) {\n                        timeValue = EXTMODE_SIMULATION_RUN_FOREVER;\n                    }\n                    else {\n                        char_T tmpstr[2];\n#if defined(INTEGER_CODE) && INTEGER_CODE == 1\n                        int tmpValue;\n\n                        if ((sscanf(tmpStr2, \"%d%1s\", &tmpValue, tmpstr) != 1) ||\n                            (tmpValue < 0)) {\n                            XCP_PRINTF(\"External mode final simulation time must be a positive, integer value or inf\\n\");\n                            parseError = true;\n                            break;\n                        }\n                        timeValue = (extmodeSimulationTime_T) tmpValue;\n#else\n                        if ((sscanf(tmpStr2, \"%lf%1s\", &timeValue, tmpstr) != 1) ||\n                            (timeValue < (real_T)0)) {\n                            XCP_PRINTF(\"External mode final simulation time must be a positive, real value or inf\\n\");\n                            parseError = true;\n                            break;\n                        }\n#endif\n                    }\n                    xcpExtmodeFinalSimulationTime = timeValue;\n\n                    argv[count - 2] = NULL;\n                    argv[count - 1] = NULL;\n                }\n                /* -w (wait for packet from host) option */\n                else if (strcmp(option, \"-w\") == 0) {\n                    xcpModelStartRequest = false;\n                    argv[count - 1] = NULL;\n                }\n            }\n        }\n\n        if (parseError) {\n            XCP_PRINTF(\"\\nUsage: model_name -option1 val1 -option2 val2 -option3 \"\n                       \"...\\n\\n\");\n#if defined(INTEGER_CODE) && INTEGER_CODE == 1\n            XCP_PRINTF(\"\\t-tf 20 - sets final time to 20 ticks\\n\");\n#else\n            XCP_PRINTF(\"\\t-tf 20 - sets final time to 20 seconds\\n\");\n#endif\n            exit(EXIT_FAILURE);\n        }\n\n        /* Extract XCP specific initialization parameters */\n        xcpExtModeParseArgs(argc, argv);\n\n        /*\n         * Check for unprocessed (\"unhandled\") args.\n         */\n        {\n            int i;\n            for (i=1; i<argc; i++) {\n                if (argv[i] != NULL) {\n                    XCP_PRINTF(\"Unexpected command line argument: %s\\n\", argv[i]);\n                    exit(EXIT_FAILURE);\n                }\n            }\n        }\n    }\n\n    if (xcpExtmodeFinalSimulationTime == EXTMODE_SIMULATION_RUN_FOREVER) {\n        XCP_PRINTF(\"\\n**warning: the simulation will run with no stop time due \"\n                   \"to external mode with '-tf inf' argument.\\n\");\n    }\n\n#endif /* EXTMODE_DISABLE_ARGS_PROCESSING */\n}\n\nvoid rtERTExtModeStartMsg(void)\n{\n    XCP_PRINTF(\"\\n** starting the model **\\n\");\n}\n\n/* End of ERT specific functions and data */\n\n/* [EOF] xcp_ext_work.c */\n"},{"name":"xcp_fifo.c","type":"source","group":"legacy","path":"E:\\Matlab\\toolbox\\coder\\xcp\\src\\target\\slave\\transport\\src","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2020 The MathWorks, Inc.\n*\n* File: xcp_fifo.c\n*\n* Abstract:\n*  Implementation of FIFO data structure based on single linked list\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp_fifo.h\"\n\n\nvoid xcpFifoInit(struct xcpFifo * fifo)\n{\n    fifo->first = NULL;\n    fifo->last = &(fifo)->first;\n}\n\n\nvoid xcpFifoEnqueue(struct xcpFifo *fifo, struct xcpFifoEntry *element)\n{\n    element->next = NULL;\n    *(fifo)->last = element;\n    fifo->last = &(element->next);\n}\n\n\nvoid xcpFifoDequeue(struct xcpFifo *fifo, struct xcpFifoEntry **element)\n{\n    *element = fifo->first;\n\n    if (fifo->first != NULL) {\n        fifo->first = fifo->first->next;\n\n        if (fifo->first == NULL)\n            fifo->last = &(fifo)->first;\n    }\n}\n\n\nvoid xcpFifoEnqueueHead(struct xcpFifo *fifo, struct xcpFifoEntry *element)\n{\n    element->next = (fifo)->first;\n\n    if ((fifo)->first == NULL) {\n        (fifo)->last = &(element->next);\n    }\n\n    (fifo)->first = element;\n}\n\n\nvoid xcpFifoSpliceHead(struct xcpFifo *dstFifo, struct xcpFifo *srcFifo)\n{\n    if (srcFifo->first != NULL) {\n        *(srcFifo->last) = dstFifo->first;\n        dstFifo->first = srcFifo->first;\n         \n        srcFifo->first = NULL;\n        srcFifo->last = &(srcFifo)->first;\n    }\n}\n\n\nboolean_T xcpFifoEmpty(struct xcpFifo *fifo)\n{\n    return ((fifo)->first == NULL);\n}\n\n\nvoid xcpFifoReset(struct xcpFifo * fifo)\n{\n    xcpFifoInit(fifo);\n}\n"},{"name":"xcp_frame_tcp.c","type":"source","group":"legacy","path":"E:\\Matlab\\toolbox\\coder\\xcp\\src\\target\\slave\\transport\\src","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2021 The MathWorks, Inc.\n*\n* File: xcp_frame_tcp.c\n*\n* Abstract:\n*  XCP Frame Handler implementation for TCP/IP transport layer.\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp.h\"\n#include \"xcp_frame.h\"\n#include \"xcp_frame_tcp.h\"\n#include \"xcp_drv.h\"\n#include \"xcp_mem.h\"\n#include \"xcp_types.h\"\n\n/* Frame Handler internal counters */\nstatic uint16_T txCounter = 0;\nstatic uint16_T rxCounter = 0;\nstatic int      firstRxCounterReceived = 0;\n\n/* true if the Frame Handler has been successfully initialized */\nstatic boolean_T initialized = false;\n\n/* ID for of the memory pool reserved for the allocation of\n    CTO XCP Packets */\nstatic xcpPoolId_T xcpCtoReservedMemPoolId = -1;\n\n#if XCP_HARDWARE_ADDRESS_GRANULARITY != XCP_ADDRESS_GRANULARITY_BYTE\n    #error \"TCP/IP transport is not supported on 16/32-bit word targets\"\n#endif\n\nuint16_T xcpTcpHtons(uint16_T hostShort)\n{\n#ifndef XCP_BIG_ENDIAN\n    return hostShort;\n#else\n    return ((hostShort & 0xFF00) >> 8) | ((hostShort & 0x00FF) << 8);\n#endif\n}\n\n\nuint16_T xcpTcpNtohs(uint16_T networkShort)\n{\n    return xcpTcpHtons(networkShort);\n}\n\n\nXcpErrorCode xcpFrameInit(\n    int   argc,   /**< [in] number of init parameters              */\n    void *argv[]  /**< [in] array of parameters values (C strings) */\n    )\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    XCP_ERROR_IF(initialized, XCP_ERROR, \"xcpFrameInit: frame handler already initialized\\n\");\n\n    /* Open the XCP driver */\n    errorCode = xcpDrvOpen(argc, argv);\n    if (errorCode == XCP_SUCCESS) {\n        txCounter = 0;\n        rxCounter = 0;\n        firstRxCounterReceived = 0;\n\n        initialized = true;\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpFrameMsgSend(\n    void    *msgBuffer,  /**< [in] pointer to the base address of the buffer where the message is stored */\n    size_t   msgOffset,  /**< [in] offset (from base address) where the XCP message frame is stored */\n    size_t   msgSize     /**< [in] size (in bytes) of the XCP message frame */\n    )\n{\n    uint8_T *msg = NULL;\n    struct XcpHeader *header = NULL;\n    uint16_T length = 0;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    XCP_ERROR_IF(msgBuffer == NULL, XCP_INV_ARG, \"xcpFrameMsgSend: invalid msgBuffer\\n\");\n    XCP_ERROR_IF(msgSize < sizeof(struct XcpHeader), XCP_INV_ARG, \"xcpFrameMsgSend: invalid msgSize\\n\");\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpFrameMsgSend: frame handler not initialized\\n\");\n\n    msg = (uint8_T *) msgBuffer + msgOffset;\n\n    header = (struct XcpHeader *) msg;\n    length = xcpTcpNtohs(header->length);\n\n    if ((length == 0) || (msgSize < (sizeof(*header) + length))) {\n        XCP_PRINTF(\"xcpFrameMsgSend: invalid message format detected\\n\");\n        return XCP_INV_MSG_FORMAT;\n    }\n\n    /* Set the value of the transport layer txCounter immediately before\n     * sending the message so that it reflects the correct order for the\n     * sequence of frames that are sent rather than the sequence in which\n     * they are constructed (which could be different in the case where\n     * there are multiple prioritized queues). */\n    header->counter = xcpTcpHtons(txCounter);\n    \n    /* Send the full message or nothing\n     * If the xcpDrvSend() is blocking, the return code should be XCP_SUCCESS\n     * If the xcpDrvSend() is non-blocking, the return code could be XCP_SUCCESS or XCP_BUSY.\n     * If something went wrong we should get XCP_ERROR or XCP_PKT_TX_TIMEOUT_ERROR */\n    errorCode = xcpDrvSend(msg, msgSize);\n\n    /* If successfully sent, the buffer can be freed */\n    if (errorCode == XCP_SUCCESS) {\n        xcpMemFree(msgBuffer);        \n    }\n    \n    /* Don't increment the counter if the transfer of the packet is delayed\n     * due to the transport layer being busy. */\n    if (errorCode != XCP_BUSY) {\n        txCounter++;\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpFrameMsgRecv(\n    void  **msgBuffer,  /**< [out] pointer to the base address of the buffer where the message is stored */\n    size_t  msgOffset,  /**< [in] offset (from base address) where the XCP message frame is stored */\n    size_t *msgSize     /**< [out] size (in bytes) of the XCP message frame that has been received */\n    )\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    struct RxXcpHeader rxHeader;\n    uint16_T length = 0;\n    uint8_T *buffer;\n    uint8_T *bufferPtr;\n\n    XCP_ERROR_IF(msgBuffer == NULL, XCP_INV_ARG, \"xcpFrameMsgRecv: invalid msgBuffer pointer\\n\");\n    XCP_ERROR_IF(msgSize == NULL, XCP_INV_ARG, \"xcpFrameMsgRecv: invalid msgSize pointer\\n\");\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpFrameMsgRecv: frame handler not initialized\\n\");\n\n    /* Receive message header first.\n     * If the xcpDrvRecv() is blocking, the return code should be XCP_SUCCESS\n     * If the xcpDrvRecv() is non-blocking, the return code could be XCP_SUCCESS or XCP_EMPTY\n     * If something went wrong we should get XCP_ERROR or XCP_PKT_RX_TIMEOUT_ERROR */\n    errorCode = xcpDrvRecv(&rxHeader, sizeof(rxHeader));\n    if (errorCode != XCP_SUCCESS) {\n        return errorCode;\n    }\n\n    length = xcpTcpNtohs(rxHeader.header.length);\n\n    if (length == 0) {\n        XCP_PRINTF(\"xcpFrameMsgRecv: invalid message format detected\\n\");\n        errorCode = XCP_INV_MSG_FORMAT;\n        return errorCode;\n    }\n\n    /* Request to the XCP allocator the memory for the message to be received */\n    if ((rxHeader.PID >= XCP_COMMAND_PACKETS_ID_MIN) &&\n        (xcpCtoReservedMemPoolId >= 0)) {\n        buffer = xcpMemAllocFromPool(xcpCtoReservedMemPoolId, msgOffset + sizeof(rxHeader.header) + length);\n    } else {\n        buffer = xcpMemAlloc(msgOffset + sizeof(rxHeader.header) + length);\n    }\n\n    if (buffer == NULL) {\n        errorCode = XCP_NO_MEMORY;\n        return errorCode;\n    }\n\n    bufferPtr = buffer;\n\n    /* Initialize the header part */\n    XCP_MEMSET(bufferPtr, 0, msgOffset);\n    bufferPtr += msgOffset;\n\n    XCP_MEMCPY(bufferPtr, &rxHeader, sizeof(rxHeader));\n    bufferPtr += sizeof(rxHeader);\n\n    if (length > sizeof(rxHeader.PID)) {\n        /* Receive the remaining part of the XCP packet\n         * Since have already started receiving the packet, we should wait\n         * until the remaining part is received, or a XCP_PKT_RX_TIMEOUT_ERROR has occurred.\n         * For this reason we force the subsequent xcpDrvRecv to be blocking */\n        xcpDrvIoctl(XCP_DRV_FORCE_BLOCKING);\n\n        errorCode = xcpDrvRecv(bufferPtr, length - sizeof(rxHeader.PID));\n\n        /* The packet has been received, or an error occurred.\n         * In any case we can restore the default blocking/non-blocking behavior */\n        xcpDrvIoctl(XCP_DRV_RESTORE_DEFAULT_BLOCKING_SETUP);\n\n        if (errorCode != XCP_SUCCESS){\n            /* XCP Header and XCP Packet should be in the same TCP/IP packet */\n            XCP_PRINTF(\"xcpFrameMsgRecv: received XCP header, but XCP packet is not available or packet size is incorrect\\n\");\n            errorCode = XCP_INV_MSG_FORMAT;\n            goto rxError;\n        }\n    }\n\n    *msgBuffer = buffer;\n    *msgSize = sizeof(rxHeader.header) + length;\n\n    return errorCode;\n\nrxError:\n    *msgBuffer = NULL;\n    *msgSize = 0;\n    xcpMemFree(buffer);\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpFrameCreateMsg(\n    void        *msgFrame,           /**< [out] pointer to the buffer containing the full message frame */\n    size_t       msgFrameBufferSize, /**< [in]  max size (in bytes) of the buffer where the message frame is copied */\n    size_t      *msgFrameSize,       /**< [out] size (in bytes) of the generated msg frame */\n    size_t       xcpPacketSize       /**< [in]  size (in bytes) of the XCP packet */\n    )\n{\n    struct XcpHeader *header = (struct XcpHeader *) msgFrame;\n\n    /* Input parameters validation */\n    XCP_ERROR_IF(msgFrame == NULL, XCP_INV_ARG, \"xcpFrameCreateMsg: invalid msgFrame buffer\\n\");\n    XCP_ERROR_IF(msgFrameSize == NULL, XCP_INV_ARG, \"xcpFrameCreateMsg: invalid msgFrameSize pointer\\n\");\n    XCP_ERROR_IF(xcpPacketSize == 0, XCP_INV_ARG, \"xcpFrameCreateMsg: invalid xcpPacketSize\\n\");\n    XCP_ERROR_IF(msgFrameBufferSize < (xcpPacketSize + sizeof(struct XcpHeader)), XCP_INV_ARG, \"xcpFrameCreateMsg: invalid msgFrameBufferSize\\n\");\n\n    /* update XCP header */\n    header->length = xcpTcpHtons((uint16_T)xcpPacketSize);\n    \n    *msgFrameSize = xcpPacketSize + sizeof(struct XcpHeader);\n\n    return XCP_SUCCESS;\n}\n\n\nXcpErrorCode xcpFrameExtractPacket(\n    const void  *msgFrame,      /**< [in]  pointer to the buffer containing full message frame content */\n    size_t       msgFrameSize,  /**< [in]  size (in bytes) of the full message frame */\n    size_t      *xcpPacketSize  /**< [out] size (in bytes) of the XCP packet that has been processed */\n    )\n{\n    const struct XcpHeader *header = (const struct XcpHeader *) msgFrame;\n    uint16_T length = 0;\n    uint16_T counter = 0;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    /* Input parameters validation */\n    XCP_ERROR_IF(msgFrame == NULL, XCP_INV_ARG, \"xcpFrameExtractPacket: invalid msgFrame\\n\");\n    XCP_ERROR_IF(xcpPacketSize == NULL, XCP_INV_ARG, \"xcpFrameExtractPacket: invalid xcpPacketSize pointer\\n\");\n    XCP_ERROR_IF(msgFrameSize <= sizeof(struct XcpHeader), XCP_INV_ARG, \"xcpFrameExtractPacket: invalid msgFrameSize\\n\");\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpFrameExtractPacket: frame handler not initialized\\n\");\n\n    /* Extract info from the received message */\n    length = xcpTcpNtohs(header->length);\n    counter = xcpTcpNtohs(header->counter);\n\n    /* Check message length */\n    if (msgFrameSize != (length + sizeof(struct XcpHeader))) {\n        XCP_PRINTF(\"xcpFrameExtractPacket: Xcp packet has an invalid size\\n\");\n        return XCP_INV_MSG_FORMAT;\n    }\n\n    /* Check message counter */\n    if (!firstRxCounterReceived) {\n        /* initialize the rxCounter with the first value received from the Master */\n        rxCounter = counter;\n        firstRxCounterReceived = 1;\n    }\n    else {\n        if (counter < (rxCounter + 1)) {\n            errorCode = XCP_PKT_OUT_OF_SEQUENCE;\n        }\n        else if (counter >(rxCounter + 1)) {\n            errorCode = XCP_PKT_LOST;\n        }\n\n        rxCounter = counter;\n    }\n\n    *xcpPacketSize = length;\n\n    return errorCode;\n}\n\n\nsize_t xcpFrameHeaderSize(void)\n{\n    return sizeof(struct XcpHeader);\n}\n\n\nsize_t xcpFrameTailSize(void)\n{\n    return 0;\n}\n\n\nsize_t xcpFrameMaxDtoSize(void)\n{\n    return XCP_MAX_DTO_SIZE;\n}\n\n\nsize_t xcpFrameMaxCtoSize(void)\n{\n    return XCP_MAX_CTO_SIZE;\n}\n\n\nXcpErrorCode xcpFrameRestart(void)\n{\n    txCounter = 0;\n    rxCounter = 0;\n    firstRxCounterReceived = 0;\n\n    return XCP_SUCCESS;\n}\n\n\nvoid xcpFrameSetCtoReservedMemPoolId(xcpPoolId_T poolId)\n{\n    xcpCtoReservedMemPoolId = poolId;\n}\n\n\nXcpErrorCode xcpFrameReset(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    if (!initialized) {\n        XCP_PRINTF(\"xcpFrameReset: frame handler already reset\\n\");\n        return XCP_SUCCESS; /* Nothing to do: just printing out a warning message*/\n    }\n\n    /* Close the actual communication channel */\n    errorCode = xcpDrvClose();\n    if (errorCode == XCP_SUCCESS) {\n        txCounter = 0;\n        rxCounter = 0;\n        firstRxCounterReceived = 0;\n\n        initialized = false;\n    } else {\n        XCP_PRINTF(\"xcpFrameReset: xcpDrvClose error\\n\");\n    }\n\n    return errorCode;\n}\n"},{"name":"xcp_mem_default.c","type":"source","group":"legacy","path":"E:\\Matlab\\toolbox\\coder\\xcp\\src\\target\\slave\\platform\\default","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2021 The MathWorks, Inc.\n*\n* File: xcp_mem_default.c\n*\n* Abstract:\n*  Implementation of default XCP Slave memory allocator\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp_mem.h\"\n#include \"xcp_mem_default.h\"\n\n#define PADDING (XCP_MEM_ALIGNMENT-1)\n\n/* Array of XcpMemPoolDescriptor for each block size to allow freeing and\n   allocating blocks.\n\n   @note this includes both the Main Memory area and the Reserved Pools\n         Memory Area */\nstatic XcpMemPoolDescriptor xcpMemPoolDescriptors[XCP_MEM_MAIN_RESERVED_POOL_NUMBER];\n\n/* xcpMemCustomPoolDescriptor stores the custom memory functions to allocate and\n   free memory for a specific memory pool */\nstatic XcpMemCustomPoolDescriptor xcpMemCustomPoolDescriptors[XCP_MEM_CUSTOM_POOL_MAX_NUMBER];\n\n\n/* Main memory chunk from which blocks are allocated using the xcpMemAlloc\n * This may not be aligned to XCP_MEM_ALIGNMENT depending on the compiler \n * and/or build flags.\n * Add padding bytes to the end to enable aligning blocks in xcpMemMainChunk\n * to aligned addresses if needed.\n */\nXCP_MEM_DATA_SECTION_BEGIN\nstatic uint8_T xcpMemMainChunk[XCP_MEM_MAIN_TOTAL_SIZE + PADDING];\nXCP_MEM_DATA_SECTION_END\n\n\n/* Reserved pools memory chunk from which pool blocks are allocated using the\n * xcpMemAllocFromPool()\n * Also refer to comments in xcpMemMainChunk\n */\nXCP_MEM_DATA_SECTION_BEGIN\nstatic uint8_T xcpMemReservedPoolsChunk[XCP_MEM_RESERVED_POOLS_TOTAL_SIZE + PADDING];\nXCP_MEM_DATA_SECTION_END\n\nstatic size_t  xcpMemReservedPoolsChunkUsedBytes;\n\n/* Mutex to prevent concurrent access to xcpMemPoolDescriptors, xcpMemMainChunk\n   and xcpMemReservedPoolsChunk\n   @note: the insertion/removal of blocks within each reserved pool is protected by a dedicated\n          lock, to reduce the interference between threads in multi-core applications */\nstatic XCP_MUTEX_DEFINE(xcpMemLock);\n\n\n/* Initialize pool's memory chunk, by creating the pool's memory blocks and as a linked list */\nstatic void xcpInitializePoolMemoryArea(uint8_T *memoryPtr, size_t blockSize, size_t blocksNumber)\n{\n    if (memoryPtr != NULL) {\n        XcpMemHeader *p, *prev = NULL;\n        size_t i;\n        /* Initialize memory to zero */\n        size_t totSize = XCP_MEM_BLOCK_SIZE_WITH_OVERHEAD(blockSize) * blocksNumber;\n        XCP_MEMSET(memoryPtr,  0, totSize);\n\n        for(i = 0 ; i < blocksNumber; ++i) {\n            p = (XcpMemHeader*) memoryPtr;\n            p -> next = NULL;\n            p -> poolId = XCP_FREE_POOL_ID;\n            if (prev) {\n                prev -> next = p;\n            }\n            memoryPtr += XCP_MEM_BLOCK_SIZE_WITH_OVERHEAD(blockSize);\n            prev = p;\n        }\n    }\n}\n\n\nXcpErrorCode xcpMemInit(void)\n{\n    uint8_T poolIdx;\n    uint8_T *memoryPtr = (uint8_T *)XCP_ALIGNED(xcpMemMainChunk);\n\n    XCP_MUTEX_INIT(xcpMemLock);\n\n    /* Initialize Main memory */\n    for(poolIdx = 0; poolIdx < XCP_MEM_MAIN_POOLS_NUMBER; ++poolIdx) {\n        size_t blocksCount = xcpMemMainBlocksNumber[poolIdx];\n        size_t blockSize = xcpMemMainBlockSizes[poolIdx];\n\n        xcpMemPoolDescriptors[poolIdx].head = (XcpMemHeader*) memoryPtr;\n        xcpMemPoolDescriptors[poolIdx].totalBlocksCount = blocksCount;\n        xcpMemPoolDescriptors[poolIdx].freeBlocksCount = blocksCount;\n        xcpMemPoolDescriptors[poolIdx].blockSize = blockSize;\n        xcpMemPoolDescriptors[poolIdx].poolSize =\n            blocksCount * XCP_MEM_BLOCK_SIZE_WITH_OVERHEAD(blockSize);\n#ifdef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n        xcpMemPoolDescriptors[poolIdx].deferredFreeHead = NULL;\n        xcpMemPoolDescriptors[poolIdx].deferredFreeTail = NULL;\n        xcpMemPoolDescriptors[poolIdx].deferredFreeBlocksCount = 0;\n#else\n        XCP_MUTEX_INIT(xcpMemPoolDescriptors[poolIdx].lock);\n#endif\n\n        xcpInitializePoolMemoryArea(memoryPtr, blockSize, blocksCount);\n        memoryPtr += xcpMemPoolDescriptors[poolIdx].poolSize;\n    }\n\n    /* Initialize Reserved pools memory\n       @note since the allocation of the memory pools is dynamic,\n             the creation of the blocks for each pool is deferred\n             and carried out within the xcpMemReservedPoolCreate() */\n    XCP_MEMSET(xcpMemReservedPoolsChunk, 0, sizeof(xcpMemReservedPoolsChunk));\n    xcpMemReservedPoolsChunkUsedBytes = 0;\n\n    for(poolIdx = XCP_MEM_MAIN_POOLS_NUMBER; poolIdx < XCP_MEM_MAIN_RESERVED_POOL_NUMBER; ++poolIdx) {\n        xcpMemPoolDescriptors[poolIdx].head = XCP_FREE_POOL;\n        xcpMemPoolDescriptors[poolIdx].totalBlocksCount = 0;\n        xcpMemPoolDescriptors[poolIdx].freeBlocksCount = 0;\n        xcpMemPoolDescriptors[poolIdx].blockSize = 0;\n        xcpMemPoolDescriptors[poolIdx].poolSize = 0;\n#ifdef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n        xcpMemPoolDescriptors[poolIdx].deferredFreeHead = NULL;\n        xcpMemPoolDescriptors[poolIdx].deferredFreeTail = NULL;\n        xcpMemPoolDescriptors[poolIdx].deferredFreeBlocksCount = 0;\n#else\n        XCP_MUTEX_INIT(xcpMemPoolDescriptors[poolIdx].lock);\n#endif\n    }\n    \n    for(poolIdx = 0; poolIdx < XCP_MEM_CUSTOM_POOL_MAX_NUMBER; poolIdx++) {\n        xcpMemCustomPoolDescriptors[poolIdx].allocHandler = NULL;\n        xcpMemCustomPoolDescriptors[poolIdx].freeHandler = NULL;\n    }\n\n    return XCP_SUCCESS;\n}\n\n\nvoid* xcpMemAlloc(size_t size)\n{\n    uint8_T poolIdx;\n    size_t blockSize = 0;\n    XcpMemHeader *poolHead = NULL;\n\n    /* a size of 0 is considered an invalid argument */\n    if (size == 0) {\n        return NULL;\n    }\n\n    XCP_MUTEX_LOCK(xcpMemLock);\n\n    /* find the first large enough pool */\n    for(poolIdx = 0; poolIdx <  XCP_MEM_MAIN_POOLS_NUMBER; ++poolIdx) {\n        blockSize = xcpMemMainBlockSizes[poolIdx];\n        if ((size <= blockSize) && (xcpMemPoolDescriptors[poolIdx].freeBlocksCount > 0)) {\n            poolHead = xcpMemPoolDescriptors[poolIdx].head;\n            break;\n        }\n    }\n\n    if (!poolHead) { /* size is too large, or there are no more free blocks */\n       XCP_MUTEX_UNLOCK(xcpMemLock);\n       return NULL;\n    }\n\n    xcpMemPoolDescriptors[poolIdx].head = poolHead->next;\n    (xcpMemPoolDescriptors[poolIdx].freeBlocksCount)--;\n    poolHead->poolId = poolIdx;\n\n    XCP_MUTEX_UNLOCK(xcpMemLock);\n\n    /* return a pointer past just the poolId */\n    return ((uint8_T*) poolHead) + XCP_MEM_POOLID_SIZE;\n}\n\n\nvoid xcpMemFree(void *ptr)\n{\n    if (ptr) {\n        /* the XcpMemHeader cell is 'behind' the user's pointer */\n        XcpMemHeader *hd = (XcpMemHeader*) ((uint8_T*)ptr - XCP_MEM_POOLID_SIZE);\n        uint8_T poolIdx = hd -> poolId;\n        \n        if (poolIdx >= XCP_MEM_CUSTOM_POOLS_OFFSET && poolIdx < XCP_MEM_CUSTOM_POOLS_UPPER_BOUND) {\n            poolIdx = poolIdx - XCP_MEM_CUSTOM_POOLS_OFFSET;\n            if (xcpMemCustomPoolDescriptors[poolIdx].freeHandler) {\n                /* For custom memory pools, protection against concurrent\n                   exclusion must be guaranteed within the custom free method */\n                xcpMemCustomPoolDescriptors[poolIdx].freeHandler((uint8_T*)ptr - XCP_MEM_POOLID_SIZE);\n            }\n            return;\n        }\n\n        if ((poolIdx == XCP_FREE_POOL_ID) || (poolIdx >= XCP_MEM_MAIN_RESERVED_POOL_NUMBER)){\n            /* ill-formed block or already freed pointer */\n            XCP_PRINTF(\"xcpMemFree: invalid or double-freed pointer %p\\n\", ptr);\n            return;\n        }\n\n        /* insert the new free block in the front of the pool */\n        if (poolIdx < XCP_MEM_MAIN_POOLS_NUMBER) {\n            XCP_MUTEX_LOCK(xcpMemLock);\n\n            hd -> poolId = XCP_FREE_POOL_ID;\n            hd -> next = xcpMemPoolDescriptors[poolIdx].head;\n\n            xcpMemPoolDescriptors[poolIdx].head = hd;\n            ++(xcpMemPoolDescriptors[poolIdx].freeBlocksCount);\n\n            XCP_MUTEX_UNLOCK(xcpMemLock);\n        } \n        else {\n        #ifdef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n            /* If lockless support is enabled, the freed memory block is\n               not immediately available for subsequent allocations,\n               until xcpMemReservedPoolFlushFreeMem is invoked */\n            hd -> poolId = XCP_FREE_POOL_ID;\n            hd -> next = xcpMemPoolDescriptors[poolIdx].deferredFreeHead;\n\n            if (xcpMemPoolDescriptors[poolIdx].deferredFreeTail == NULL) {\n                /* Let's save a reference to the first block in the pool\n                   that has been freed */\n                xcpMemPoolDescriptors[poolIdx].deferredFreeTail = hd;\n            }\n\n            xcpMemPoolDescriptors[poolIdx].deferredFreeHead = hd;\n            ++(xcpMemPoolDescriptors[poolIdx].deferredFreeBlocksCount);\n        #else\n            XCP_MUTEX_LOCK(xcpMemPoolDescriptors[poolIdx].lock);\n\n            hd -> poolId = XCP_FREE_POOL_ID;\n            hd -> next = xcpMemPoolDescriptors[poolIdx].head;\n\n            xcpMemPoolDescriptors[poolIdx].head = hd;\n            ++(xcpMemPoolDescriptors[poolIdx].freeBlocksCount);\n            XCP_MUTEX_UNLOCK(xcpMemPoolDescriptors[poolIdx].lock);\n        #endif\n        }\n    }\n}\n\n\nXcpErrorCode xcpMemReservedPoolCreate(size_t blockSize, size_t blocksNumber, xcpPoolId_T* poolId)\n{\n    uint8_T poolIdx;\n    uint8_T *currentHead = (uint8_T *) XCP_ALIGNED(xcpMemReservedPoolsChunk);\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    xcpPoolId_T pool = XCP_INVALID_POOL_ID;\n    size_t requestedPoolSize;\n\n    if ((poolId == NULL) || (blockSize == 0) || (blocksNumber == 0)) {\n        XCP_PRINTF(\"xcpMemReservedPoolCreate: invalid input parameter\\n\");\n        return XCP_INV_ARG;\n    }\n\n    /* blockSize needs to be a multiple of XCP_MEM_ALIGNMENT in order to align blocks to aligned addresses.\n     * If the size is not a multiple, adjustment is done here.\n     */\n    blockSize = (size_t) XCP_ALIGNED(blockSize);\n\n    requestedPoolSize = blocksNumber * XCP_MEM_BLOCK_SIZE_WITH_OVERHEAD(blockSize);\n\n    XCP_MUTEX_LOCK(xcpMemLock);\n\n    for(poolIdx = XCP_MEM_MAIN_POOLS_NUMBER; poolIdx < XCP_MEM_MAIN_RESERVED_POOL_NUMBER; ++poolIdx) {\n        if (xcpMemPoolDescriptors[poolIdx].head == XCP_FREE_POOL) {\n            /* The pool is free, let's check if it is big enough */\n            if ((xcpMemPoolDescriptors[poolIdx].poolSize) == 0) {\n                /* The pool has never been allocated before, so this must be the last\n                   usable pool in the list */\n                if (requestedPoolSize <= (XCP_MEM_RESERVED_POOLS_TOTAL_SIZE - xcpMemReservedPoolsChunkUsedBytes)) {\n                    /* It is big enough, so let's mark it as allocated */\n                    xcpMemPoolDescriptors[poolIdx].head = (XcpMemHeader*) currentHead;\n                    xcpMemPoolDescriptors[poolIdx].totalBlocksCount = blocksNumber;\n                    xcpMemPoolDescriptors[poolIdx].freeBlocksCount = blocksNumber;\n                    xcpMemPoolDescriptors[poolIdx].blockSize = blockSize;\n                    xcpMemPoolDescriptors[poolIdx].poolSize = requestedPoolSize;\n                #ifdef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n                    xcpMemPoolDescriptors[poolIdx].deferredFreeHead = NULL;\n                    xcpMemPoolDescriptors[poolIdx].deferredFreeTail = NULL;\n                    xcpMemPoolDescriptors[poolIdx].deferredFreeBlocksCount = 0;\n                #endif\n\n                    xcpInitializePoolMemoryArea(currentHead, blockSize, blocksNumber);\n                    xcpMemReservedPoolsChunkUsedBytes += requestedPoolSize;\n\n                    pool = poolIdx;\n                }\n                break; /* No more pools to process, exit from the loop */\n            } else {\n                /* The pool has already been allocated so it can't be re-sized */\n                if (requestedPoolSize <= xcpMemPoolDescriptors[poolIdx].poolSize) {\n                    /* It is big enough, so let's mark it as allocated */\n                    xcpMemPoolDescriptors[poolIdx].head = (XcpMemHeader*) currentHead;\n                    xcpMemPoolDescriptors[poolIdx].totalBlocksCount = blocksNumber;\n                    xcpMemPoolDescriptors[poolIdx].freeBlocksCount = blocksNumber;\n                    xcpMemPoolDescriptors[poolIdx].blockSize = blockSize;\n                #ifdef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n                    xcpMemPoolDescriptors[poolIdx].deferredFreeHead = NULL;\n                    xcpMemPoolDescriptors[poolIdx].deferredFreeTail = NULL;\n                    xcpMemPoolDescriptors[poolIdx].deferredFreeBlocksCount = 0;\n                #endif\n\n                    xcpInitializePoolMemoryArea(currentHead, blockSize, blocksNumber);\n                    pool = poolIdx;\n                    break; /* We found what we were looking for, exit from the loop */\n                }\n            }\n        }\n\n        /* Let's continue to see if there are bigger memory areas available */\n        currentHead += xcpMemPoolDescriptors[poolIdx].poolSize;\n    }\n\n    XCP_MUTEX_UNLOCK(xcpMemLock);\n\n    if (pool == XCP_INVALID_POOL_ID) {\n        errorCode = XCP_NO_MEMORY;\n    }\n\n    *poolId = pool;\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpMemReservedPoolDestroy(xcpPoolId_T poolId)\n{\n    uint8_T poolIdx;\n    boolean_T isLastPool = true;\n\n    if ((poolId < XCP_MEM_MAIN_POOLS_NUMBER) || (poolId >= XCP_MEM_MAIN_RESERVED_POOL_NUMBER)) {\n        XCP_PRINTF(\"xcpMemReservedPoolDestroy: invalid input parameter\\n\");\n        return XCP_INV_ARG;\n    }\n\n    XCP_MUTEX_LOCK(xcpMemLock);\n\n    /* Check if the pool is the last one (i.e. the used pool with the highest id) */\n    for(poolIdx = (XCP_MEM_MAIN_RESERVED_POOL_NUMBER - 1); poolIdx > poolId; --poolIdx) {\n        if ((xcpMemPoolDescriptors[poolIdx].head != XCP_FREE_POOL) ||\n            (xcpMemPoolDescriptors[poolIdx].poolSize != 0)) {\n            isLastPool = false;\n            break; /* the pool is not the last, exit from the loop */\n        }\n    }\n\n    xcpMemPoolDescriptors[poolId].head = XCP_FREE_POOL;\n    xcpMemPoolDescriptors[poolId].totalBlocksCount = 0;\n    xcpMemPoolDescriptors[poolId].freeBlocksCount = 0;\n    xcpMemPoolDescriptors[poolId].blockSize = 0;\n\n#ifdef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n    xcpMemPoolDescriptors[poolId].deferredFreeHead = NULL;\n    xcpMemPoolDescriptors[poolId].deferredFreeTail = NULL;\n    xcpMemPoolDescriptors[poolId].deferredFreeBlocksCount = 0;\n#endif\n\n    if (isLastPool) {\n        /* If it's the last pool we can de-allocate the memory, taking into account this pool\n           as well as the previous ones that have already been deallocated (out of order) */\n        for(poolIdx = (XCP_MEM_MAIN_RESERVED_POOL_NUMBER - 1); poolIdx >= XCP_MEM_MAIN_POOLS_NUMBER; --poolIdx) {\n            if ((xcpMemPoolDescriptors[poolIdx].head == XCP_FREE_POOL) &&\n                (xcpMemPoolDescriptors[poolIdx].poolSize != 0)) {\n                xcpMemReservedPoolsChunkUsedBytes -= xcpMemPoolDescriptors[poolIdx].poolSize;\n                xcpMemPoolDescriptors[poolIdx].poolSize = 0;\n            }\n        }\n    }\n\n    XCP_MUTEX_UNLOCK(xcpMemLock);\n\n    return XCP_SUCCESS;\n}\n\n\nXcpErrorCode xcpMemCustomPoolCreate(XcpCustomAllocHandler allocHandler, XcpCustomFreeHandler freeHandler, xcpPoolId_T* poolId)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    uint8_T poolIdx;\n\n    xcpPoolId_T pool = XCP_INVALID_POOL_ID;\n\n    if ((poolId == NULL) || (allocHandler == NULL) || (freeHandler == NULL)) {\n        XCP_PRINTF(\"xcpMemCustomPoolCreate: invalid input parameter\\n\");\n        return XCP_INV_ARG;\n    }\n\n    XCP_MUTEX_LOCK(xcpMemLock);\n\n    for (poolIdx = 0; poolIdx < XCP_MEM_CUSTOM_POOL_MAX_NUMBER; poolIdx++) {\n        if (xcpMemCustomPoolDescriptors[poolIdx].allocHandler == NULL && xcpMemCustomPoolDescriptors[poolIdx].freeHandler == NULL) {\n            pool = poolIdx + XCP_MEM_CUSTOM_POOLS_OFFSET;\n            xcpMemCustomPoolDescriptors[poolIdx].allocHandler = allocHandler;\n            xcpMemCustomPoolDescriptors[poolIdx].freeHandler = freeHandler;\n            break;\n        }\n    }\n\n    XCP_MUTEX_UNLOCK(xcpMemLock);\n\n    if (pool == XCP_INVALID_POOL_ID) {\n        errorCode = XCP_NO_MEMORY;\n    }\n\n    *poolId = pool;\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpMemCustomPoolDestroy(xcpPoolId_T poolId)\n{\n    if (poolId < XCP_MEM_CUSTOM_POOLS_OFFSET || poolId >= XCP_MEM_CUSTOM_POOLS_UPPER_BOUND) {\n        XCP_PRINTF(\"xcpMemCustomPoolDestroy: invalid poolId\\n\");\n        return XCP_INV_ARG;\n    }\n\n    XCP_MUTEX_LOCK(xcpMemLock);\n\n    xcpMemCustomPoolDescriptors[poolId - XCP_MEM_CUSTOM_POOLS_OFFSET].allocHandler = NULL;\n    xcpMemCustomPoolDescriptors[poolId - XCP_MEM_CUSTOM_POOLS_OFFSET].freeHandler = NULL;\n\n    XCP_MUTEX_UNLOCK(xcpMemLock);\n\n    return XCP_SUCCESS;\n}\n\n\nvoid* xcpMemAllocFromPool(xcpPoolId_T poolId, size_t size)\n{\n    XcpMemHeader *poolHead = NULL;\n\n    /* a size of 0 is considered an invalid argument */\n    if (size == 0) {\n        return NULL;\n    }\n\n    /* Check if memory allocation is delegated to a custom handler.\n       For custom memory pools, protection against concurrent execution must be\n       implemented withing the allocation method */\n    if (poolId >= XCP_MEM_CUSTOM_POOLS_OFFSET && poolId < XCP_MEM_CUSTOM_POOLS_UPPER_BOUND) {\n        if (xcpMemCustomPoolDescriptors[poolId - XCP_MEM_CUSTOM_POOLS_OFFSET].allocHandler) {\n            /* Memory must be added explicitly to store the pool ID */\n            poolHead = (XcpMemHeader *) xcpMemCustomPoolDescriptors[poolId - XCP_MEM_CUSTOM_POOLS_OFFSET].allocHandler(size + XCP_MEM_POOLID_SIZE);\n            if (!poolHead) {\n                return NULL;\n            }\n            poolHead->poolId = (uint8_T) poolId;\n            return ((uint8_T*) poolHead) + XCP_MEM_POOLID_SIZE;\n        }\n        return NULL;\n    }\n    \n    if ((poolId < XCP_MEM_MAIN_POOLS_NUMBER) || (poolId >= XCP_MEM_MAIN_RESERVED_POOL_NUMBER) ||\n        (xcpMemPoolDescriptors[poolId].head == XCP_FREE_POOL) ||\n        (xcpMemPoolDescriptors[poolId].blockSize < size)) {\n        /* No memory block of the given size is available from this pool */\n        return NULL;\n    }\n\n#ifndef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n    XCP_MUTEX_LOCK(xcpMemPoolDescriptors[poolId].lock);\n#endif\n\n    if (xcpMemPoolDescriptors[poolId].freeBlocksCount > 0) {\n        poolHead = xcpMemPoolDescriptors[poolId].head;\n    }\n\n    if (!poolHead){ /* there are no more free blocks */\n#ifndef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n       XCP_MUTEX_UNLOCK(xcpMemPoolDescriptors[poolId].lock);\n#endif\n       return NULL;\n    }\n\n    xcpMemPoolDescriptors[poolId].head = poolHead->next;\n    (xcpMemPoolDescriptors[poolId].freeBlocksCount)--;\n    poolHead->poolId = (uint8_T) poolId;\n\n#ifndef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n    XCP_MUTEX_UNLOCK(xcpMemPoolDescriptors[poolId].lock);\n#endif\n\n    /* return a pointer past just the poolId */\n    return ((uint8_T*) poolHead) + XCP_MEM_POOLID_SIZE;\n\n}\n\n\n#ifdef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\nvoid xcpMemReservedPoolFlushFreeMem(xcpPoolId_T poolId)\n{\n    if ((poolId >= XCP_MEM_MAIN_POOLS_NUMBER) &&\n        (poolId < XCP_MEM_MAIN_RESERVED_POOL_NUMBER) &&\n        (xcpMemPoolDescriptors[poolId].deferredFreeTail != NULL)) {\n        /* Let's move the deferred free blocks to the list of free blocks\n           available for subsequent allocations */\n        xcpMemPoolDescriptors[poolId].deferredFreeTail->next = xcpMemPoolDescriptors[poolId].head;\n        xcpMemPoolDescriptors[poolId].head = xcpMemPoolDescriptors[poolId].deferredFreeHead;\n        xcpMemPoolDescriptors[poolId].freeBlocksCount += xcpMemPoolDescriptors[poolId].deferredFreeBlocksCount;\n        xcpMemPoolDescriptors[poolId].deferredFreeBlocksCount = 0;\n        xcpMemPoolDescriptors[poolId].deferredFreeTail = NULL;\n    }\n}\n#endif\n\n\nXcpErrorCode xcpMemReset(void){\n    XCP_MEMSET(xcpMemMainChunk,          0, sizeof(xcpMemMainChunk));\n    XCP_MEMSET(xcpMemReservedPoolsChunk, 0, sizeof(xcpMemReservedPoolsChunk));\n    xcpMemReservedPoolsChunkUsedBytes = 0;\n\n    XCP_MEMSET(xcpMemPoolDescriptors,    0, sizeof(xcpMemPoolDescriptors));\n\n    XCP_MEMSET(xcpMemCustomPoolDescriptors, 0, sizeof(xcpMemCustomPoolDescriptors));\n\n    return XCP_SUCCESS;\n}\n\n#ifdef XCP_DEBUG_SUPPORT\n\nvoid xcpMemPrintDiagnostics(void)\n{\n    uint8_T poolIdx;\n    XCP_PRINTF(\"#############################\\n\");\n    XCP_PRINTF(\"             Header size: %7zu B\\n\", XCP_MEM_HEADER_SIZE);\n    XCP_PRINTF(\"             Offset size: %7zu B\\n\", XCP_MEM_POOLID_SIZE);\n    XCP_PRINTF(\"      Main System memory: %7zu B\\n\", XCP_MEM_MAIN_SYSTEM_SIZE);\n    XCP_PRINTF(\"        Main User memory: %7zu B\\n\", XCP_MEM_MAIN_USER_SIZE);\n    XCP_PRINTF(\"       Main Total memory: %7zu B\\n\", XCP_MEM_MAIN_TOTAL_SIZE);\n\n    for(poolIdx = 0 ; poolIdx < XCP_MEM_MAIN_POOLS_NUMBER ; ++poolIdx) {\n        size_t bsThisPool = xcpMemMainBlockSizes[poolIdx];\n        size_t nbBlocksThisPool = xcpMemPoolDescriptors[poolIdx].totalBlocksCount;\n        size_t nbFreeBlocksThisPool = xcpMemPoolDescriptors[poolIdx].freeBlocksCount;\n        XCP_PRINTF(\"%6zu B blocks: %4zu/%-4zu\\n\", bsThisPool, nbFreeBlocksThisPool, nbBlocksThisPool);\n    }\n    XCP_PRINTF(\"               (free)/(total)\\n\");\n    XCP_PRINTF(\"#############################\\n\");\n\n    XCP_PRINTF(\"        Res Pools Number: %7d B\\n\", XCP_MEM_RESERVED_POOLS_NUMBER);\n    XCP_PRINTF(\"  Res Pools Total memory: %7zu B\\n\", XCP_MEM_RESERVED_POOLS_TOTAL_SIZE);\n\n    for(poolIdx = XCP_MEM_MAIN_POOLS_NUMBER ; poolIdx < XCP_MEM_MAIN_RESERVED_POOL_NUMBER ; ++poolIdx) {\n        size_t nbBlocksThisPool = xcpMemPoolDescriptors[poolIdx].totalBlocksCount;\n        size_t nbFreeBlocksThisPool = xcpMemPoolDescriptors[poolIdx].freeBlocksCount;\n        XCP_PRINTF(\"Pool %3d blocks: %4zu/%-4zu\\n\", poolIdx, nbFreeBlocksThisPool, nbBlocksThisPool);\n    }\n    XCP_PRINTF(\"               (free)/(total)\\n\");\n}\n\n#endif\n\n#ifdef XCP_MEM_BYTE_COPY_SUPPORT\n/* xcpMemcpyByte() currently supports byte-wise copy on WORD (HW_AG=2) addressable targets only */\nvoid xcpMemcpyByte(void *pDst, uint8_T dstOffsetBytes, void *pSrc, uint8_T srcOffsetBytes, size_t numOfBytes)\n{\n    uint16_T *dst = (uint16_T *)pDst;\n    uint16_T *src = (uint16_T *)pSrc;\n\n    if (numOfBytes >= 1) {\n        size_t numOfAGUnits = ((numOfBytes + 1) >> 1);\n        \n        if ((dstOffsetBytes == 0) && (srcOffsetBytes == 0)){\n            if (numOfBytes % 2){\n                numOfAGUnits--;\n                XCP_MEMCPY(dst, src, numOfAGUnits);\n                dst[numOfAGUnits] &= 0xff00;\n                dst[numOfAGUnits] |= (src[numOfAGUnits] & 0x00ff);\n            }\n            else {\n                XCP_MEMCPY(dst, src, numOfAGUnits);\n            }\n        }\n        else if ((dstOffsetBytes == 1) && (srcOffsetBytes == 0)){\n            uint32_T i = 0;\n            dst[0] &= 0x00ff;\n            dst[0] |= ((src[0] & 0x00ff) << 8);\n            for (i = 1; i < numOfAGUnits; i++){\n                dst[i]  = ((src[i-1] & 0xff00) >> 8);\n                dst[i] |= ((src[i] & 0x00ff) << 8);\n            }\n            if ((numOfBytes % 2) == 0){\n                dst[i] &= 0xff00;\n                dst[i] |= ((src[i-1] & 0xff00) >> 8);\n            }\n        }\n        else if ((dstOffsetBytes == 0) && (srcOffsetBytes == 1)){\n            uint32_T i = 0;\n            dst[0] = ((src[0] & 0xff00) >> 8);\n            if (numOfBytes >= 2) {\n                dst[0] |= ((src[1] & 0x00ff) << 8);\n                for (i = 1; i < numOfAGUnits-1; i++){\n                    dst[i]  = ((src[i] & 0xff00) >> 8);\n                    dst[i] |= ((src[i+1] & 0x00ff) << 8);\n                }\n                if (numOfBytes % 2){\n                    dst[i] &= 0xff00;\n                    dst[i] |= ((src[i] & 0xff00) >> 8);\n                }\n            }\n        }\n        else if ((dstOffsetBytes == 1) && (srcOffsetBytes == 1)){\n            dst[0] &= 0x00ff;\n            dst[0] |= (src[0] & 0xff00);\n            numOfBytes--;\n            numOfAGUnits--;\n            dst++;\n            src++;\n            XCP_MEMCPY(dst, src, numOfAGUnits);\n            if ((numOfBytes % 2) != 0){\n                dst[numOfAGUnits] &= 0xff00;\n                dst[numOfAGUnits] |= (src[numOfAGUnits] & 0x00ff);\n            }\n        }\n    }\n}\n\n#endif\n"},{"name":"xcp_platform_default.c","type":"source","group":"legacy","path":"E:\\Matlab\\toolbox\\coder\\xcp\\src\\target\\slave\\platform\\default","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2021 The MathWorks, Inc.\n*\n* File: xcp_platform_default.c\n*\n* Abstract:\n*  Implementation of default XCP Slave platform services\n*/\n\n#include <stdlib.h>\n\n#include \"xcp_common.h\"\n#include \"xcp_platform_default.h\"\n#include \"xcp_cfg.h\"\n\n#if defined(__APPLE__) && defined(__MACH__)\n#include <mach-o/dyld.h>\n#endif\n\n/* Define the API to pause the execution (sleep) for a specific amount of time */\n#if defined(_WIN32) || defined(__WIN32__) || defined(WIN32)\n\n#define XCP_MICROSECONDS_PER_SECOND  1000000\n\nstatic boolean_T xcpPerfCounterAvailable      = true;\nstatic boolean_T xcpPerfCounterInitialized    = false;\nstatic uint64_t  xcpPerfCounterTicksPerSecond = 1;\n\n/* Initialize performance counters */\nstatic void xcpPerfCounterInit(void)\n{\n    if (!xcpPerfCounterInitialized) {\n        LARGE_INTEGER frequency;\n\n        if (QueryPerformanceFrequency(&frequency)) {\n            if ((frequency.u.HighPart != 0) || (frequency.u.LowPart == 0)) {\n                XCP_PRINTF(\"xcpTimestampInit: QueryPerformanceFrequency error, unexpected frequency\\n\");\n                xcpPerfCounterAvailable = false;\n            } else {\n                xcpPerfCounterTicksPerSecond = frequency.u.LowPart;\n            }\n        }\n        else {\n            XCP_PRINTF(\"xcpTimestampInit: QueryPerformanceFrequency error, performance Counter not available\\n\");\n            xcpPerfCounterAvailable = false;\n        }\n\n        xcpPerfCounterInitialized = true;\n    }\n}\n\n\n/* Convert a performance counter value (in ticks) into a value according to a specific time unit */\nstatic uint64_t xcpPerfCounterValue2TimeUnits(LARGE_INTEGER value, uint64_t timeUnitsPerSecond)\n{\n    return ((((uint64_t)value.u.HighPart) << 32) | (uint64_t)value.u.LowPart) * timeUnitsPerSecond / xcpPerfCounterTicksPerSecond;\n}\n\n\n\nvoid xcpSleep(uint32_T seconds, uint32_T microseconds)\n{\n    if ((seconds == 0) && (microseconds == 0)) {\n        /* According to MSDN, a value of zero causes the thread to relinquish\n           the remainder of its time slice to any other thread that is ready to run.\n           If there are no other threads ready to run, the function returns immediately\n           and the thread continues execution */\n        Sleep(0);\n    } else if ((seconds == 0) && (microseconds < 1000)) {\n        /* Sleep() doesn't allow to sleep for less than 1ms.\n           If a sleep time of less than 1ms is requested on Windows, a busy wait\n           based on performance counters is used instead */\n        if (!xcpPerfCounterInitialized) {\n            /* Initialize performance counters */\n            xcpPerfCounterInit();\n        }\n\n        if (xcpPerfCounterAvailable) {\n            LARGE_INTEGER current;\n            uint64_t startTime = 0;\n            uint64_t currentTime = 0;\n            uint64_t elapsedTime = 0;\n\n            QueryPerformanceCounter(&current);\n            startTime = xcpPerfCounterValue2TimeUnits(current, XCP_MICROSECONDS_PER_SECOND);\n\n            do\n            {\n                QueryPerformanceCounter(&current);\n                currentTime = xcpPerfCounterValue2TimeUnits(current, XCP_MICROSECONDS_PER_SECOND);\n\n                if (currentTime >= startTime) {\n                    elapsedTime = currentTime - startTime;\n                } else {\n                    elapsedTime = currentTime + UINT64_MAX - startTime;\n                }\n            }\n            while(elapsedTime <= microseconds);\n        }\n    } else {\n        /* Sleep for the required amount of ms */\n        Sleep((seconds) * 1000 + (((microseconds) + 1000 - 1) / 1000));\n    }\n}\n\n#elif defined(__linux__) || defined(__APPLE__) && defined(__MACH__)\n\nvoid xcpSleep(uint32_T seconds, uint32_T microseconds)\n{\n#if defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 199309L\n\t/* nanosleep() is the preferred sleep method on Linux */\n\tstruct timespec t;\n\tt.tv_sec = seconds;\n\tt.tv_nsec = microseconds * 1000;\n\n\tnanosleep(&t, NULL);\n#else\n\t/* if nanosleep() is not available, use the select() instead */\n\tstruct timeval t;\n\tt.tv_sec = seconds;\n\tt.tv_usec = (suseconds_t)microseconds; /* tv_usec is signed */\n\n\tselect(0, NULL, NULL, NULL, &t);\n#endif /* _POSIX_C_SOURCE >= 199309L */\n}\n\n#else\n\n#error \"platform not supported: a custom Platform Abstraction Layer needs to be provided.\"\n\n#endif\n\n\n#ifndef XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME\n/* @note The following section provides the default implementation\n         of the xcpGetTimestamp() API, based on the 'real' time\n         for Linux and Windows platforms.\n         If XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME is defined,\n         the same function will be implemented in the External Mode\n         abstraction layer, based on the model simulation time */\n\n/* Define the XCP_TIMESTAMP_UNITS_PER_SECOND value based on the\n   selected XCP_TIMESTAMP_UNIT */\n#if (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1NS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e9\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10NS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e8\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100NS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e7\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1US)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e6\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10US)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e5\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100US)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e4\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1MS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e3\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10MS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e2\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100MS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e1\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1S)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND            1\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1PS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND         1e12\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10PS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND         1e11\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100PS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND         1e10\n#else\n#error \"invalid XCP_TIMESTAMP_UNIT value\"\n#endif\n\n/* Define the corresponding XCP_TIMESTAMP_UNITS_PER_MICROSECOND value */\n#define XCP_TIMESTAMP_UNITS_PER_MICROSECOND (XCP_TIMESTAMP_UNITS_PER_SECOND / 1e6)\n\nstatic boolean_T xcpTimestampInitialized = false;\nstatic uint64_t  xcpTimestampStartTime = 0;\n\n\n#if defined(_WIN32) || defined(__WIN32__) || defined(WIN32)\n\n/* Initialize timestamp based on performance counters */\nstatic void xcpTimestampInit(void)\n{\n    if (!xcpTimestampInitialized) {\n        if (!xcpPerfCounterInitialized) {\n            /* Initialize performance counters */\n            xcpPerfCounterInit();\n        }\n\n        if (xcpPerfCounterAvailable) {\n            LARGE_INTEGER current;\n\n            /* Initialize xcpTimestampStartTime based on current time */\n            QueryPerformanceCounter(&current);\n\n            xcpTimestampStartTime = xcpPerfCounterValue2TimeUnits(current, (uint64_t) XCP_TIMESTAMP_UNITS_PER_SECOND);\n        }\n\n        xcpTimestampInitialized = true;\n    }\n}\n\n/* Get timestamp value in XCP_TIMESTAMP_UNITs\n    @note in the current implementation the time starts counting from 0 on the first call */\nuint32_T xcpGetTimestamp(void)\n{\n    LARGE_INTEGER current;\n    uint64_t currentTime;\n    uint32_T ret = 0;\n\n    if (!xcpTimestampInitialized) {\n        xcpTimestampInit();\n        return ret;\n    }\n\n    if (xcpPerfCounterAvailable) {\n        QueryPerformanceCounter(&current);\n        currentTime = xcpPerfCounterValue2TimeUnits(current, (uint64_t) XCP_TIMESTAMP_UNITS_PER_SECOND);\n\n        if (currentTime >= xcpTimestampStartTime) {\n            ret = (uint32_T) (currentTime - xcpTimestampStartTime);\n        } else {\n            ret = (uint32_T) (currentTime + UINT64_MAX - xcpTimestampStartTime);\n        }\n    }\n\n    return ret;\n}\n\n#elif defined(__linux__) || defined(__APPLE__) && defined(__MACH__)\n\n/* Return value in XCP_TIMESTAMP_UNITs\n   @note in the current implementation the time starts counting from 0 on the first call */\nuint32_T xcpGetTimestamp(void)\n{\n    struct timeval timeVal;\n    uint64_t currentTime = 0;\n    uint32_T ret = 0;\n\n    gettimeofday(&timeVal, NULL);\n    currentTime = timeVal.tv_sec * XCP_TIMESTAMP_UNITS_PER_SECOND + timeVal.tv_usec * XCP_TIMESTAMP_UNITS_PER_MICROSECOND;\n\n    if (!xcpTimestampInitialized) {\n        /* Read initial time and store it in xcpTimestampStartTime variable */\n        xcpTimestampStartTime = currentTime;\n\n        xcpTimestampInitialized = true;\n    }\n\n    if (currentTime >= xcpTimestampStartTime) {\n        ret = (uint32_T) (currentTime - xcpTimestampStartTime);\n    } else {\n        ret = (uint32_T) (currentTime + UINT64_MAX - xcpTimestampStartTime);\n    }\n\n    return ret;\n}\n\n#else\n\n#error \"platform not supported: a custom Platform Abstraction Layer needs to be provided.\"\n\n#endif\n\n#endif /* XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME */\n\n\n/* Define the API to convert the XCP address and extension into the corresponding\n   variable address in the target address space */\n#if defined(_WIN32) || defined(__WIN32__) || defined(WIN32)\n\n#if defined(__MINGW32__) || defined(__MINGW64__) || defined(XCP_PLATFORM_WINDOWS_NO_OFFSET_SUPPORT)\n\nuint8_T *xcpAddressGet(uint8_T addressExtension, uint32_T address)\n{\n    return (uint8_T*) ((uintptr_t) address | (((uintptr_t)addressExtension) << 32));\n}\n\n#else\n\nextern IMAGE_DOS_HEADER __ImageBase;\nuint8_T *xcpAddressGet(uint8_T addressExtension, uint32_T address)\n{\n    return (uint8_T*) (((uintptr_t) address | (((uintptr_t)addressExtension) << 32)) + \n                       (uintptr_t)&__ImageBase);\n}\n\n#endif\n\n#elif defined(__linux__)\n\nextern char __executable_start;\n\n#if defined(XCP_PLATFORM_LINUX_PIE_SUPPORT) && defined(XCP_PLATFORM_LINUX_NO_PIE_SUPPORT)\n#error \"XCP_PLATFORM_LINUX_PIE_SUPPORT and XCP_PLATFORM_LINUX_NO_PIE_SUPPORT cannot be defined at the same time.\"\n#endif\n\n#ifdef XCP_PLATFORM_LINUX_PIE_SUPPORT\n\n/* If the binary is compiled as Position Independent Executable, the address sent by the XCP Master\n   is treated as an offset from the __executable_start address */\nuint8_T *xcpAddressGet(uint8_T addressExtension, uint32_T address)\n{\n    return (uint8_T*) (((uintptr_t) address | (((uintptr_t)addressExtension) << 32)) + \n                        (uintptr_t)&__executable_start);\n}\n\n#elif defined(XCP_PLATFORM_LINUX_NO_PIE_SUPPORT)\n\n/* If the binary is NOT compiled as Position Independent Executable, the address sent by the XCP Master\n   is treated as the actual address of the variable */\nuint8_T *xcpAddressGet(uint8_T addressExtension, uint32_T address)\n{\n    return (uint8_T*) ((uintptr_t) address | (((uintptr_t)addressExtension) << 32));\n}\n\n#else\n\n/* if the code is loaded below 32 bits, the default implementation is assuming\n   that PIE is not enabled and that address represents the actual address\n   in memory where the variable is loaded.\n\n   However if we detect that the code has been loaded beyond that limit,\n   then a relocation mechanism must be enabled and therefore we apply\n   the same conversion rule as PIE */\nuint8_T *xcpAddressGet(uint8_T addressExtension, uint32_T address)\n{\n    if ((uintptr_t)&__executable_start < (uintptr_t)MAX_uint32_T) {\n        return (uint8_T*) ((uintptr_t) address | (((uintptr_t)addressExtension) << 32));\n    } else {\n        return (uint8_T*) (((uintptr_t) address | (((uintptr_t)addressExtension) << 32)) +\n                            (uintptr_t)&__executable_start);\n    }\n}\n\n#endif /*  XCP_PLATFORM_LINUX_PIE_SUPPORT */\n\n#elif defined(__APPLE__) && defined(__MACH__)\n\n#define MAX_EXECUTABLE_PATH_SIZE 1024\n#define UNINITIALIZED_ADDRESS ((intptr_t) -1)\n\n/* Get the dynamic image slide of system when the executable is deployed */\nuintptr_t xcpExecutableStartAddress(void)\n{    \n    static intptr_t imgSlideValue = UNINITIALIZED_ADDRESS;\n    \n    if (imgSlideValue == UNINITIALIZED_ADDRESS) {\n        char path[MAX_EXECUTABLE_PATH_SIZE];\n        uint32_T size = sizeof(path);\n        path[MAX_EXECUTABLE_PATH_SIZE-1] = '\\0';\n        /* _NSGetExecutablePath returns 0 if the path of the main executable\n         * is successfully copied */\n        if (_NSGetExecutablePath(path, &size) == 0) {\n            uint32_T i = 0;\n            for (i = 0; (i < _dyld_image_count()) && (imgSlideValue == UNINITIALIZED_ADDRESS); i++)\n            {\n             /* If the path of the executable is the same as the indexed image\n             that means the image is the ASLR slide */\n                if (strcmp(_dyld_get_image_name(i), path) == 0)\n                    imgSlideValue = _dyld_get_image_vmaddr_slide(i);\n            }\n        }\n    }\n    return (uintptr_t)imgSlideValue;\n}\n\nuint8_T *xcpAddressGet(uint8_T addressExtension, uint32_T address)\n{\n    return (uint8_T*) (((uintptr_t) address | (((uintptr_t)addressExtension) << 32)) + \n                       xcpExecutableStartAddress());\n}\n\n#else\n\n#error \"platform not supported: a custom Platform Abstraction Layer needs to be provided.\"\n\n#endif\n\n"},{"name":"xcp_standard.c","type":"source","group":"legacy","path":"E:\\Matlab\\toolbox\\coder\\xcp\\src\\target\\slave\\protocol\\src","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2021 The MathWorks, Inc.\n*\n* File: xcp_standard.c\n*\n* Abstract:\n*  Implementation of XCP Protocol Layer standard commands\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp.h\"\n#include \"xcp_cfg.h\"\n#include \"xcp_types.h\"\n#include \"xcp_transport_internal.h\"\n#include \"xcp_daq.h\"\n#include \"xcp_standard.h\"\n#include \"xcp_standard_ext.h\"\n#include \"xcp_standard_types.h\"\n\n\n/*****************************************************************************\n    Internal Variables\n******************************************************************************/\nstatic XcpAddress xcpMta = {0,0};   /* MTA and MTA extension in same format as in SET_MTA packet, used by (SHORT)_UPLOAD, (SHORT)_DOWNLOAD */\nstatic uint8_T xcpUploadSize = 0;\n\n\n/*****************************************************************************\n    Internal Utility Functions\n******************************************************************************/\nstatic boolean_T isValidUploadSize(uint8_T size)\n{\n    size_t addressGranularity = XCP_ADDRESS_GRANULARITY_BYTES_NUMBER;\n    size_t maxCtoSize = xcpTransportMaxCtoSize();\n\n    return (size < ((maxCtoSize) / addressGranularity));\n}\n\n/** memcpy function used to copy data from MTA address to the packet */\nstatic void xcpMemcpyFromMTA(uint8_T *pktData, uint8_T dstOffsetBytes)\n{\n    /* Retrieve memory address */\n    uint8_T *xcpMTARawPointer = xcpStandardGetAddressFromMta();\n\n    XCP_PRINTF(\"reading at address %p\\n\", xcpMTARawPointer);\n\n#ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n{\n    uint32_T address;\n    uint8_T addressExtension;\n    uint8_T srcOffsetBytes;\n    xcpStandardGetMta(&address, &addressExtension);\n    srcOffsetBytes = XCP_BYTE_OFFSET_GET(address);\n    if (dstOffsetBytes) { pktData--; }\n    xcpMemcpyByte(pktData, dstOffsetBytes, xcpMTARawPointer, srcOffsetBytes, xcpUploadSize);\n}\n#else\n    XCP_UNUSED_PARAM(dstOffsetBytes);\n    XCP_MEMCPY(pktData, xcpMTARawPointer, xcpUploadSize);\n#endif\n\n}\n\n/*****************************************************************************\n    XCP CONNECT\n******************************************************************************/\n#define XCP_NO_RESOURCES  0x00\n\nstatic const uint8_T xcpResourceValue = (\n    XCP_NO_RESOURCES\n#ifdef XCP_DAQ_SUPPORT\n    | XCP_RESOURCE_DAQ_MASK\n#endif\n#ifdef XCP_STIM_SUPPORT\n    | XCP_RESOURCE_STIM_MASK\n#endif\n#ifdef XCP_PGM_SUPPORT\n    | XCP_RESOURCE_PGM_MASK\n#endif\n#ifdef XCP_CALIBRATION_SUPPORT\n    | XCP_RESOURCE_CAL_PAG_MASK\n#endif\n    );\n\nstatic const uint8_T xcpCommModeBaseValue = (\n    (XCP_ADDRESS_GRANULARITY << XCP_COMM_MODE_ADDRESS_GRANULARITY_OFFSET)\n#if (XCP_BYTE_ORDER != 0)\n    | XCP_COMM_MODE_BYTE_ORDER_MASK\n#endif\n#ifdef XCP_BLOCK_MODE_SUPPORT\n    | XCP_COMM_MODE_SLAVE_BLOCK_MODE_MASK\n#endif\n#ifdef XCP_COMM_MODE_INFO_SUPPORT\n    | XCP_COMM_MODE_OPTIONAL_MASK\n#endif\n    );\n\nstatic XcpProtoErrorCode connectInputPacketHandler(void   *msgBuffer,\n                                                   size_t  xcpPacketOffset,\n                                                   size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpConnectCmdPacketFrame *frame = (XcpConnectCmdPacketFrame *) packet;\n    boolean_T ok = false;\n\n    /* If DAQ List support is enabled, reset the status of dynamic DAQ list data structures */\n    ok = xcpResetDaqListStatus();\n\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_BUSY,\n        (\"CONNECT: DAQ lists reset cannot be carried out, as an event was processed\\n\"));\n\n    /* Validate command inputs */\n    ok = (frame->mode == XCP_CONNECT_MODE_NORMAL) || (frame->mode == XCP_CONNECT_MODE_USER_DEFINED);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n                          (\"CONNECT: invalid mode detected %xH\\n\", frame->mode));\n\n    /* Everything is fine -> updating the Protocol Layer status */\n    XCP_PRINTF(\"CONNECT: entering XCP_CONNECTED status\\n\");\n    xcpStatusSet(XCP_CONNECTED);\n\n    protoErrorCode = XCP_PROTO_SUCCESS;\n    *outputPacketSize = XCP_CONNECT_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\nstatic void connectOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize)\n{\n    if (inputCode == XCP_PROTO_SUCCESS) {\n        /* Fill connect response */\n        XcpConnectResPacketFrame *frame = (XcpConnectResPacketFrame *)packet;\n        XCP_MEMSET(frame, 0, sizeof(*frame));\n\n        frame->PID = XCP_PID_RES;\n\n        /* Update resource field */\n        frame->resource = xcpResourceValue;\n\n        /* Update commModeBasic field */\n        frame->commModeBasic = xcpCommModeBaseValue;\n\n        /* Update Max CTO and DTO fields */\n        frame->maxCtoSize = (uint8_T)xcpTransportMaxCtoSize();\n        frame->maxDtoSize = (uint16_T)xcpTransportMaxDtoSize();\n\n        /* Update Protocol and Transport Version fields */\n        frame->xcpProtocolVersion  = XCP_MAJOR_NUMBER(XCP_PROTOCOL_LAYER_VERSION);\n        frame->xcpTransportVersion = XCP_MAJOR_NUMBER(XCP_TRANSPORT_LAYER_VERSION);\n\n        XCP_PRINTF(\"* Resource:          %xH\\n\", frame->resource);\n        XCP_PRINTF(\"* Comm Mode Basic:   %xH\\n\", frame->commModeBasic);\n        XCP_PRINTF(\"* Max CTO size:      %d\\n\",  frame->maxCtoSize);\n        XCP_PRINTF(\"* Max DTO size:      %d\\n\",  frame->maxDtoSize);\n        XCP_PRINTF(\"* Protocol Version:  %d\\n\",  frame->xcpProtocolVersion);\n        XCP_PRINTF(\"* Transport Version: %d\\n\",  frame->xcpTransportVersion);\n    }\n    else {\n        genericOutputPacketHandler(inputCode, packet, packetSize);\n    }\n}\n\n/*****************************************************************************\n    XCP DISCONNECT\n******************************************************************************/\nstatic XcpProtoErrorCode disconnectInputPacketHandler(void   *msgBuffer,\n                                                      size_t  xcpPacketOffset,\n                                                      size_t *outputPacketSize)\n{\n    boolean_T ok = true;\n\n    XCP_UNUSED_PARAM(msgBuffer);\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    /* If DAQ List support is enabled, reset the status of dynamic DAQ list data structures */\n    ok = xcpResetDaqListStatus();\n\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_BUSY,\n        (\"DISCONNECT: DAQ lists reset cannot be carried out, as an event was processed\\n\"));\n\n    /* Everything is fine -> proceed with the status update */\n    XCP_PRINTF(\"DISCONNECT: entering XCP_DISCONNECTED status\\n\");\n    xcpStatusSet(XCP_DISCONNECTED);\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return XCP_PROTO_SUCCESS;\n}\n\n/*****************************************************************************\n    XCP GET_STATUS\n******************************************************************************/\nstatic XcpProtoErrorCode getStatusInputPacketHandler(void   *msgBuffer,\n                                                     size_t  xcpPacketOffset,\n                                                     size_t *outputPacketSize)\n{\n    XCP_UNUSED_PARAM(msgBuffer);\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    XCP_PRINTF(\"GET STATUS\\n\");\n\n    *outputPacketSize = XCP_GET_STATUS_RES_PACKET_SIZE_IN_BYTES;\n\n    return XCP_PROTO_SUCCESS;\n}\n\nstatic void getStatusOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize)\n{\n    XcpGetStatusResPacketFrame *frame = (XcpGetStatusResPacketFrame *)packet;\n\n    XCP_UNUSED_PARAM(inputCode);\n    XCP_UNUSED_PARAM(packetSize);\n\n    /* Fill Get Status response */\n    XCP_MEMSET(frame, 0, sizeof(*frame));\n\n    frame->PID                      = XCP_PID_RES;\n    frame->sessionStatus            = xcpSessionStatusGet();\n    frame->resourceProtectionStatus = xcpResourceProtectionStatusGet();\n    frame->sessionConfigurationId   = xcpSessionConfigurationIdGet();\n\n    XCP_PRINTF(\"* Session Status:              %xH\\n\", frame->sessionStatus);\n    XCP_PRINTF(\"* Resource Protection Status:  %xH\\n\", frame->resourceProtectionStatus);\n    XCP_PRINTF(\"* Session Config Id:           %d\\n\", frame->sessionConfigurationId);\n}\n\n/*****************************************************************************\n    XCP SYNCH\n******************************************************************************/\n#define XCP_SYNC_RES_PACKET_SIZE_IN_BYTES 2\n\nstatic XcpProtoErrorCode synchInputPacketHandler(void   *msgBuffer,\n                                                 size_t  xcpPacketOffset,\n                                                 size_t *outputPacketSize)\n{\n    boolean_T locked = false;\n\n    XCP_UNUSED_PARAM(msgBuffer);\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    XCP_PRINTF(\"SYNCH\\n\");\n\n    /* Make sure that no DAQ list is currently\n       in the process of sending packets */\n    locked = xcpDaqLock();\n\n    if (locked) {\n        /* Re-synchronizing the transport layer, by flushing the TX packets currently\n           in the TX FIFO and restarting the frame handler */\n        xcpTransportResynch();\n\n        xcpDaqUnlock();\n    }\n\n    *outputPacketSize = XCP_SYNC_RES_PACKET_SIZE_IN_BYTES;\n\n    return XCP_PROTO_SYNCH;\n}\n\n\n#if XCP_SET_MTA_ENABLE == 1\n/*****************************************************************************\n    XCP SET_MTA\n******************************************************************************/\n    static XcpProtoErrorCode setMTAInputPacketHandler(void  *msgBuffer, \n        size_t  xcpPacketOffset, \n        size_t *outputPacketSize) {\n\n        XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n        uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n        XcpSetMTACmdPacketFrame *frame = (XcpSetMTACmdPacketFrame *)packet;\n        boolean_T ok = false;\n\n        /* Check if the memory address is valid and set the MTA pointer */\n        ok = xcpStandardSetMta(frame->address, (uint8_T)frame->addressExtension);\n        XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_ACCESS_DENIED, (\"SET_MTA: invalid address\\n\"));\n        \n        XCP_PRINTF(\"SET_MTA: setting MTA value to %x and extension %x\\n\", frame->address, frame->addressExtension);    \n\n        *outputPacketSize = sizeof(XcpGenericResPacketFrame);\n\n        return protoErrorCode;\n    }\n\n/*****************************************************************************\n    XCP UPLOAD\n******************************************************************************/\n    static XcpProtoErrorCode uploadInputPacketHandler(void   *msgBuffer,\n        size_t  xcpPacketOffset,\n        size_t *outputPacketSize) {\n\n        XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n        uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n        XcpUploadCmdPacketFrame *frame = (XcpUploadCmdPacketFrame *)packet;\n        boolean_T ok = false;\n        uint8_T *xcpMTARawPointer = xcpStandardGetAddressFromMta();\n\n        /* Check if the number of data elements is valid */\n        ok = isValidUploadSize((uint8_T)frame->size);\n        XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n            (\"UPLOAD: invalid number of data elements (%d)\\n\", (uint8_T)frame->size));\n        \n        /* Check if a valid MTA address is available */\n        XCP_INPUT_PKT_ERROR_IF(xcpMTARawPointer == 0, XCP_PROTO_ACCESS_DENIED,\n            (\"UPLOAD: invalid address\\n\"));\n        \n        xcpUploadSize = (uint8_T)frame->size;\n        *outputPacketSize = XCP_UPLOAD_RES_PACKET_SIZE_IN_BYTES + XCP_IN_BYTES(xcpUploadSize);\n\n        return protoErrorCode;\n    }\n\n    \n    static void uploadOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize) {\n        \n        if (inputCode == XCP_PROTO_SUCCESS) {\n\n            /* Fill Upload response */\n            uint8_T *xcpMTARawPointer = xcpStandardGetAddressFromMta();\n            XcpUploadResPacketFrame *frame = (XcpUploadResPacketFrame *)packet;\n            XCP_MEMSET(frame, 0, sizeof(*frame));\n            frame->PID = XCP_PID_RES;\n\n            if ((xcpMTARawPointer != NULL) &&\n                (packetSize == (XCP_UPLOAD_RES_PACKET_SIZE_IN_BYTES + XCP_IN_BYTES(xcpUploadSize)))\n                ) {\n                uint8_T *pktData = (uint8_T *)packet + XCP_IN_AG(XCP_UPLOAD_RES_PACKET_SIZE_IN_BYTES);\n                uint8_T dstOffsetBytes = (XCP_UPLOAD_RES_PACKET_SIZE_IN_BYTES % XCP_HARDWARE_ADDRESS_GRANULARITY_BYTES_NUMBER);\n\n                XCP_PRINTF(\"UPLOAD: \");\n                \n                /* Copy the memory content to the packet data area */\n                xcpMemcpyFromMTA(pktData, dstOffsetBytes);\n\n                /* Post-increment MTA by the frame size in address granularity units */\n                xcpStandardIncrementMta(xcpUploadSize);\n                xcpUploadSize = 0;\n            }\n            else {\n                /* This is a software error and it should never happen */\n                XCP_PRINTF(\"UPLOAD: invalid data detected\\n\");\n            }\n        }\n        else {\n            genericOutputPacketHandler(inputCode, packet, packetSize);\n        }\n    }\n#endif  /* XCP_SET_MTA_ENABLE == 1  */\n\n\n/*****************************************************************************\n    XCP SHORT_UPLOAD\n******************************************************************************/\nstatic XcpProtoErrorCode shortUploadInputPacketHandler(void   *msgBuffer,\n    size_t  xcpPacketOffset,\n    size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpShortUploadCmdPacketFrame *frame = (XcpShortUploadCmdPacketFrame *)packet;\n    boolean_T ok = false;\n\n    /* Check if the number of data elements is valid */\n    ok = isValidUploadSize((uint8_T)frame->size);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"SHORT_UPLOAD: invalid number of data elements (%d)\\n\", (uint8_T)frame->size));\n\n    /* Check if the memory address is valid and set the MTA pointer */\n    ok = xcpStandardSetMta(frame->address, (uint8_T)frame->addressExtension);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_ACCESS_DENIED, (\"SHORT_UPLOAD: invalid address\\n\"));\n\n    xcpUploadSize = (uint8_T)frame->size;\n\n    *outputPacketSize = XCP_SHORT_UPLOAD_RES_PACKET_SIZE_IN_BYTES + XCP_IN_BYTES(xcpUploadSize);\n\n    return protoErrorCode;\n}\n\nstatic void shortUploadOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize)\n{    \n    if (inputCode == XCP_PROTO_SUCCESS) {\n\n        /* Fill Short Upload response */\n        uint8_T *xcpMTARawPointer = xcpStandardGetAddressFromMta();\n        XcpShortUploadResPacketFrame *frame = (XcpShortUploadResPacketFrame *)packet;\n        XCP_MEMSET(frame, 0, sizeof(*frame));\n\n        frame->PID = XCP_PID_RES;\n\n        if ((xcpMTARawPointer != NULL) &&\n            (packetSize == XCP_SHORT_UPLOAD_RES_PACKET_SIZE_IN_BYTES + XCP_IN_BYTES(xcpUploadSize) )\n           ) {\n            uint8_T *pktData = (uint8_T *)packet + XCP_IN_AG(XCP_SHORT_UPLOAD_RES_PACKET_SIZE_IN_BYTES);\n            uint8_T dstOffsetBytes = (XCP_SHORT_UPLOAD_RES_PACKET_SIZE_IN_BYTES % XCP_HARDWARE_ADDRESS_GRANULARITY_BYTES_NUMBER);\n\n            XCP_PRINTF(\"SHORT_UPLOAD: \");\n\n            /* Copy the memory content to the packet data area */\n            xcpMemcpyFromMTA(pktData, dstOffsetBytes);\n\n            /* Post-increment MTA by the frame size in address granularity units */\n            xcpStandardIncrementMta(xcpUploadSize);\n\n            xcpUploadSize = 0;\n        }\n        else {\n            /* This is a software error and it should never happen */\n            XCP_PRINTF(\"SHORT_UPLOAD: invalid data detected\\n\");\n        }\n    }\n    else {\n        genericOutputPacketHandler(inputCode, packet, packetSize);\n    }\n}\n\n\n/** This table contains the list of supported Rx packets and the corresponding handlers */\nstatic const XcpPacketHandlers standardSupportedRxPacket[] =\n{\n    { XCP_PID_CONNECT,      connectInputPacketHandler,     connectOutputPacketHandler },\n    { XCP_PID_DISCONNECT,   disconnectInputPacketHandler,  genericOutputPacketHandler },\n    { XCP_PID_GET_STATUS,   getStatusInputPacketHandler,   getStatusOutputPacketHandler },\n    { XCP_PID_SYNCH,        synchInputPacketHandler,       genericOutputPacketHandler },\n#if XCP_SET_MTA_ENABLE == 1  \n    { XCP_PID_SET_MTA,      setMTAInputPacketHandler,      genericOutputPacketHandler },\n    { XCP_PID_UPLOAD,       uploadInputPacketHandler,      uploadOutputPacketHandler},\n#endif\n    { XCP_PID_SHORT_UPLOAD, shortUploadInputPacketHandler, shortUploadOutputPacketHandler }\n};\n\n\n\n/*****************************************************************************\n    XCP Packet Lookup Function for basic standard commands\n******************************************************************************/\n\n/* Default Standard Packet Lookup function, supporting only basic commands\n   listed in the table above */\nstatic const XcpPacketHandlers* getPacket(XcpRxPidCode pid)\n{\n    return xcpFindPacket(pid, standardSupportedRxPacket,\n                         XCP_ELEMENTS_NUMBER(standardSupportedRxPacket));\n}\n\nstatic XcpPacketLookupFunction packetLookup = NULL;\n\n\n\n/*****************************************************************************\n    Public Functions (invoked within the Protocol Layer)\n******************************************************************************/\nvoid xcpStandardInit(void)\n{\n    /* Initialize the packet lookup function to support only basic\n       standard commands */\n    xcpStandardSetPacketLookup(getPacket);\n\n    /* Initialize support for the extended list of Standard commands\n       @note this may override the default Packet lookup function\n             by adding support for more (optional) commands */\n    xcpStandardExtendedInit();\n}\n\n\nXcpPacketLookupFunction xcpStandardGetPacketLookup(void)\n{\n    return packetLookup;\n}\n\n\nvoid xcpStandardSetPacketLookup(XcpPacketLookupFunction getPacket)\n{\n    packetLookup = getPacket;\n}\n\n\nvoid xcpStandardReset(void)\n{\n    /* reset support for the extended list of Standard commands */\n    xcpStandardExtendedReset();\n\n    /* Restore the original value for the lookup function */\n    xcpStandardSetPacketLookup(NULL);\n}\n\n\nuint8_T* xcpStandardGetAddressFromMta(void) {\n    return XCP_ADDRESS_GET_INTERNAL(xcpMta.addressExtension, xcpMta.address);\n}\n\n\nboolean_T xcpStandardSetMta(uint32_T address, uint8_T addressExtension) {\n    if ((addressExtension == 0) && (address == 0)) {\n        return false;\n    } else {\n        xcpMta.address = address;\n        xcpMta.addressExtension = addressExtension;\n        return true;\n    }\n}\n\n\nvoid xcpStandardGetMta(uint32_T *address, uint8_T *addressExtension) {\n    *address = xcpMta.address;\n    *addressExtension = xcpMta.addressExtension;\n}\n\n\nvoid xcpStandardIncrementMta(uint8_T incr) {\n    xcpMta.address += incr;\n}\n\n\n#ifndef XCP_STANDARD_EXTENDED_SUPPORT\n\nvoid xcpStandardExtendedInit(void) {}\nvoid xcpStandardExtendedReset(void) {}\n\n#endif\n"},{"name":"xcp_transport.c","type":"source","group":"legacy","path":"E:\\Matlab\\toolbox\\coder\\xcp\\src\\target\\slave\\transport\\src","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2020 The MathWorks, Inc.\n*\n* File: xcp_transport.c\n*\n* Abstract:\n*  Implementation of XCP Transport Layer.\n*  The file contains the common part that is responsible for the handling\n*  of Tx/Rx buffers and relies on the Xcp Driver and Xcp Frame Handler layers\n*  for sending and receiving data to/from the supported transport layer specification\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp.h\"\n#include \"xcp_transport.h\"\n#include \"xcp_transport_types.h\"\n#include \"xcp_transport_internal.h\"\n#include \"xcp_frame.h\"\n#include \"xcp_fifo.h\"\n#include \"xcp_mem.h\"\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n#include \"xcp_daq_types.h\"\n#endif\n\n/** Number of supported Tx queues */\n\n#define XCP_TRANSPORT_TX_QUEUES_TYPES_NUMBER     2\n\n/** Number of supported Rx queues */\n#define XCP_TRANSPORT_RX_QUEUES_TYPES_NUMBER  1\n\n\n/* In this Transport Layer implementation, the memory buffer associated with a generic\n   XCP message has the following format:\n\n   --------------      +---->  --------------\n  | xcpFifoEntry | ----+      | xcpFifoEntry |\n   --------------              --------------\n  | XCP Header   |            | XCP Header   |\n   --------------              --------------\n  | XCP Packet   |            | XCP Packet   |\n   --------------              --------------\n\n  xcpFifoEntry is an internal data structure used to implement a FIFO through a single linked list\n*/\n\n\n\n/* Transmit FIFOs */\nstatic struct xcpFifo txFifo[XCP_TRANSPORT_TX_QUEUES_TYPES_NUMBER];\n\nstatic XCP_MUTEX_DEFINE(txLock);\n\n/* Receive FIFOs */\nstatic struct xcpFifo rxFifo[XCP_TRANSPORT_RX_QUEUES_TYPES_NUMBER];\n\nstatic XCP_MUTEX_DEFINE(rxLock);\n\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n\n#if XCP_MEM_DAQ_RESERVED_POOLS_NUMBER <= 0\n#error  \"XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT requires a XCP_MEM_DAQ_RESERVED_POOLS_NUMBER value greater than 0\"\n#endif\n\nstatic struct xcpFifo daqDeferredTxFifo[XCP_MEM_DAQ_RESERVED_POOLS_NUMBER];\nstatic struct xcpFifo daqTxFifo[XCP_MEM_DAQ_RESERVED_POOLS_NUMBER];\nstatic boolean_T      daqTxRequest[XCP_MEM_DAQ_RESERVED_POOLS_NUMBER];\nstatic uint16_T       lastDaqIdTx = 0xFFFF;\n\n#endif\n\n\n/* true if the Transport Layer has been successfully initialized */\nstatic boolean_T  initialized = false;\n\n/* ID of the memory pool reserved for the allocation of\n    CTO XCP Packets */\nstatic xcpPoolId_T xcpCtoReservedMemPoolId = -1;\n\n\n#ifdef XCP_DEBUG_SUPPORT\nstatic const char *xcpTransportDiagDataString[XCP_TRANSPORT_COUNTERS_NUMBER] = {\n    \"XCP_TRANSPORT_INIT_COUNTER               \",\n    \"XCP_TRANSPORT_TX_COUNTER                 \",\n    \"XCP_TRANSPORT_TX_PACKET_SET_COUNTER      \",\n    \"XCP_TRANSPORT_RX_PACKET_GET_COUNTER      \",\n    \"XCP_TRANSPORT_RX_COUNTER                 \",\n    \"XCP_TRANSPORT_RESTART_COUNTER            \",\n    \"XCP_TRANSPORT_RESYNCH_COUNTER            \",\n    \"XCP_TRANSPORT_RESET_COUNTER              \",\n    \"XCP_TRANSPORT_MEM_INIT_ERROR             \",\n    \"XCP_TRANSPORT_MEM_RESET_ERROR            \",\n    \"XCP_TRANSPORT_FRAME_INIT_ERROR           \",\n    \"XCP_TRANSPORT_FRAME_CREATE_MSG_ERROR     \",\n    \"XCP_TRANSPORT_FRAME_SEND_ERROR           \",\n    \"XCP_TRANSPORT_FRAME_RECV_ERROR           \",\n    \"XCP_TRANSPORT_FRAME_EXTRACT_PACKET_ERROR \",\n    \"XCP_TRANSPORT_FRAME_RESTART_ERROR        \",\n    \"XCP_TRANSPORT_FRAME_RESET_ERROR          \",\n    \"XCP_TRANSPORT_TX_PACKET_IN_COUNTER       \",\n    \"XCP_TRANSPORT_TX_PACKET_OUT_COUNTER      \",\n    \"XCP_TRANSPORT_TX_PACKET_FREED_COUNTER    \",\n    \"XCP_TRANSPORT_TX_IS_EMPTY_COUNTER        \",\n    \"XCP_TRANSPORT_RX_PACKET_IN_COUNTER       \",\n    \"XCP_TRANSPORT_RX_PACKET_OUT_COUNTER      \",\n    \"XCP_TRANSPORT_RX_PACKET_FREED_COUNTER    \",\n    \"XCP_TRANSPORT_RX_IS_EMPTY_COUNTER        \"\n};\n\nstatic XcpTransportDiagnostic xcpTransportDiagnostic;\n\n\nvoid xcpTransportDiagnosticReset(void)\n{\n    XCP_MEMSET(&xcpTransportDiagnostic, 0, sizeof(xcpTransportDiagnostic));\n}\n\n\nvoid xcpTransportDiagnosticGet(XcpTransportDiagnostic *diag)\n{\n    XCP_MEMCPY(diag, &xcpTransportDiagnostic, sizeof(xcpTransportDiagnostic));\n}\n\n\nvoid xcpTransportDiagnosticPrint(const XcpTransportDiagnostic *diag)\n{\n    if (diag != NULL) {\n        int i = 0;\n        for (i = 0; i < XCP_TRANSPORT_COUNTERS_NUMBER; i++) {\n            XCP_PRINTF(\"%s = %lu\\n\", xcpTransportDiagDataString[i], (unsigned long) xcpTransportDiagnostic.data[i]);\n        }\n    }\n}\n\n#define XCP_DIAG_UPDATE(counterId)     xcpTransportDiagnostic.data[counterId]++\n\n#else\n\n#define XCP_DIAG_UPDATE(counterId) \n\n#endif\n\n/* Empty the TX FIFO by deleting the existing packets */\nstatic void xcpTransportEmptyTxFifo(void)\n{\n    struct xcpFifoEntry *msgBufferHeader = NULL;\n    uint16_T i = 0;\n\n    XCP_MUTEX_LOCK(txLock);\n\n    for (i = 0; i < XCP_TRANSPORT_TX_QUEUES_TYPES_NUMBER; i++) {\n        do {\n            xcpFifoDequeue(&txFifo[i], &msgBufferHeader);\n\n            if (msgBufferHeader != NULL) {\n                xcpMemFree(msgBufferHeader);\n                XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_PACKET_FREED_COUNTER);\n            }\n        } while (msgBufferHeader != NULL);\n    }\n\n    XCP_MUTEX_UNLOCK(txLock);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    for (i = 0; i < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER; i++) {\n        do {\n            xcpFifoDequeue(&daqTxFifo[i], &msgBufferHeader);\n\n            if (msgBufferHeader != NULL) {\n                xcpMemFree(msgBufferHeader);\n                XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_PACKET_FREED_COUNTER);\n            }\n        } while (msgBufferHeader != NULL);\n\n        do {\n            xcpFifoDequeue(&daqDeferredTxFifo[i], &msgBufferHeader);\n\n            if (msgBufferHeader != NULL) {\n                xcpMemFree(msgBufferHeader);\n                XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_PACKET_FREED_COUNTER);\n            }\n        } while (msgBufferHeader != NULL);\n\n        daqTxRequest[i] = false;\n    }\n    lastDaqIdTx = 0xFFFF;\n#endif\n}\n\n\n/* Empty the RX FIFO by deleting the existing packets */\nstatic void xcpTransportEmptyRxFifo(void)\n{\n    struct xcpFifoEntry *msgBufferHeader = NULL;\n    XcpTransportQueueType_T i = 0;\n\n    XCP_MUTEX_LOCK(rxLock);\n\n    for (i = 0; i < XCP_TRANSPORT_RX_QUEUES_TYPES_NUMBER; i++) {\n        do {\n            xcpFifoDequeue(&rxFifo[i], &msgBufferHeader);\n\n            if (msgBufferHeader != NULL) {\n                xcpMemFree(msgBufferHeader);\n                XCP_DIAG_UPDATE(XCP_TRANSPORT_RX_PACKET_FREED_COUNTER);\n            }\n        } while (msgBufferHeader != NULL);\n    }\n\n    XCP_MUTEX_UNLOCK(rxLock);\n}\n\n\nXcpErrorCode xcpTransportInit(int argc, void * argv[])\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    uint16_T i = 0;\n\n    XCP_ERROR_IF(initialized, XCP_ERROR, \"xcpTransportInit: transport layer already initialized\\n\");\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_INIT_COUNTER);\n\n    /* Initialize Tx and Rx data structures*/\n    for (i = 0; i < XCP_TRANSPORT_TX_QUEUES_TYPES_NUMBER; i++) {\n        xcpFifoInit(&txFifo[i]);\n    }\n    XCP_MUTEX_INIT(txLock);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    for (i = 0; i < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER; i++) {\n        xcpFifoInit(&daqTxFifo[i]);\n        xcpFifoInit(&daqDeferredTxFifo[i]);\n        daqTxRequest[i] = false;\n    }\n    lastDaqIdTx = 0xFFFF;\n#endif\n\n    for (i = 0; i < XCP_TRANSPORT_RX_QUEUES_TYPES_NUMBER; i++) {\n        xcpFifoInit(&rxFifo[i]);\n    }\n    XCP_MUTEX_INIT(rxLock);\n\n    /* Initialize XCP memory allocator */\n    errorCode = xcpMemInit();\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportInit: error (%d) detected during memory allocator initialization\\n\", errorCode);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_MEM_INIT_ERROR);\n        return errorCode;\n    }\n\n    {\n        /* Allocate the memory pool reserved for the allocation\n           of CTO, EV and SERV XCP Packets */\n        size_t maxCtoSize = xcpTransportMaxCtoSize();\n        size_t maxBufferSize = xcpTransportMsgBufferSize(maxCtoSize, XCP_CTO);\n\n        errorCode = xcpMemReservedPoolCreate(maxBufferSize, XCP_MEM_CTO_RESERVED_POOL_BLOCKS_NUMBER,\n                                             &xcpCtoReservedMemPoolId);\n\n        if (errorCode != XCP_SUCCESS) {\n            XCP_PRINTF(\"xcpTransportInit: error (%d) detected during allocation of reserved memory pool\\n\", errorCode);\n            XCP_DIAG_UPDATE(XCP_TRANSPORT_MEM_INIT_ERROR);\n            return errorCode;\n        }\n\n        xcpFrameSetCtoReservedMemPoolId(xcpCtoReservedMemPoolId);\n    }\n\n    /* Initialize XCP Frame handler */\n    errorCode = xcpFrameInit(argc, argv);\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportInit: error (%d) detected during frame handler initialization\\n\", errorCode);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_INIT_ERROR);\n        return errorCode;\n    }\n\n    initialized = true;\n\n    return errorCode;\n}\n\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n\nboolean_T xcpTransportTxReady(\n    XcpTransportQueueType_T queueType, /**< [in] type of the TX queue the packet has to be sent to */\n\tuint16_T daqId                     /**< [in] id of the DAQ list the packet refers to */\n)\n{\n    boolean_T ready = true;\n    /* In the lockless implementation we enqueue data only\n       if the previous transmission has been completed */\n    if ((queueType == XCP_TRANSPORT_TX_DEFAULT_QUEUE) &&\n        (daqId <  XCP_MEM_DAQ_RESERVED_POOLS_NUMBER)) {\n        ready = !daqTxRequest[daqId];\n    }\n\n    return ready;\n}\n\n\n/** If lockless streaming is enabled, trigger the transmission of\n    packets previously enqueued (by invoking xcpTransportTxPacketSet.\n    The function returns XCP_BUSY if the TX request is already\n    in progress */\nXcpErrorCode  xcpTransportTxTrigger(\n    XcpTransportQueueType_T queueType, /**< [in] type of the TX queue the packet has to be sent to */\n    uint16_T daqId                     /**< [in] id of the DAQ list the packet refers to */\n)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    if ((queueType != XCP_TRANSPORT_TX_DEFAULT_QUEUE) ||\n        (daqId >= XCP_MEM_DAQ_RESERVED_POOLS_NUMBER)) {\n        return XCP_INV_ARG;\n    }\n\n    if (!daqTxRequest[daqId]) {\n        if (!xcpFifoEmpty(daqDeferredTxFifo)) {\n            /* If the transmission of any packets was deferred \n               from previous run, we need to enqueue them at the\n               head of the daqTxFifo, as they need to be sent first */\n            xcpFifoSpliceHead(daqTxFifo, daqDeferredTxFifo);\n        }\n\n        XCP_MEM_BARRIER();\n        daqTxRequest[daqId] = true;\n    } else {\n        errorCode = XCP_BUSY;\n    }\n\n    return errorCode;\n}\n\n#else\n\nboolean_T xcpTransportTxReady(\n    XcpTransportQueueType_T queueType, /**< [in] type of the TX queue the packet has to be sent to */\n    uint16_T daqId                     /**< [in] id of the DAQ list the packet refers to */\n)\n{\n    XCP_UNUSED_PARAM(queueType);\n    XCP_UNUSED_PARAM(daqId);\n\n    /* In the standard (mutex-based) implementation we can always enqueue\n       new packets and therefore TX is always ready*/\n    return true;\n}\n\n\nXcpErrorCode  xcpTransportTxTrigger(\n    XcpTransportQueueType_T queueType, /**< [in] type of the TX queue the packet has to be sent to */\n    uint16_T daqId                     /**< [in] id of the DAQ list the packet refers to */\n)\n{\n    /* In the standard (mutex-based) implementation the transmission\n       is always in progress, as long as there are samples in the TX fifo.\n       For this reasons this method has no effect in this case */\n    XCP_UNUSED_PARAM(queueType);\n    XCP_UNUSED_PARAM(daqId);\n\n    return XCP_SUCCESS;\n}\n\n#endif\n\n\nXcpErrorCode xcpTransportTxPacketSet(\n    XcpTransportQueueType_T queueType, /**< [in] id of the TX queue the packet has to be sent to */\n    uint16_T daqId,       /**< [in] id of the DAQ list the packet refers to */\n    void  *msgBuffer,       /* [in] pointer to the buffer containing the full XCP message */\n    size_t msgBufferSize,   /* [in] size (in AG units) of the buffer */\n    size_t xcpPktOffset,    /* [in] offset (in AG units) where the actual XCP packet content has been copied (within xcpMsg buffer)  */\n    size_t xcpPktSize       /* [in] size (in BYTEs) of the XCP packet */\n    )\n{\n    struct xcpFifoEntry *msgBufferHeader = NULL;\n    uint8_T *msgFrame = NULL;\n    size_t msgFrameMaxSize = 0;\n    size_t msgFrameSize = 0;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    /* Lock must be excluded for DAQ lists associated to reserved memory pools */\n    boolean_T locklessTx = ((queueType == XCP_TRANSPORT_TX_DEFAULT_QUEUE)   ||\n                            (queueType == XCP_TRANSPORT_DEFERRED_TX_QUEUE)) &&\n                            (daqId < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER);\n#else\n    XCP_UNUSED_PARAM(daqId);\n#endif\n\n    /* Input parameters validation */\n    XCP_ERROR_IF((queueType != XCP_TRANSPORT_DEFERRED_TX_QUEUE) && \n                 ((queueType < 0) || (queueType >= XCP_TRANSPORT_TX_QUEUES_TYPES_NUMBER)), \n                 XCP_INV_ARG, \"xcpTransportTxPacketSet: invalid queueType\\n\");\n    XCP_ERROR_IF(msgBuffer == NULL, XCP_INV_ARG, \"xcpTransportTxPacketSet: invalid msgBuffer\\n\");\n    XCP_ERROR_IF(xcpPktOffset != xcpTransportPacketOffset(), XCP_INV_ARG, \"xcpTransportTxPacketSet: invalid packet offset\\n\");\n    XCP_ERROR_IF(xcpPktSize == 0, XCP_INV_ARG, \"xcpTransportTxPacketSet: invalid packet size\\n\");\n    XCP_ERROR_IF(msgBufferSize < (xcpPktOffset + XCP_IN_HW_AG(xcpPktSize)), XCP_INV_ARG, \"xcpTransportTxPacketSet: invalid msgBufferSize\\n\");\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpTransportTxPacketSet: transport layer not initialized\\n\");\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_PACKET_SET_COUNTER);\n\n    msgBufferHeader = (struct xcpFifoEntry *) msgBuffer;\n    msgFrame = (uint8_T *)msgBuffer + sizeof(struct xcpFifoEntry);\n    msgFrameMaxSize = msgBufferSize - sizeof(struct xcpFifoEntry);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    if (!locklessTx) {\n#endif\n    /* Now fill the XCP frame content \n       @note the lock is used to protect the txFifo data structures from concurrent execution */\n    XCP_MUTEX_LOCK(txLock);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    }\n#endif\n\n    errorCode = xcpFrameCreateMsg(msgFrame, msgFrameMaxSize, &msgFrameSize, xcpPktSize);\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportTxPacketSet: xcpFrameCreateMsg failure detected (%d)\\n\", errorCode);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_CREATE_MSG_ERROR);\n        goto error;\n    }\n\n    msgBufferHeader->msgFrameSize = msgFrameSize;\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    if (!locklessTx) {\n#endif\n        /* Now that the packet has been created, we can add it to the txFifo for transmission */\n        xcpFifoEnqueue(&txFifo[queueType], msgBufferHeader);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    } else {\n        if (queueType == XCP_TRANSPORT_DEFERRED_TX_QUEUE) {\n            xcpFifoEnqueue(&daqDeferredTxFifo[daqId], msgBufferHeader);\n        } else {\n         xcpFifoEnqueue(&daqTxFifo[daqId], msgBufferHeader);\n        }\n    }\n#endif\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_PACKET_IN_COUNTER);\n\nerror:\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    if (!locklessTx) {\n#endif\n    XCP_MUTEX_UNLOCK(txLock);\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    }\n#endif\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpTransportTx(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t msgFrameSize = 0;\n    struct xcpFifoEntry *msgBufferHeader = NULL;\n    XcpTransportQueueType_T queueType = XCP_TRANSPORT_TX_HIGHEST_PRIO_QUEUE;\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    /* Lock must be excluded for DAQ lists associated to reserved memory pools */\n    boolean_T locklessTx = false;\n#endif\n\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpTransportTx: transport layer not initialized\\n\");\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_COUNTER);\n\n    XCP_MUTEX_LOCK(txLock);\n    /* Extract the message from the Fifos, starting from the highest priority */\n    xcpFifoDequeue(&txFifo[queueType], &msgBufferHeader);\n\n    XCP_MUTEX_UNLOCK(txLock);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    if (msgBufferHeader == NULL) {\n        uint16_T i = 0;\n        /* If the highest priority is empty, check if one of the DAQ-specific ones\n           has a pending request */\n        for (i = 0; (i < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER) && !locklessTx; i++) {\n            lastDaqIdTx = (lastDaqIdTx + 1) %  XCP_MEM_DAQ_RESERVED_POOLS_NUMBER;\n            if (daqTxRequest[lastDaqIdTx]) {\n                xcpFifoDequeue(&daqTxFifo[lastDaqIdTx], &msgBufferHeader);\n                if (msgBufferHeader == NULL) {\n                    /* if no data are available, we can acknowledge the request\n                       straight away */\n                    daqTxRequest[lastDaqIdTx] = false;\n                } else {\n                    locklessTx = true;\n                }\n            }\n        }\n    }\n#endif\n    if (msgBufferHeader == NULL) {\n        /* If the highest priority is empty, and no DAQ packets are available\n           try the default queue */\n        XCP_MUTEX_LOCK(txLock);\n\n        queueType = XCP_TRANSPORT_TX_DEFAULT_QUEUE;\n        xcpFifoDequeue(&txFifo[queueType], &msgBufferHeader);\n        XCP_MUTEX_UNLOCK(txLock);\n    }\n\n    if (msgBufferHeader != NULL) {\n        msgFrameSize = msgBufferHeader->msgFrameSize;\n\n        /* Trying to send one XCP message via the frame handler\n           @note The frame handler will be responsible for releasing\n                 the message buffer if the data has been successfully sent\n                 (return code XCP_SUCCESS).\n                 If not, the memory area won't be freed and the message\n                 will need to go back to the FIFO. */\n        errorCode = xcpFrameMsgSend(msgBufferHeader, sizeof(struct xcpFifoEntry), msgFrameSize);\n\n        if (errorCode != XCP_SUCCESS) {\n            XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_SEND_ERROR);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n            if (!locklessTx) {\n#endif\n            XCP_MUTEX_LOCK(txLock);\n\n            xcpFifoEnqueueHead(&txFifo[queueType], msgBufferHeader);\n\n            XCP_MUTEX_UNLOCK(txLock);\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n            } else {\n                xcpFifoEnqueueHead(&daqTxFifo[lastDaqIdTx], msgBufferHeader);\n            }\n#endif\n        } else {\n            XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_PACKET_OUT_COUNTER);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n            if (locklessTx && xcpFifoEmpty(&daqTxFifo[lastDaqIdTx])) {\n                /* All packets in the queue have been sent,\n                   the request can be acknowledged */\n                XCP_MEM_BARRIER();\n                daqTxRequest[lastDaqIdTx] = false;\n            }\n#endif\n        }\n    } else {\n        errorCode = XCP_EMPTY;\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_IS_EMPTY_COUNTER);\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpTransportRx(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t msgFrameSize = 0;\n    struct xcpFifoEntry *msgBufferHeader = NULL;\n\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpTransportRx: transport layer not initialized\\n\");\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_RX_COUNTER);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    /* Make sure that the blocks associated to the CTO reserved memory\n       pool are made available for subsequent allocations */\n    xcpMemReservedPoolFlushFreeMem(xcpCtoReservedMemPoolId);\n#endif\n\n    /* Trying to receive one XCP message via the frame handler\n       @note The frame handler is also responsible for allocating the\n             memory area and it is no longer responsible for the ownership\n             of the memory if the function has been successfully executed\n             (error code XCP_SUCCESS)\n             If there are no messages available, the return code is XCP_EMPTY */\n    errorCode = xcpFrameMsgRecv((void**) &msgBufferHeader, sizeof(struct xcpFifoEntry), &msgFrameSize);\n\n    if (errorCode == XCP_SUCCESS) {\n        /* Add the message to the Fifo */\n        msgBufferHeader->msgFrameSize = msgFrameSize;\n\n        XCP_MUTEX_LOCK(rxLock);\n\n        /* Only one RX queue available */\n        xcpFifoEnqueue(&rxFifo[XCP_TRANSPORT_RX_DEFAULT_QUEUE], msgBufferHeader);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_RX_PACKET_IN_COUNTER);\n\n        XCP_MUTEX_UNLOCK(rxLock);\n    } else if (errorCode == XCP_EMPTY) {\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_RX_IS_EMPTY_COUNTER);\n    } else {\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_RECV_ERROR);\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpTransportRxPacketGet(\n    XcpTransportQueueType_T queueType, /**< [in] id of the RX queue the packet has to be received from */\n    void  **msgBuffer,     /* [out] pointer to the buffer containing the full XCP message that has been extracted */\n    size_t *msgBufferSize, /* [out] size (in AG units) of the buffer */\n    size_t *xcpPktOffset,  /* [out] offset (in AG units) of the XCP packet within the message buffer */\n    size_t *xcpPktSize     /* [out] size (in BYTEs) of the XCP packet */\n    )\n{\n    struct xcpFifoEntry *msgBufferHeader = NULL;\n    uint8_T *msgFrame = NULL;\n    size_t msgFrameSize = 0;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    /* Input parameters validation */\n    XCP_ERROR_IF((queueType < 0) || (queueType >= XCP_TRANSPORT_RX_QUEUES_TYPES_NUMBER), XCP_INV_ARG, \"xcpTransportRxPacketGet: invalid queueType\\n\");\n    XCP_ERROR_IF(msgBuffer == NULL, XCP_INV_ARG, \"xcpTransportRxPacketGet: invalid msgBuffer pointer\\n\");\n    XCP_ERROR_IF(msgBufferSize == NULL, XCP_INV_ARG, \"xcpTransportRxPacketGet: invalid msgBufferSize pointer\\n\");\n    XCP_ERROR_IF(xcpPktOffset == NULL, XCP_INV_ARG, \"xcpTransportRxPacketGet: invalid xcpPktOffset pointer\\n\");\n    XCP_ERROR_IF(xcpPktSize == NULL, XCP_INV_ARG, \"xcpTransportRxPacketGet: invalid xcpPktSize pointer\\n\");\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpTransportRxPacketGet: transport layer not initialized\\n\");\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_RX_PACKET_GET_COUNTER);\n\n    XCP_MUTEX_LOCK(rxLock);\n\n    xcpFifoDequeue(&rxFifo[queueType], &msgBufferHeader);\n\n    XCP_MUTEX_UNLOCK(rxLock);\n\n    if (msgBufferHeader == NULL) {\n        return XCP_EMPTY; /* No messages in the FIFO */\n    }\n    else {\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_RX_PACKET_OUT_COUNTER);\n    }\n\n    msgFrame = (uint8_T *) msgBufferHeader + sizeof(struct xcpFifoEntry);\n    msgFrameSize = msgBufferHeader->msgFrameSize;\n\n    /* Extract a new XCP packet from the XCP message, and carry out all the relevant checks in the frame format */\n    errorCode = xcpFrameExtractPacket(msgFrame, msgFrameSize, xcpPktSize);\n    if (errorCode != XCP_SUCCESS) {\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_EXTRACT_PACKET_ERROR);\n    }\n\n    *msgBuffer = msgBufferHeader;\n    *msgBufferSize = msgBufferHeader->msgFrameSize + sizeof(struct xcpFifoEntry);\n    *xcpPktOffset = xcpTransportPacketOffset();\n\n    return errorCode;\n}\n\n\nsize_t xcpTransportPacketOffset(void)\n{\n    size_t size = sizeof(struct xcpFifoEntry);\n\n    size += XCP_IN_HW_AG(xcpFrameHeaderSize());\n\n    return size;\n}\n\n/* xcpPacketSize is the number of octets in the XCP Packet\n * Return value the buffer size in terms of target memory granularity needed to contain this packet.\n * On 32-bit address granularity processor, a packet of 6 contiguous BYTEs, we require 2 memory\n *  locations to contain it.\n */\nsize_t xcpTransportMsgBufferSize(size_t xcpPacketSize, XcpPacketType pktType)\n{\n    size_t size = 0;\n    size_t maxPacketSize = 0;\n    \n    maxPacketSize = (pktType == XCP_CTO) ? xcpFrameMaxCtoSize() : xcpFrameMaxDtoSize();\n\n    if (xcpPacketSize > maxPacketSize) {\n        XCP_PRINTF(\"xcpTransportMsgSize: invalid xcpPacketSize\\n\");\n        return 0;\n    }\n\n    size = sizeof(struct xcpFifoEntry);\n\n    size += XCP_IN_HW_AG(xcpFrameHeaderSize());\n    size += XCP_IN_HW_AG(xcpPacketSize);\n    size += XCP_IN_HW_AG(xcpFrameTailSize());\n\n    return size;\n}\n\n\nsize_t xcpTransportMaxDtoSize(void)\n{\n    return xcpFrameMaxDtoSize();\n}\n\n\nsize_t xcpTransportMaxCtoSize(void)\n{\n    return xcpFrameMaxCtoSize();\n}\n\n\nXcpErrorCode xcpTransportRestart(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_RESTART_COUNTER);\n\n    /* Restart Frame Handler */\n    errorCode = xcpFrameRestart();\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportRestart: error (%d) detected during frame handler restart\\n\", errorCode);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_RESTART_ERROR);\n        return errorCode;\n    }\n\n    /* Empty TX and RX fifos */\n    xcpTransportEmptyTxFifo();\n    xcpTransportEmptyRxFifo();\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpTransportResynch(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_RESYNCH_COUNTER);\n\n    /* Restart Frame Handler */\n    errorCode = xcpFrameRestart();\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportRestart: error (%d) detected during frame handler restart\\n\", errorCode);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_RESTART_ERROR);\n        return errorCode;\n    }\n\n    /* Empty TX FIFO */\n    xcpTransportEmptyTxFifo();\n\n    return errorCode;\n}\n\n\nxcpPoolId_T xcpTransportCtoReservedMemPoolId(void)\n{\n    return xcpCtoReservedMemPoolId;\n}\n\n\nXcpErrorCode xcpTransportReset(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    XcpTransportQueueType_T i = 0;\n\n    if (!initialized) {\n        XCP_PRINTF(\"xcpTransportReset: transport layer already reset\\n\");\n        return XCP_SUCCESS; /* Nothing to do: just printing out a warning message*/\n    }\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_RESET_COUNTER);\n\n    /* Reset XCP Frame handler */\n    errorCode = xcpFrameReset();\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportReset: error (%d) detected during frame handler reset\\n\", errorCode);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_RESET_ERROR);\n        return errorCode;\n    }\n\n    /* Before resetting the txFifo and rxFifo, all the message buffers still enqueued need to be freed\n    as the ownership of the memory area was explicitly given to the Transport Layer */\n    xcpTransportEmptyTxFifo();\n    xcpTransportEmptyRxFifo();\n\n    /* Destroy the reserved memory pool */\n    xcpMemReservedPoolDestroy(xcpCtoReservedMemPoolId);\n\n    /* Reset XCP memory allocator */\n    errorCode = xcpMemReset();\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportReset: error (%d) detected during memory allocator reset\\n\", errorCode);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_MEM_RESET_ERROR);\n        return errorCode;\n    }\n\n    /* Now we can reset Tx and Rx Fifos */\n    /* Initialize Tx and Rx data structures*/\n    for (i = 0; i < XCP_TRANSPORT_TX_QUEUES_TYPES_NUMBER; i++) {\n        xcpFifoReset(&txFifo[i]);\n    }\n    for (i = 0; i < XCP_TRANSPORT_RX_QUEUES_TYPES_NUMBER; i++) {\n        xcpFifoReset(&rxFifo[i]);\n    }\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    for (i = 0; i < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER; i++) {\n        xcpFifoReset(&daqTxFifo[i]);\n        xcpFifoReset(&daqDeferredTxFifo[i]);\n        daqTxRequest[i] = false;\n    }\n    lastDaqIdTx = 0xFFFF;\n#endif\n\n    initialized = false;\n\n    return errorCode;\n}\n\n\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}]};