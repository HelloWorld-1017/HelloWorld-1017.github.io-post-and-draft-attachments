# 随机数与伪随机数

随机数生成器的目的是使输出的数字满足 **独立同分布** 的要求。“独立”是指每一个新生成的数 $x_n$ 不依赖于之前的任何一个输出；“同分布”是指生成的数字满足服从同一个总体分布。但是很显然，随机数生成器所要求的“独立”与基于计算机的随机数生成方法是冲突的，因为使用计算机程序是按照程序员的预先设计运行的，它所生成的随机数序列都是可重复的，输出的结果完全可预知，也就必然不独立。程序的可重复性对于一些模拟应用是非常有用的，因此我们需要做的就是让计算机所生成的随机数序列 **尽可能** **看上去** 相互独立（尽管它们必然是不独立的）。因此也就引出了伪随机数的概念——用 **确定性的方法** 生成 **尽量** 独立同分布的随机数。

由于高度不独立的生成方法和对数据独立性的要求，因此还不存在完美的随机数生成算法。正如冯·诺伊曼在1951年所说的，”任何想用 **数学方法** 生成随机数的想法都是有罪的” 。用户只能针对他们要测试的具体问题选择合适的（伪）随机数生成器，然后希望 **生成器的相关性和缺陷不会影响到问题的求解** ，或者主动出击证明这一点。



# 线性同余生成器 LCG

**线性同余生成器 (Linear congruential generator, LCG)** 是一种常用的伪随机数生成器（Pseudo-random number generator, PRNG)，用于在区间 $[0, 1]$ 上产生均匀分布的（伪）随机数。选一个初始整数 $x_0\ne0$，称为种子(seed)。LCG 可以表示为如下形式：
$$
\begin{align*}
x_i &= (ax_{i-1}+b)\ \mathrm{mod}\ (m)\\
u_i &= \dfrac{x_i}{m}
\end{align*}
$$
 其中， $a$ 为乘子，$b$ 为偏移，$m$ 为模数。

假设 $a=13$，$b=0$，$m=31$，种子 $x_0=4$ ，则使用 LCG 生成序列：

```matlab
clc, clear
num = 100;
a = 13;
b = 0;
m = 31;
x0 = 4;

x = zeros(num, 1);
u = zeros(num, 1);

x(1) = x0;
u(1) = x0/m;

for i = 2:num
    x(i) = mod(a*x(i-1), m);
    u(i) = x(i)/m;
end
```

序列 $x$ ：

| $x$  |      |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 4    | 21   | 25   | 15   | 9    | 24   |
| 2    | 26   | 28   | 23   | 20   | 12   |
| 1    | 13   | 14   | 27   | 10   | 6    |
| 16   | 22   | 7    | 29   | 5    | 3    |
| 8    | 11   | 19   | 30   | 18   | 17   |
| 4    | 21   | 25   | 15   | 9    | 24   |
| 2    | 26   | 28   | 23   | 20   | 12   |
| 1    | 13   | 14   | 27   | 10   | 6    |
| 16   | 22   | 7    | 29   | 5    | 3    |
| 8    | 11   | 19   | 30   | 18   | 17   |

序列 $u$ ，即伪随机数数列：

| $u$    |        |        |        |        |        |
| ------ | ------ | ------ | ------ | ------ | ------ |
| 0.1290 | 0.6774 | 0.8065 | 0.4839 | 0.2903 | 0.7742 |
| 0.0645 | 0.8387 | 0.9032 | 0.7419 | 0.6452 | 0.3871 |
| 0.0323 | 0.4194 | 0.4516 | 0.8710 | 0.3226 | 0.1935 |
| 0.5161 | 0.7097 | 0.2258 | 0.9355 | 0.1613 | 0.0968 |
| 0.2581 | 0.3548 | 0.6129 | 0.9677 | 0.5806 | 0.5484 |
| 0.1290 | 0.6774 | 0.8065 | 0.4839 | 0.2903 | 0.7742 |
| 0.0645 | 0.8387 | 0.9032 | 0.7419 | 0.6452 | 0.3871 |
| 0.0323 | 0.4194 | 0.4516 | 0.8710 | 0.3226 | 0.1935 |
| 0.5161 | 0.7097 | 0.2258 | 0.9355 | 0.1613 | 0.0968 |
| 0.2581 | 0.3548 | 0.6129 | 0.9677 | 0.5806 | 0.5484 |

可以看到，该 LCG 的周期为 30，因此这样生成的实数数列完全不是随机的，当种子选好后，生成的 30 个数字的顺序就已经确定了。

周期为 30，也说明该 LCG 最多只能产生 30 个在 $[0,1]$ 区间的伪随机数，如果想要获取更多的随机数，使后续蒙特卡洛模拟的过程更加精确，只需要沿用 LCG 模型，增大 $a$ 和 $m$ 的值即可。



# 最小标准随机数生成器

Park 和 Miller 在1998年提出了一种 LCG，称为“最小标准”随机数生成器，因为它代码简单且能达到较高的精度。在1998年的 MATLAB 第4版中，就使用了这种随机数生成器。

**最小标准随机数生成器**
$$
\begin{align*}
x_i &= (ax_{i-1})\ \mathrm{mod}\ (m)\\
u_i &= \dfrac{x_i}{m}
\end{align*}
$$
其中，$m=2^{31}-1$，$a=7^5=16807$，$b=0$。

形如 $2^p-1$ 的素数（其中 $p$ 为整数），又被称作 **梅森(Mersenne)素数** ，1772年，欧拉首次发现了梅森素数。最小标准随机数生成器的重复周期达到了 $2^{31}-2$ ，这说明只要随机种子非零，它就能遍历小于 $2^{31}-2$ 的所有非零整数，这大概包含 $2\times 10^9$  个数。

==1998年的 MATLAB 第四版就使用的是这种随机数生成器==。





# randu 生成器

**randu 生成器**
$$
\begin{align*}
x_i &= (ax_{i-1})\ \mathrm{mod}\ (m)\\
u_i &= \dfrac{x_i}{m}
\end{align*}
$$
其中，$a=2^{16}+3=65\ 539$，$m=2^{31}$。

随机种子 $x_0\ne0$ 可以任意选取，**非素数模** $m$ 的选取是为了提高取模运算的速度，乘数 $a$ 的选取是因为它的二进制表示非常简单。但是有一个严重的问题就是它 **更加** 不满足随机数的独立性要求。

由于
$$
a^2-6a=(2^{16}+3)^2-6(2^{16}+3) = 2^{32}-9\notag
$$
有
$$
(a^2-6a-9)\ \mathrm{mod}\ m=0\notag
$$
因此
$$
x_{i+2}-6x_{i+1}+9x_i=a^
$$



[Control random number generator - MATLAB rng - MathWorks China](https://ww2.mathworks.cn/help/matlab/ref/rng.html#d123e1281010)
